{"ast":null,"code":"import { keccak_256 } from \"js-sha3\";\nexport class MerkleTree {\n  constructor(leafs) {\n    this.leafs = void 0;\n    this.layers = void 0;\n    this.leafs = leafs.slice();\n    this.layers = [];\n    let hashes = this.leafs.map(MerkleTree.nodeHash);\n\n    while (hashes.length > 0) {\n      console.log(\"Hashes\", this.layers.length, hashes);\n      this.layers.push(hashes.slice());\n      if (hashes.length === 1) break;\n      hashes = hashes.reduce((acc, cur, idx, arr) => {\n        if (idx % 2 === 0) {\n          const nxt = arr[idx + 1];\n          acc.push(MerkleTree.internalHash(cur, nxt));\n        }\n\n        return acc;\n      }, Array());\n    }\n  }\n\n  static nodeHash(data) {\n    return Buffer.from(keccak_256.digest([0x00, ...data]));\n  }\n\n  static internalHash(first, second) {\n    if (!second) return first;\n    const [fst, snd] = [first, second].sort(Buffer.compare);\n    return Buffer.from(keccak_256.digest([0x01, ...fst, ...snd]));\n  }\n\n  getRoot() {\n    return this.layers[this.layers.length - 1][0];\n  }\n\n  getProof(idx) {\n    return this.layers.reduce((proof, layer) => {\n      const sibling = idx ^ 1;\n\n      if (sibling < layer.length) {\n        proof.push(layer[sibling]);\n      }\n\n      idx = Math.floor(idx / 2);\n      return proof;\n    }, []);\n  }\n\n  getHexRoot() {\n    return this.getRoot().toString(\"hex\");\n  }\n\n  getHexProof(idx) {\n    return this.getProof(idx).map(el => el.toString(\"hex\"));\n  }\n\n  verifyProof(idx, proof, root) {\n    let pair = MerkleTree.nodeHash(this.leafs[idx]);\n\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n  static verifyClaim(leaf, proof, root) {\n    let pair = MerkleTree.nodeHash(leaf);\n\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/utils/merkleTree.ts"],"names":["keccak_256","MerkleTree","constructor","leafs","layers","slice","hashes","map","nodeHash","length","console","log","push","reduce","acc","cur","idx","arr","nxt","internalHash","Array","data","Buffer","from","digest","first","second","fst","snd","sort","compare","getRoot","getProof","proof","layer","sibling","Math","floor","getHexRoot","toString","getHexProof","el","verifyProof","root","pair","item","equals","verifyClaim","leaf"],"mappings":"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","sourcesContent":["import { keccak_256 } from \"js-sha3\";\r\n\r\nexport class MerkleTree {\r\n  leafs: Array<Buffer>;\r\n  layers: Array<Array<Buffer>>;\r\n\r\n  constructor(leafs : Array<Buffer>) {\r\n    this.leafs = leafs.slice();\r\n    this.layers = [];\r\n\r\n    let hashes = this.leafs.map(MerkleTree.nodeHash);\r\n    while (hashes.length > 0) {\r\n      console.log(\"Hashes\", this.layers.length, hashes);\r\n      this.layers.push(hashes.slice());\r\n      if (hashes.length === 1) break;\r\n      hashes = hashes.reduce((acc, cur, idx, arr) => {\r\n        if (idx % 2 === 0) {\r\n          const nxt = arr[idx + 1];\r\n          acc.push(MerkleTree.internalHash(cur, nxt));\r\n        }\r\n        return acc;\r\n      }, Array<Buffer>());\r\n    }\r\n  }\r\n\r\n  static nodeHash(\r\n    data : Buffer,\r\n  ) : Buffer {\r\n    return Buffer.from(keccak_256.digest([0x00, ...data]));\r\n  }\r\n\r\n\r\n  static internalHash(\r\n    first : Buffer,\r\n    second : Buffer | undefined,\r\n  ) : Buffer {\r\n    if (!second) return first;\r\n    const [fst, snd] = [first, second].sort(Buffer.compare)\r\n    return Buffer.from(\r\n      keccak_256.digest([0x01, ...fst, ...snd])\r\n    );\r\n  }\r\n\r\n  getRoot() : Buffer {\r\n    return this.layers[this.layers.length - 1][0];\r\n  }\r\n\r\n  getProof(idx : number) : Buffer[] {\r\n    return this.layers.reduce((proof, layer) => {\r\n      const sibling = idx ^ 1;\r\n      if (sibling < layer.length) {\r\n        proof.push(layer[sibling]);\r\n      }\r\n\r\n      idx = Math.floor(idx / 2);\r\n\r\n      return proof;\r\n    }, []);\r\n  }\r\n\r\n  getHexRoot(): string {\r\n    return this.getRoot().toString(\"hex\");\r\n  }\r\n\r\n  getHexProof(idx : number) : string[] {\r\n    return this.getProof(idx).map((el) => el.toString(\"hex\"));\r\n  }\r\n\r\n  verifyProof(\r\n    idx : number,\r\n    proof : Buffer[],\r\n    root : Buffer\r\n  ): boolean {\r\n    let pair = MerkleTree.nodeHash(this.leafs[idx]);\r\n    for (const item of proof) {\r\n      pair = MerkleTree.internalHash(pair, item);\r\n    }\r\n\r\n    return pair.equals(root);\r\n  }\r\n\r\n  static verifyClaim(\r\n    leaf : Buffer,\r\n    proof : Buffer[],\r\n    root : Buffer\r\n  ): boolean {\r\n    let pair = MerkleTree.nodeHash(leaf);\r\n    for (const item of proof) {\r\n      pair = MerkleTree.internalHash(pair, item);\r\n    }\r\n\r\n    return pair.equals(root);\r\n  }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}