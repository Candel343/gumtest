{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Diego\\\\metaplex\\\\js\\\\packages\\\\gumdrop\\\\src\\\\contexts\\\\AccountContext.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n\nimport React, { useCallback, useContext, useEffect, useState } from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintLayout, u64 } from '@solana/spl-token';\nimport { EventEmitter, programIds, chunks, WRAPPED_SOL_MINT } from '@oyster/common';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AccountsContext = /*#__PURE__*/React.createContext(null);\nconst pendingCalls = new Map();\nconst genericCache = new Map();\nconst pendingMintCalls = new Map();\nconst mintCache = new Map();\n\nconst getMintInfo = async (connection, pubKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey, info) => {\n  const buffer = Buffer.from(info.data);\n  const data = deserializeMint(buffer);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: data\n  };\n  return details;\n};\n_c = MintParser;\nexport const TokenAccountParser = (pubKey, info) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n    const details = {\n      pubkey: pubKey,\n      account: { ...info\n      },\n      info: data\n    };\n    return details;\n  }\n};\n_c2 = TokenAccountParser;\nexport const GenericAccountParser = (pubKey, info) => {\n  const buffer = Buffer.from(info.data);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: buffer\n  };\n  return details;\n};\n_c3 = GenericAccountParser;\nexport const keyToAccountParser = new Map();\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (connection, pubKey, parser) => {\n    let id;\n\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    const account = genericCache.get(address);\n\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n\n    if (query) {\n      return query;\n    } // TODO: refactor to use multiple accounts query with flush like behavior\n\n\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    });\n    pendingCalls.set(address, query);\n    return query;\n  },\n  add: (id, obj, parser, isActive) => {\n    const address = typeof id === 'string' ? id : id === null || id === void 0 ? void 0 : id.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n\n    if (!deserialize) {\n      throw new Error('Deserializer needs to be registered or passed as a parameter');\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;else if (isActive instanceof Function) isActive = isActive(account);\n    const isNew = !genericCache.has(address);\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: pubKey => {\n    let key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: pubKey => {\n    let key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n\n    return false;\n  },\n  byParser: parser => {\n    const result = [];\n\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey, parser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey === null || pubkey === void 0 ? void 0 : pubkey.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection, pubKey) => {\n    let id;\n\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    const mint = mintCache.get(address);\n\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n      mintCache.set(address, data);\n      return data;\n    });\n    pendingMintCalls.set(address, query);\n    return query;\n  },\n  getMint: pubKey => {\n    let key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey, obj) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  }\n};\nexport const useAccountsContext = () => {\n  _s();\n\n  const context = useContext(AccountsContext);\n  return context;\n};\n\n_s(useAccountsContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nfunction wrapNativeAccount(pubkey, account) {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null\n    }\n  };\n}\n\nexport const getCachedAccount = predicate => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  _s2();\n\n  const connection = useConnection();\n  const {\n    publicKey\n  } = useWallet();\n  const [nativeAccount, setNativeAccount] = useState();\n  const updateCache = useCallback(account => {\n    if (publicKey) {\n      const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n\n      if (wrapped !== undefined) {\n        const id = publicKey.toBase58();\n        cache.registerParser(id, TokenAccountParser);\n        genericCache.set(id, wrapped);\n        cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n      }\n    }\n  }, [publicKey]);\n  useEffect(() => {\n    let subId = 0;\n\n    const updateAccount = account => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n  return {\n    nativeAccount\n  };\n};\n\n_s2(UseNativeAccount, \"OTr4S3cxOZogJ/lCWrgFDqkUhI0=\", false, function () {\n  return [useConnection, useWallet];\n});\n\n_c4 = UseNativeAccount;\nconst PRECACHED_OWNERS = new Set();\n\nconst precacheUserTokenAccounts = async (connection, owner) => {\n  if (!owner) {\n    return;\n  } // used for filtering account updates over websocket\n\n\n  PRECACHED_OWNERS.add(owner.toBase58()); // user accounts are updated via ws subscription\n\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token\n  });\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({\n  children = undefined\n}) {\n  _s3();\n\n  const connection = useConnection();\n  const {\n    publicKey\n  } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState([]);\n  const [userAccounts, setUserAccounts] = useState([]);\n  const {\n    nativeAccount\n  } = UseNativeAccount();\n  const walletKey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58();\n  const selectUserAccounts = useCallback(() => {\n    return cache.byParser(TokenAccountParser).map(id => cache.get(id)).filter(a => a && a.info.owner.toBase58() === walletKey).map(a => a);\n  }, [walletKey]);\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(a => a !== undefined);\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n  useEffect(() => {\n    const subs = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        const id = args.id;\n        const deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      }); // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n\n      const tokenSubID = connection.onProgramAccountChange(programIds().token, info => {\n        // TODO: fix type in web3.js\n        const id = info.accountId; // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n\n        if (info.accountInfo.data.length === AccountLayout.span) {\n          const data = deserializeAccount(info.accountInfo.data);\n\n          if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n            cache.add(id, info.accountInfo, TokenAccountParser);\n            setTokenAccounts(selectUserAccounts());\n          }\n        }\n      }, 'singleGossip');\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n  return /*#__PURE__*/_jsxDEV(AccountsContext.Provider, {\n    value: {\n      userAccounts,\n      nativeAccount\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 463,\n    columnNumber: 5\n  }, this);\n}\n\n_s3(AccountsProvider, \"rH7wjNGIgr2b5YjMncNLx7kEdSw=\", false, function () {\n  return [useConnection, useWallet];\n});\n\n_c5 = AccountsProvider;\nexport function useNativeAccount() {\n  _s4();\n\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount\n  };\n}\n\n_s4(useNativeAccount, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nexport const getMultipleAccounts = async (connection, keys, commitment) => {\n  const result = await Promise.all(chunks(keys, 99).map(chunk => getMultipleAccountsCore(connection, chunk, commitment)));\n  const array = result.map(a => a.array.map(acc => {\n    if (!acc) {\n      return undefined;\n    }\n\n    const {\n      data,\n      ...rest\n    } = acc;\n    const obj = { ...rest,\n      data: Buffer.from(data[0], 'base64')\n    };\n    return obj;\n  })).flat();\n  return {\n    keys,\n    array\n  };\n};\n\nconst getMultipleAccountsCore = async (connection, keys, commitment) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n\n  if (unsafeRes.error) {\n    throw new Error('failed to get info about account ' + unsafeRes.error.message);\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value;\n    return {\n      keys,\n      array\n    };\n  } // TODO: fix\n\n\n  throw new Error();\n};\n\nexport function useMint(key) {\n  _s5();\n\n  const connection = useConnection();\n  const [mint, setMint] = useState();\n  const id = typeof key === 'string' ? key : key === null || key === void 0 ? void 0 : key.toBase58();\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache.query(connection, id, MintParser).then(acc => setMint(acc.info)).catch(err => console.log(err));\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n\n      if (event.id === id) {\n        cache.query(connection, id, MintParser).then(mint => setMint(mint.info));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n  return mint;\n}\n\n_s5(useMint, \"/CLPph+bq3vWsAHzlMV9EjOrpgE=\", false, function () {\n  return [useConnection];\n});\n\nexport function useAccount(pubKey) {\n  _s6();\n\n  const connection = useConnection();\n  const [account, setAccount] = useState();\n  const key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache.query(connection, key, TokenAccountParser).catch(err => console.log(err));\n\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n  return account;\n} // TODO: expose in spl package\n\n_s6(useAccount, \"HSyiSFcaOPcHMh5tpuogKXQKciU=\", false, function () {\n  return [useConnection];\n});\n\nexport const deserializeAccount = data => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n}; // TODO: expose in spl package\n\nexport const deserializeMint = data => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo;\n};\n\nvar _c, _c2, _c3, _c4, _c5;\n\n$RefreshReg$(_c, \"MintParser\");\n$RefreshReg$(_c2, \"TokenAccountParser\");\n$RefreshReg$(_c3, \"GenericAccountParser\");\n$RefreshReg$(_c4, \"UseNativeAccount\");\n$RefreshReg$(_c5, \"AccountsProvider\");","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/contexts/AccountContext.tsx"],"names":["React","useCallback","useContext","useEffect","useState","useConnection","useWallet","PublicKey","AccountLayout","MintLayout","u64","EventEmitter","programIds","chunks","WRAPPED_SOL_MINT","AccountsContext","createContext","pendingCalls","Map","genericCache","pendingMintCalls","mintCache","getMintInfo","connection","pubKey","info","getAccountInfo","Error","data","Buffer","from","deserializeMint","MintParser","buffer","details","pubkey","account","TokenAccountParser","length","deserializeAccount","GenericAccountParser","keyToAccountParser","cache","emitter","query","parser","id","address","toBase58","get","then","add","set","obj","isActive","deserialize","registerParser","delete","undefined","Function","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","result","keys","push","queryMint","mint","getMint","addMint","useAccountsContext","context","wrapNativeAccount","owner","amount","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","getCachedAccount","predicate","values","UseNativeAccount","publicKey","nativeAccount","setNativeAccount","updateCache","wrapped","subId","updateAccount","onAccountChange","removeAccountChangeListener","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","accounts","getTokenAccountsByOwner","programId","token","value","forEach","AccountsProvider","children","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","walletKey","selectUserAccounts","map","filter","a","subs","onCache","args","tokenSubID","onProgramAccountChange","accountId","accountInfo","span","removeProgramAccountChangeListener","useNativeAccount","getMultipleAccounts","commitment","Promise","all","chunk","getMultipleAccountsCore","array","acc","rest","flat","_buildArgs","unsafeRes","_rpcRequest","error","message","useMint","setMint","catch","err","console","log","dispose","e","event","useAccount","setAccount","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority"],"mappings":"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","sourcesContent":["import React, {\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useState,\r\n} from 'react';\r\nimport { useConnection } from './ConnectionContext';\r\nimport { useWallet } from '@solana/wallet-adapter-react';\r\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\r\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\r\nimport { EventEmitter, programIds, chunks, StringPublicKey, WRAPPED_SOL_MINT } from '@oyster/common';\r\n\r\nimport { TokenAccount } from '../models';\r\n\r\nconst AccountsContext = React.createContext<any>(null);\r\n\r\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\r\nconst genericCache = new Map<string, ParsedAccountBase>();\r\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\r\nconst mintCache = new Map<string, MintInfo>();\r\n\r\nexport interface ParsedAccountBase {\r\n  pubkey: StringPublicKey;\r\n  account: AccountInfo<Buffer>;\r\n  info: any; // TODO: change to unknown\r\n}\r\n\r\nexport type AccountParser = (\r\n  pubkey: StringPublicKey,\r\n  data: AccountInfo<Buffer>,\r\n) => ParsedAccountBase | undefined;\r\n\r\nexport interface ParsedAccount<T> extends ParsedAccountBase {\r\n  info: T;\r\n}\r\n\r\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\r\n  const info = await connection.getAccountInfo(pubKey);\r\n  if (info === null) {\r\n    throw new Error('Failed to find mint account');\r\n  }\r\n\r\n  const data = Buffer.from(info.data);\r\n\r\n  return deserializeMint(data);\r\n};\r\n\r\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\r\n  const buffer = Buffer.from(info.data);\r\n\r\n  const data = deserializeMint(buffer);\r\n\r\n  const details = {\r\n    pubkey: pubKey,\r\n    account: {\r\n      ...info,\r\n    },\r\n    info: data,\r\n  } as ParsedAccountBase;\r\n\r\n  return details;\r\n};\r\n\r\nexport const TokenAccountParser = (\r\n  pubKey: string,\r\n  info: AccountInfo<Buffer>,\r\n) => {\r\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\r\n  // triggers an update over wss which triggers this guy to get called\r\n  // since your UI already logged that pubkey as a token account. Check for length.\r\n  if (info.data.length > 0) {\r\n    const buffer = Buffer.from(info.data);\r\n    const data = deserializeAccount(buffer);\r\n\r\n    const details = {\r\n      pubkey: pubKey,\r\n      account: {\r\n        ...info,\r\n      },\r\n      info: data,\r\n    } as TokenAccount;\r\n\r\n    return details;\r\n  }\r\n};\r\n\r\nexport const GenericAccountParser = (\r\n  pubKey: string,\r\n  info: AccountInfo<Buffer>,\r\n) => {\r\n  const buffer = Buffer.from(info.data);\r\n\r\n  const details = {\r\n    pubkey: pubKey,\r\n    account: {\r\n      ...info,\r\n    },\r\n    info: buffer,\r\n  } as ParsedAccountBase;\r\n\r\n  return details;\r\n};\r\n\r\nexport const keyToAccountParser = new Map<string, AccountParser>();\r\n\r\nexport const cache = {\r\n  emitter: new EventEmitter(),\r\n  query: async (\r\n    connection: Connection,\r\n    pubKey: string | PublicKey,\r\n    parser?: AccountParser,\r\n  ) => {\r\n    let id: PublicKey;\r\n    if (typeof pubKey === 'string') {\r\n      id = new PublicKey(pubKey);\r\n    } else {\r\n      id = pubKey;\r\n    }\r\n\r\n    const address = id.toBase58();\r\n\r\n    const account = genericCache.get(address);\r\n    if (account) {\r\n      return account;\r\n    }\r\n\r\n    let query = pendingCalls.get(address);\r\n    if (query) {\r\n      return query;\r\n    }\r\n\r\n    // TODO: refactor to use multiple accounts query with flush like behavior\r\n    query = connection.getAccountInfo(id).then(data => {\r\n      if (!data) {\r\n        throw new Error('Account not found');\r\n      }\r\n\r\n      return cache.add(id, data, parser);\r\n    }) as Promise<TokenAccount>;\r\n    pendingCalls.set(address, query as any);\r\n\r\n    return query;\r\n  },\r\n  add: (\r\n    id: PublicKey | string,\r\n    obj: AccountInfo<Buffer>,\r\n    parser?: AccountParser,\r\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\r\n  ) => {\r\n    const address = typeof id === 'string' ? id : id?.toBase58();\r\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\r\n    if (!deserialize) {\r\n      throw new Error(\r\n        'Deserializer needs to be registered or passed as a parameter',\r\n      );\r\n    }\r\n\r\n    cache.registerParser(id, deserialize);\r\n    pendingCalls.delete(address);\r\n    const account = deserialize(address, obj);\r\n    if (!account) {\r\n      return;\r\n    }\r\n\r\n    if (isActive === undefined) isActive = true;\r\n    else if (isActive instanceof Function) isActive = isActive(account);\r\n\r\n    const isNew = !genericCache.has(address);\r\n\r\n    genericCache.set(address, account);\r\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\r\n    return account;\r\n  },\r\n  get: (pubKey: string | PublicKey) => {\r\n    let key: string;\r\n    if (typeof pubKey !== 'string') {\r\n      key = pubKey.toBase58();\r\n    } else {\r\n      key = pubKey;\r\n    }\r\n\r\n    return genericCache.get(key);\r\n  },\r\n  delete: (pubKey: string | PublicKey) => {\r\n    let key: string;\r\n    if (typeof pubKey !== 'string') {\r\n      key = pubKey.toBase58();\r\n    } else {\r\n      key = pubKey;\r\n    }\r\n\r\n    if (genericCache.get(key)) {\r\n      genericCache.delete(key);\r\n      cache.emitter.raiseCacheDeleted(key);\r\n      return true;\r\n    }\r\n    return false;\r\n  },\r\n\r\n  byParser: (parser: AccountParser) => {\r\n    const result: string[] = [];\r\n    for (const id of keyToAccountParser.keys()) {\r\n      if (keyToAccountParser.get(id) === parser) {\r\n        result.push(id);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  },\r\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\r\n    if (pubkey) {\r\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\r\n      keyToAccountParser.set(address, parser);\r\n    }\r\n\r\n    return pubkey;\r\n  },\r\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\r\n    let id: PublicKey;\r\n    if (typeof pubKey === 'string') {\r\n      id = new PublicKey(pubKey);\r\n    } else {\r\n      id = pubKey;\r\n    }\r\n\r\n    const address = id.toBase58();\r\n    const mint = mintCache.get(address);\r\n    if (mint) {\r\n      return mint;\r\n    }\r\n\r\n    let query = pendingMintCalls.get(address);\r\n    if (query) {\r\n      return query;\r\n    }\r\n\r\n    query = getMintInfo(connection, id).then(data => {\r\n      pendingMintCalls.delete(address);\r\n\r\n      mintCache.set(address, data);\r\n      return data;\r\n    }) as Promise<MintInfo>;\r\n    pendingMintCalls.set(address, query as any);\r\n\r\n    return query;\r\n  },\r\n  getMint: (pubKey: string | PublicKey) => {\r\n    let key: string;\r\n    if (typeof pubKey !== 'string') {\r\n      key = pubKey.toBase58();\r\n    } else {\r\n      key = pubKey;\r\n    }\r\n\r\n    return mintCache.get(key);\r\n  },\r\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\r\n    const mint = deserializeMint(obj.data);\r\n    const id = pubKey.toBase58();\r\n    mintCache.set(id, mint);\r\n    return mint;\r\n  },\r\n};\r\n\r\nexport const useAccountsContext = () => {\r\n  const context = useContext(AccountsContext);\r\n\r\n  return context;\r\n};\r\n\r\nfunction wrapNativeAccount(\r\n  pubkey: string,\r\n  account?: AccountInfo<Buffer>,\r\n): TokenAccount | undefined {\r\n  if (!account) {\r\n    return undefined;\r\n  }\r\n\r\n  const key = new PublicKey(pubkey);\r\n\r\n  return {\r\n    pubkey: pubkey,\r\n    account,\r\n    info: {\r\n      address: key,\r\n      mint: WRAPPED_SOL_MINT,\r\n      owner: key,\r\n      amount: new u64(account.lamports),\r\n      delegate: null,\r\n      delegatedAmount: new u64(0),\r\n      isInitialized: true,\r\n      isFrozen: false,\r\n      isNative: true,\r\n      rentExemptReserve: null,\r\n      closeAuthority: null,\r\n    },\r\n  };\r\n}\r\n\r\nexport const getCachedAccount = (\r\n  predicate: (account: TokenAccount) => boolean,\r\n) => {\r\n  for (const account of genericCache.values()) {\r\n    if (predicate(account)) {\r\n      return account as TokenAccount;\r\n    }\r\n  }\r\n};\r\n\r\nconst UseNativeAccount = () => {\r\n  const connection = useConnection();\r\n  const { publicKey } = useWallet();\r\n\r\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\r\n\r\n  const updateCache = useCallback(\r\n    account => {\r\n      if (publicKey) {\r\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\r\n        if (wrapped !== undefined) {\r\n          const id = publicKey.toBase58();\r\n          cache.registerParser(id, TokenAccountParser);\r\n          genericCache.set(id, wrapped as TokenAccount);\r\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\r\n        }\r\n      }\r\n    },\r\n    [publicKey],\r\n  );\r\n\r\n  useEffect(() => {\r\n    let subId = 0;\r\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\r\n      if (account) {\r\n        updateCache(account);\r\n        setNativeAccount(account);\r\n      }\r\n    };\r\n\r\n    (async () => {\r\n      if (!connection || !publicKey) {\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const account = await connection.getAccountInfo(publicKey);\r\n        updateAccount(account);\r\n      } catch {\r\n        return;\r\n      }\r\n\r\n      subId = connection.onAccountChange(publicKey, updateAccount);\r\n    })();\r\n\r\n    return () => {\r\n      if (subId) {\r\n        connection.removeAccountChangeListener(subId);\r\n      }\r\n    };\r\n  }, [setNativeAccount, publicKey, connection, updateCache]);\r\n\r\n  return { nativeAccount };\r\n};\r\n\r\nconst PRECACHED_OWNERS = new Set<string>();\r\nconst precacheUserTokenAccounts = async (\r\n  connection: Connection,\r\n  owner?: PublicKey,\r\n) => {\r\n  if (!owner) {\r\n    return;\r\n  }\r\n\r\n  // used for filtering account updates over websocket\r\n  PRECACHED_OWNERS.add(owner.toBase58());\r\n\r\n  // user accounts are updated via ws subscription\r\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\r\n    programId: programIds().token,\r\n  });\r\n\r\n  accounts.value.forEach(info => {\r\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\r\n  });\r\n};\r\n\r\nexport function AccountsProvider({ children = undefined } : { children : React.ReactNode }) {\r\n  const connection = useConnection();\r\n  const { publicKey } = useWallet();\r\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\r\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\r\n  const { nativeAccount } = UseNativeAccount();\r\n  const walletKey = publicKey?.toBase58();\r\n\r\n  const selectUserAccounts = useCallback(() => {\r\n    return cache\r\n      .byParser(TokenAccountParser)\r\n      .map(id => cache.get(id))\r\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\r\n      .map(a => a as TokenAccount);\r\n  }, [walletKey]);\r\n\r\n  useEffect(() => {\r\n    const accounts = selectUserAccounts().filter(\r\n      a => a !== undefined,\r\n    ) as TokenAccount[];\r\n    setUserAccounts(accounts);\r\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\r\n\r\n  useEffect(() => {\r\n    const subs: number[] = [];\r\n    cache.emitter.onCache(args => {\r\n      if (args.isNew && args.isActive) {\r\n        const id = args.id;\r\n        const deserialize = args.parser;\r\n        connection.onAccountChange(new PublicKey(id), info => {\r\n          cache.add(id, info, deserialize);\r\n        });\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      subs.forEach(id => connection.removeAccountChangeListener(id));\r\n    };\r\n  }, [connection]);\r\n\r\n  useEffect(() => {\r\n    if (!connection || !publicKey) {\r\n      setTokenAccounts([]);\r\n    } else {\r\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\r\n        setTokenAccounts(selectUserAccounts());\r\n      });\r\n\r\n      // This can return different types of accounts: token-account, mint, multisig\r\n      // TODO: web3.js expose ability to filter.\r\n      // this should use only filter syntax to only get accounts that are owned by user\r\n      const tokenSubID = connection.onProgramAccountChange(\r\n        programIds().token,\r\n        info => {\r\n          // TODO: fix type in web3.js\r\n          const id = info.accountId as unknown as string;\r\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\r\n          if (info.accountInfo.data.length === AccountLayout.span) {\r\n            const data = deserializeAccount(info.accountInfo.data);\r\n\r\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\r\n              cache.add(id, info.accountInfo, TokenAccountParser);\r\n              setTokenAccounts(selectUserAccounts());\r\n            }\r\n          }\r\n        },\r\n        'singleGossip',\r\n      );\r\n\r\n      return () => {\r\n        connection.removeProgramAccountChangeListener(tokenSubID);\r\n      };\r\n    }\r\n  }, [connection, publicKey, selectUserAccounts]);\r\n\r\n  return (\r\n    <AccountsContext.Provider\r\n      value={{\r\n        userAccounts,\r\n        nativeAccount,\r\n      }}\r\n    >\r\n      {children}\r\n    </AccountsContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useNativeAccount() {\r\n  const context = useContext(AccountsContext);\r\n  return {\r\n    account: context.nativeAccount as AccountInfo<Buffer>,\r\n  };\r\n}\r\n\r\nexport const getMultipleAccounts = async (\r\n  connection: any,\r\n  keys: string[],\r\n  commitment: string,\r\n) => {\r\n  const result = await Promise.all(\r\n    chunks(keys, 99).map(chunk =>\r\n      getMultipleAccountsCore(connection, chunk, commitment),\r\n    ),\r\n  );\r\n\r\n  const array = result\r\n    .map(\r\n      a =>\r\n        a.array.map(acc => {\r\n          if (!acc) {\r\n            return undefined;\r\n          }\r\n\r\n          const { data, ...rest } = acc;\r\n          const obj = {\r\n            ...rest,\r\n            data: Buffer.from(data[0], 'base64'),\r\n          } as AccountInfo<Buffer>;\r\n          return obj;\r\n        }) as AccountInfo<Buffer>[],\r\n    )\r\n    .flat();\r\n  return { keys, array };\r\n};\r\n\r\nconst getMultipleAccountsCore = async (\r\n  connection: any,\r\n  keys: string[],\r\n  commitment: string,\r\n) => {\r\n  const args = connection._buildArgs([keys], commitment, 'base64');\r\n\r\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\r\n  if (unsafeRes.error) {\r\n    throw new Error(\r\n      'failed to get info about account ' + unsafeRes.error.message,\r\n    );\r\n  }\r\n\r\n  if (unsafeRes.result.value) {\r\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\r\n    return { keys, array };\r\n  }\r\n\r\n  // TODO: fix\r\n  throw new Error();\r\n};\r\n\r\nexport function useMint(key?: string | PublicKey) {\r\n  const connection = useConnection();\r\n  const [mint, setMint] = useState<MintInfo>();\r\n\r\n  const id = typeof key === 'string' ? key : key?.toBase58();\r\n\r\n  useEffect(() => {\r\n    if (!id) {\r\n      return;\r\n    }\r\n\r\n    cache\r\n      .query(connection, id, MintParser)\r\n      .then(acc => setMint(acc.info as any))\r\n      .catch(err => console.log(err));\r\n\r\n    const dispose = cache.emitter.onCache(e => {\r\n      const event = e;\r\n      if (event.id === id) {\r\n        cache\r\n          .query(connection, id, MintParser)\r\n          .then(mint => setMint(mint.info as any));\r\n      }\r\n    });\r\n    return () => {\r\n      dispose();\r\n    };\r\n  }, [connection, id]);\r\n\r\n  return mint;\r\n}\r\n\r\nexport function useAccount(pubKey?: PublicKey) {\r\n  const connection = useConnection();\r\n  const [account, setAccount] = useState<TokenAccount>();\r\n\r\n  const key = pubKey?.toBase58();\r\n  useEffect(() => {\r\n    const query = async () => {\r\n      try {\r\n        if (!key) {\r\n          return;\r\n        }\r\n\r\n        const acc = await cache\r\n          .query(connection, key, TokenAccountParser)\r\n          .catch(err => console.log(err));\r\n        if (acc) {\r\n          setAccount(acc);\r\n        }\r\n      } catch (err) {\r\n        console.error(err);\r\n      }\r\n    };\r\n\r\n    query();\r\n\r\n    const dispose = cache.emitter.onCache(e => {\r\n      const event = e;\r\n      if (event.id === key) {\r\n        query();\r\n      }\r\n    });\r\n    return () => {\r\n      dispose();\r\n    };\r\n  }, [connection, key]);\r\n\r\n  return account;\r\n}\r\n\r\n// TODO: expose in spl package\r\nexport const deserializeAccount = (data: Buffer) => {\r\n  const accountInfo = AccountLayout.decode(data);\r\n  accountInfo.mint = new PublicKey(accountInfo.mint);\r\n  accountInfo.owner = new PublicKey(accountInfo.owner);\r\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\r\n\r\n  if (accountInfo.delegateOption === 0) {\r\n    accountInfo.delegate = null;\r\n    accountInfo.delegatedAmount = new u64(0);\r\n  } else {\r\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\r\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\r\n  }\r\n\r\n  accountInfo.isInitialized = accountInfo.state !== 0;\r\n  accountInfo.isFrozen = accountInfo.state === 2;\r\n\r\n  if (accountInfo.isNativeOption === 1) {\r\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\r\n    accountInfo.isNative = true;\r\n  } else {\r\n    accountInfo.rentExemptReserve = null;\r\n    accountInfo.isNative = false;\r\n  }\r\n\r\n  if (accountInfo.closeAuthorityOption === 0) {\r\n    accountInfo.closeAuthority = null;\r\n  } else {\r\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\r\n  }\r\n\r\n  return accountInfo;\r\n};\r\n\r\n// TODO: expose in spl package\r\nexport const deserializeMint = (data: Buffer) => {\r\n  if (data.length !== MintLayout.span) {\r\n    throw new Error('Not a valid Mint');\r\n  }\r\n\r\n  const mintInfo = MintLayout.decode(data);\r\n\r\n  if (mintInfo.mintAuthorityOption === 0) {\r\n    mintInfo.mintAuthority = null;\r\n  } else {\r\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\r\n  }\r\n\r\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\r\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\r\n\r\n  if (mintInfo.freezeAuthorityOption === 0) {\r\n    mintInfo.freezeAuthority = null;\r\n  } else {\r\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\r\n  }\r\n\r\n  return mintInfo as MintInfo;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}