{"ast":null,"code":"import _createForOfIteratorHelper from\"C:/Users/Diego/metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _regeneratorRuntime from\"C:/Users/Diego/metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"C:/Users/Diego/metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"C:/Users/Diego/metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _asyncToGenerator from\"C:/Users/Diego/metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import React from\"react\";import queryString from'query-string';import{Box,Button,CircularProgress,FormControl,Link as HyperLink,InputLabel,MenuItem,Select,Stack,Step,StepLabel,Stepper,TextField}from\"@mui/material\";import{useWallet}from\"@solana/wallet-adapter-react\";import{Keypair,PublicKey,SystemProgram,SYSVAR_RENT_PUBKEY,SYSVAR_CLOCK_PUBKEY,Transaction,TransactionInstruction}from\"@solana/web3.js\";import{AccountLayout,MintLayout,Token,TOKEN_PROGRAM_ID}from\"@solana/spl-token\";import{notify}from\"@oyster/common\";import{sha256}from\"js-sha256\";import BN from'bn.js';import*as bs58 from\"bs58\";import{useConnection}from\"../contexts\";import{CANDY_MACHINE_ID,GUMDROP_DISTRIBUTOR_ID,GUMDROP_TEMPORAL_SIGNER,SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,TOKEN_METADATA_PROGRAM_ID}from\"../utils/ids\";import{getCandyMachine,getCandyMachineAddress,getEdition,getEditionMarkerPda,getMetadata}from\"../utils/accounts\";import{MerkleTree}from\"../utils/merkleTree\";import{explorerLinkFor,sendSignedTransaction}from\"../utils/transactions\";import{chunk}from\"../utils/claimant\";import{coder}from\"../utils/merkleDistributor\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var walletKeyOrPda=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(walletKey,handle,pin,seed){var _key,seeds,_yield$PublicKey$find,_yield$PublicKey$find2,claimantPda;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(pin===null)){_context.next=13;break;}_context.prev=1;_key=new PublicKey(handle);if(_key.equals(walletKey)){_context.next=5;break;}throw new Error(\"Claimant wallet handle does not match connected wallet\");case 5:return _context.abrupt(\"return\",[_key,[]]);case 8:_context.prev=8;_context.t0=_context[\"catch\"](1);throw new Error(\"Invalid claimant wallet handle \".concat(_context.t0));case 11:_context.next=20;break;case 13:seeds=[seed.toBuffer(),Buffer.from(handle),Buffer.from(pin.toArray(\"le\",4))];_context.next=16;return PublicKey.findProgramAddress([seeds[0]].concat(_toConsumableArray(chunk(seeds[1],32)),[seeds[2]]),GUMDROP_DISTRIBUTOR_ID);case 16:_yield$PublicKey$find=_context.sent;_yield$PublicKey$find2=_slicedToArray(_yield$PublicKey$find,1);claimantPda=_yield$PublicKey$find2[0];return _context.abrupt(\"return\",[claimantPda,seeds]);case 20:case\"end\":return _context.stop();}}},_callee,null,[[1,8]]);}));return function walletKeyOrPda(_x,_x2,_x3,_x4){return _ref.apply(this,arguments);};}();var buildMintClaim=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection,walletKey,distributorKey,distributorInfo,tokenAcc,proof,handle,amount,index,pin){var tokenAccKey,distTokenAccount,tokenAccountInfo,mint,_yield$walletKeyOrPda,_yield$walletKeyOrPda2,secret,pdaSeeds,leaf,matches,_yield$PublicKey$find3,_yield$PublicKey$find4,claimStatus,cbump,_yield$PublicKey$find5,_yield$PublicKey$find6,walletTokenKey,setup,temporalSigner,claimAirdrop;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.prev=0;tokenAccKey=new PublicKey(tokenAcc);_context2.next=7;break;case 4:_context2.prev=4;_context2.t0=_context2[\"catch\"](0);throw new Error(\"Invalid tokenAcc key \".concat(_context2.t0));case 7:_context2.next=9;return connection.getAccountInfo(tokenAccKey);case 9:distTokenAccount=_context2.sent;if(!(distTokenAccount===null)){_context2.next=12;break;}throw new Error(\"Could not fetch distributor token account\");case 12:tokenAccountInfo=AccountLayout.decode(distTokenAccount.data);mint=new PublicKey(tokenAccountInfo.mint);console.log(mint.toBase58());_context2.next=17;return walletKeyOrPda(walletKey,handle,pin,mint);case 17:_yield$walletKeyOrPda=_context2.sent;_yield$walletKeyOrPda2=_slicedToArray(_yield$walletKeyOrPda,2);secret=_yield$walletKeyOrPda2[0];pdaSeeds=_yield$walletKeyOrPda2[1];// TODO: since it's in the PDA do we need it to be in the leaf?\nleaf=Buffer.from([].concat(_toConsumableArray(new BN(index).toArray(\"le\",8)),_toConsumableArray(secret.toBuffer()),_toConsumableArray(mint.toBuffer()),_toConsumableArray(new BN(amount).toArray(\"le\",8))));matches=MerkleTree.verifyClaim(leaf,proof,Buffer.from(distributorInfo.root));if(matches){_context2.next=25;break;}throw new Error(\"Gumdrop merkle proof does not match\");case 25:_context2.next=27;return PublicKey.findProgramAddress([Buffer.from(\"ClaimStatus\"),Buffer.from(new BN(index).toArray(\"le\",8)),distributorKey.toBuffer()],GUMDROP_DISTRIBUTOR_ID);case 27:_yield$PublicKey$find3=_context2.sent;_yield$PublicKey$find4=_slicedToArray(_yield$PublicKey$find3,2);claimStatus=_yield$PublicKey$find4[0];cbump=_yield$PublicKey$find4[1];_context2.next=33;return PublicKey.findProgramAddress([walletKey.toBuffer(),TOKEN_PROGRAM_ID.toBuffer(),mint.toBuffer()],SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);case 33:_yield$PublicKey$find5=_context2.sent;_yield$PublicKey$find6=_slicedToArray(_yield$PublicKey$find5,1);walletTokenKey=_yield$PublicKey$find6[0];setup=[];_context2.next=39;return connection.getAccountInfo(walletTokenKey);case 39:_context2.t1=_context2.sent;if(!(_context2.t1===null)){_context2.next=42;break;}setup.push(Token.createAssociatedTokenAccountInstruction(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,TOKEN_PROGRAM_ID,mint,walletTokenKey,walletKey,walletKey));case 42:temporalSigner=distributorInfo.temporal.equals(PublicKey.default)||secret.equals(walletKey)?walletKey:distributorInfo.temporal;claimAirdrop=new TransactionInstruction({programId:GUMDROP_DISTRIBUTOR_ID,keys:[{pubkey:distributorKey,isSigner:false,isWritable:true},{pubkey:claimStatus,isSigner:false,isWritable:true},{pubkey:tokenAccKey,isSigner:false,isWritable:true},{pubkey:walletTokenKey,isSigner:false,isWritable:true},{pubkey:temporalSigner,isSigner:true,isWritable:false},{pubkey:walletKey,isSigner:true,isWritable:false},// payer\n{pubkey:SystemProgram.programId,isSigner:false,isWritable:false},{pubkey:TOKEN_PROGRAM_ID,isSigner:false,isWritable:false}],data:Buffer.from([].concat(_toConsumableArray(Buffer.from(sha256.digest(\"global:claim\")).slice(0,8)),_toConsumableArray(new BN(cbump).toArray(\"le\",1)),_toConsumableArray(new BN(index).toArray(\"le\",8)),_toConsumableArray(new BN(amount).toArray(\"le\",8)),_toConsumableArray(secret.toBuffer()),_toConsumableArray(new BN(proof.length).toArray(\"le\",4)),_toConsumableArray(Buffer.concat(proof))))});return _context2.abrupt(\"return\",[[].concat(setup,[claimAirdrop]),pdaSeeds,[]]);case 45:case\"end\":return _context2.stop();}}},_callee2,null,[[0,4]]);}));return function buildMintClaim(_x5,_x6,_x7,_x8,_x9,_x10,_x11,_x12,_x13,_x14){return _ref2.apply(this,arguments);};}();var buildCandyClaim=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection,walletKey,distributorKey,distributorInfo,candyConfig,candyUUID,proof,handle,amount,index,pin){var configKey,_yield$walletKeyOrPda3,_yield$walletKeyOrPda4,secret,pdaSeeds,leaf,matches,_yield$PublicKey$find7,_yield$PublicKey$find8,claimCount,cbump,_yield$PublicKey$find9,_yield$PublicKey$find10,distributorWalletKey,wbump,temporalSigner,setup,claimCountAccount,nftsAlreadyMinted,claimAccountInfo,claimantStr,nftsAvailable,_yield$getCandyMachin,_yield$getCandyMachin2,candyMachineKey,candyMachine,candyMachineMints,_yield$buildSingleCan,_yield$buildSingleCan2,instrs,mint;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;configKey=new PublicKey(candyConfig);_context3.next=7;break;case 4:_context3.prev=4;_context3.t0=_context3[\"catch\"](0);throw new Error(\"Invalid candy config key \".concat(_context3.t0));case 7:_context3.next=9;return walletKeyOrPda(walletKey,handle,pin,configKey);case 9:_yield$walletKeyOrPda3=_context3.sent;_yield$walletKeyOrPda4=_slicedToArray(_yield$walletKeyOrPda3,2);secret=_yield$walletKeyOrPda4[0];pdaSeeds=_yield$walletKeyOrPda4[1];// TODO: since it's in the PDA do we need it to be in the leaf?\nleaf=Buffer.from([].concat(_toConsumableArray(new BN(index).toArray(\"le\",8)),_toConsumableArray(secret.toBuffer()),_toConsumableArray(configKey.toBuffer()),_toConsumableArray(new BN(amount).toArray(\"le\",8))));matches=MerkleTree.verifyClaim(leaf,proof,Buffer.from(distributorInfo.root));if(matches){_context3.next=17;break;}throw new Error(\"Gumdrop merkle proof does not match\");case 17:_context3.next=19;return PublicKey.findProgramAddress([Buffer.from(\"ClaimCount\"),Buffer.from(new BN(index).toArray(\"le\",8)),distributorKey.toBuffer()],GUMDROP_DISTRIBUTOR_ID);case 19:_yield$PublicKey$find7=_context3.sent;_yield$PublicKey$find8=_slicedToArray(_yield$PublicKey$find7,2);claimCount=_yield$PublicKey$find8[0];cbump=_yield$PublicKey$find8[1];_context3.next=25;return PublicKey.findProgramAddress([Buffer.from(\"Wallet\"),distributorKey.toBuffer()],GUMDROP_DISTRIBUTOR_ID);case 25:_yield$PublicKey$find9=_context3.sent;_yield$PublicKey$find10=_slicedToArray(_yield$PublicKey$find9,2);distributorWalletKey=_yield$PublicKey$find10[0];wbump=_yield$PublicKey$find10[1];// atm the contract has a special case for when the temporal key is defaulted\n// (aka always passes temporal check)\n// TODO: more flexible\ntemporalSigner=distributorInfo.temporal.equals(PublicKey.default)||secret.equals(walletKey)?walletKey:distributorInfo.temporal;setup=[];_context3.next=33;return connection.getAccountInfo(claimCount);case 33:claimCountAccount=_context3.sent;nftsAlreadyMinted=0;if(!(claimCountAccount===null)){_context3.next=38;break;}_context3.next=46;break;case 38:// TODO: subtract already minted?...\nclaimAccountInfo=coder.accounts.decode(\"ClaimCount\",claimCountAccount.data);nftsAlreadyMinted=claimAccountInfo.count;if(!claimAccountInfo.claimant.equals(walletKey)){_context3.next=44;break;}// we already proved this claim and verified the OTP once, contract knows\n// that this wallet is OK\ntemporalSigner=walletKey;_context3.next=46;break;case 44:// need to claim with the first wallet...\nclaimantStr=claimAccountInfo.claimant.toBase58();throw new Error(\"This wallet does not match existing claimant \".concat(claimantStr));case 46:nftsAvailable=amount;if(!(nftsAlreadyMinted>=nftsAvailable)){_context3.next=49;break;}throw new Error(\"Cannot mint another NFT. \".concat(nftsAvailable,\" NFT(s) were originally allocated\")+(nftsAlreadyMinted>0?\" and \".concat(nftsAlreadyMinted,\" NFT(s) were already minted\"):\"\"));case 49:_context3.next=51;return getCandyMachineAddress(configKey,candyUUID);case 51:_yield$getCandyMachin=_context3.sent;_yield$getCandyMachin2=_slicedToArray(_yield$getCandyMachin,1);candyMachineKey=_yield$getCandyMachin2[0];_context3.next=56;return getCandyMachine(connection,candyMachineKey);case 56:candyMachine=_context3.sent;console.log(\"Candy Machine\",candyMachine);candyMachineMints=[];_context3.next=61;return buildSingleCandyMint(connection,walletKey,distributorKey,distributorWalletKey,claimCount,temporalSigner,configKey,candyMachineKey,candyMachine.wallet,Buffer.from([].concat(_toConsumableArray(new BN(wbump).toArray(\"le\",1)),_toConsumableArray(new BN(cbump).toArray(\"le\",1)),_toConsumableArray(new BN(index).toArray(\"le\",8)),_toConsumableArray(new BN(amount).toArray(\"le\",8)),_toConsumableArray(secret.toBuffer()),_toConsumableArray(new BN(proof.length).toArray(\"le\",4)),_toConsumableArray(Buffer.concat(proof)))));case 61:_yield$buildSingleCan=_context3.sent;_yield$buildSingleCan2=_slicedToArray(_yield$buildSingleCan,2);instrs=_yield$buildSingleCan2[0];mint=_yield$buildSingleCan2[1];candyMachineMints.push(mint);setup.push.apply(setup,_toConsumableArray(instrs));return _context3.abrupt(\"return\",[setup,pdaSeeds,candyMachineMints]);case 68:case\"end\":return _context3.stop();}}},_callee3,null,[[0,4]]);}));return function buildCandyClaim(_x15,_x16,_x17,_x18,_x19,_x20,_x21,_x22,_x23,_x24,_x25){return _ref3.apply(this,arguments);};}();var buildSingleCandyMint=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(connection,walletKey,distributorKey,distributorWalletKey,claimCount,temporalSigner,configKey,candyMachineKey,candyMachineWallet,data){var candyMachineMint,candyMachineMetadata,candyMachineMaster,setup;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:candyMachineMint=Keypair.generate();_context4.next=3;return getMetadata(candyMachineMint.publicKey);case 3:candyMachineMetadata=_context4.sent;_context4.next=6;return getEdition(candyMachineMint.publicKey);case 6:candyMachineMaster=_context4.sent;setup=[];_context4.next=10;return createMintAndAccount(connection,walletKey,candyMachineMint.publicKey,setup);case 10:setup.push(new TransactionInstruction({programId:GUMDROP_DISTRIBUTOR_ID,keys:[{pubkey:distributorKey,isSigner:false,isWritable:true},{pubkey:distributorWalletKey,isSigner:false,isWritable:true},{pubkey:claimCount,isSigner:false,isWritable:true},{pubkey:temporalSigner,isSigner:true,isWritable:false},{pubkey:walletKey,isSigner:true,isWritable:false},// payer\n{pubkey:configKey,isSigner:false,isWritable:true},{pubkey:candyMachineKey,isSigner:false,isWritable:true},{pubkey:candyMachineWallet,isSigner:false,isWritable:true},{pubkey:candyMachineMint.publicKey,isSigner:false,isWritable:true},{pubkey:candyMachineMetadata,isSigner:false,isWritable:true},{pubkey:candyMachineMaster,isSigner:false,isWritable:true},{pubkey:SystemProgram.programId,isSigner:false,isWritable:false},{pubkey:TOKEN_PROGRAM_ID,isSigner:false,isWritable:false},{pubkey:TOKEN_METADATA_PROGRAM_ID,isSigner:false,isWritable:false},{pubkey:CANDY_MACHINE_ID,isSigner:false,isWritable:false},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:false,isWritable:false},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:false,isWritable:false}],data:Buffer.from([].concat(_toConsumableArray(Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0,8)),_toConsumableArray(data)))}));return _context4.abrupt(\"return\",[setup,candyMachineMint]);case 12:case\"end\":return _context4.stop();}}},_callee4);}));return function buildSingleCandyMint(_x26,_x27,_x28,_x29,_x30,_x31,_x32,_x33,_x34,_x35){return _ref4.apply(this,arguments);};}();var createMintAndAccount=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connection,walletKey,mint,setup){var _yield$PublicKey$find11,_yield$PublicKey$find12,walletTokenKey;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return PublicKey.findProgramAddress([walletKey.toBuffer(),TOKEN_PROGRAM_ID.toBuffer(),mint.toBuffer()],SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);case 2:_yield$PublicKey$find11=_context5.sent;_yield$PublicKey$find12=_slicedToArray(_yield$PublicKey$find11,1);walletTokenKey=_yield$PublicKey$find12[0];_context5.t0=setup;_context5.t1=SystemProgram;_context5.t2=walletKey;_context5.t3=mint;_context5.t4=MintLayout.span;_context5.next=12;return connection.getMinimumBalanceForRentExemption(MintLayout.span);case 12:_context5.t5=_context5.sent;_context5.t6=TOKEN_PROGRAM_ID;_context5.t7={fromPubkey:_context5.t2,newAccountPubkey:_context5.t3,space:_context5.t4,lamports:_context5.t5,programId:_context5.t6};_context5.t8=_context5.t1.createAccount.call(_context5.t1,_context5.t7);_context5.t0.push.call(_context5.t0,_context5.t8);setup.push(Token.createInitMintInstruction(TOKEN_PROGRAM_ID,mint,0,walletKey,walletKey));setup.push(Token.createAssociatedTokenAccountInstruction(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,TOKEN_PROGRAM_ID,mint,walletTokenKey,walletKey,walletKey));setup.push(Token.createMintToInstruction(TOKEN_PROGRAM_ID,mint,walletTokenKey,walletKey,[],1));case 20:case\"end\":return _context5.stop();}}},_callee5);}));return function createMintAndAccount(_x36,_x37,_x38,_x39){return _ref5.apply(this,arguments);};}();var buildEditionClaim=/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(connection,walletKey,distributorKey,distributorInfo,masterMint,edition,proof,handle,amount,index,pin){var masterMintKey,_yield$walletKeyOrPda5,_yield$walletKeyOrPda6,secret,pdaSeeds,leaf,matches,_yield$PublicKey$find13,_yield$PublicKey$find14,claimCount,cbump,temporalSigner,claimCountAccount,setup,newMint,newMetadataKey,masterMetadataKey,newEdition,masterEdition,_yield$PublicKey$find15,_yield$PublicKey$find16,distributorTokenKey,editionMarkKey;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.prev=0;masterMintKey=new PublicKey(masterMint);_context6.next=7;break;case 4:_context6.prev=4;_context6.t0=_context6[\"catch\"](0);throw new Error(\"Invalid master mint key \".concat(_context6.t0));case 7:_context6.next=9;return walletKeyOrPda(walletKey,handle,pin,masterMintKey);case 9:_yield$walletKeyOrPda5=_context6.sent;_yield$walletKeyOrPda6=_slicedToArray(_yield$walletKeyOrPda5,2);secret=_yield$walletKeyOrPda6[0];pdaSeeds=_yield$walletKeyOrPda6[1];// should we assert that the amount is 1?\nleaf=Buffer.from([].concat(_toConsumableArray(new BN(index).toArray(\"le\",8)),_toConsumableArray(secret.toBuffer()),_toConsumableArray(masterMintKey.toBuffer()),_toConsumableArray(new BN(amount).toArray(\"le\",8)),_toConsumableArray(new BN(edition).toArray(\"le\",8))));matches=MerkleTree.verifyClaim(leaf,proof,Buffer.from(distributorInfo.root));if(matches){_context6.next=17;break;}throw new Error(\"Gumdrop merkle proof does not match\");case 17:_context6.next=19;return PublicKey.findProgramAddress([Buffer.from(\"ClaimCount\"),Buffer.from(new BN(index).toArray(\"le\",8)),distributorKey.toBuffer()],GUMDROP_DISTRIBUTOR_ID);case 19:_yield$PublicKey$find13=_context6.sent;_yield$PublicKey$find14=_slicedToArray(_yield$PublicKey$find13,2);claimCount=_yield$PublicKey$find14[0];cbump=_yield$PublicKey$find14[1];// atm the contract has a special case for when the temporal key is defaulted\n// (aka always passes temporal check)\n// TODO: more flexible\ntemporalSigner=distributorInfo.temporal.equals(PublicKey.default)||secret.equals(walletKey)?walletKey:distributorInfo.temporal;_context6.next=26;return connection.getAccountInfo(claimCount);case 26:claimCountAccount=_context6.sent;if(!(claimCountAccount!==null)){_context6.next=29;break;}throw new Error(\"This edition was already claimed\");case 29:setup=[];newMint=Keypair.generate();_context6.next=33;return getMetadata(newMint.publicKey);case 33:newMetadataKey=_context6.sent;_context6.next=36;return getMetadata(masterMintKey);case 36:masterMetadataKey=_context6.sent;_context6.next=39;return getEdition(newMint.publicKey);case 39:newEdition=_context6.sent;_context6.next=42;return getEdition(masterMintKey);case 42:masterEdition=_context6.sent;_context6.next=45;return createMintAndAccount(connection,walletKey,newMint.publicKey,setup);case 45:_context6.next=47;return PublicKey.findProgramAddress([distributorKey.toBuffer(),TOKEN_PROGRAM_ID.toBuffer(),masterMintKey.toBuffer()],SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);case 47:_yield$PublicKey$find15=_context6.sent;_yield$PublicKey$find16=_slicedToArray(_yield$PublicKey$find15,1);distributorTokenKey=_yield$PublicKey$find16[0];_context6.next=52;return getEditionMarkerPda(masterMintKey,new BN(edition));case 52:editionMarkKey=_context6.sent;setup.push(new TransactionInstruction({programId:GUMDROP_DISTRIBUTOR_ID,keys:[{pubkey:distributorKey,isSigner:false,isWritable:true},{pubkey:claimCount,isSigner:false,isWritable:true},{pubkey:temporalSigner,isSigner:true,isWritable:false},{pubkey:walletKey,isSigner:true,isWritable:false},// payer\n{pubkey:newMetadataKey,isSigner:false,isWritable:true},{pubkey:newEdition,isSigner:false,isWritable:true},{pubkey:masterEdition,isSigner:false,isWritable:true},{pubkey:newMint.publicKey,isSigner:false,isWritable:true},{pubkey:editionMarkKey,isSigner:false,isWritable:true},{pubkey:walletKey,isSigner:true,isWritable:false},// `newMint` auth\n{pubkey:distributorTokenKey,isSigner:false,isWritable:false},{pubkey:walletKey,isSigner:false,isWritable:false},// new update auth\n{pubkey:masterMetadataKey,isSigner:false,isWritable:false},{pubkey:masterMintKey,isSigner:false,isWritable:false},{pubkey:SystemProgram.programId,isSigner:false,isWritable:false},{pubkey:TOKEN_PROGRAM_ID,isSigner:false,isWritable:false},{pubkey:TOKEN_METADATA_PROGRAM_ID,isSigner:false,isWritable:false},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:false,isWritable:false}],data:Buffer.from([].concat(_toConsumableArray(Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0,8)),_toConsumableArray(new BN(cbump).toArray(\"le\",1)),_toConsumableArray(new BN(index).toArray(\"le\",8)),_toConsumableArray(new BN(amount).toArray(\"le\",8)),_toConsumableArray(new BN(edition).toArray(\"le\",8)),_toConsumableArray(secret.toBuffer()),_toConsumableArray(new BN(proof.length).toArray(\"le\",4)),_toConsumableArray(Buffer.concat(proof))))}));return _context6.abrupt(\"return\",[setup,pdaSeeds,[newMint]]);case 55:case\"end\":return _context6.stop();}}},_callee6,null,[[0,4]]);}));return function buildEditionClaim(_x40,_x41,_x42,_x43,_x44,_x45,_x46,_x47,_x48,_x49,_x50){return _ref6.apply(this,arguments);};}();var fetchDistributor=/*#__PURE__*/function(){var _ref7=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(connection,distributorStr){var key,account,ownerStr,info;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:_context7.prev=0;key=new PublicKey(distributorStr);_context7.next=7;break;case 4:_context7.prev=4;_context7.t0=_context7[\"catch\"](0);throw new Error(\"Invalid distributor key \".concat(_context7.t0));case 7:_context7.next=9;return connection.getAccountInfo(key);case 9:account=_context7.sent;if(!(account===null)){_context7.next=12;break;}throw new Error(\"Could not fetch distributor \".concat(distributorStr));case 12:if(account.owner.equals(GUMDROP_DISTRIBUTOR_ID)){_context7.next=15;break;}ownerStr=account.owner.toBase58();throw new Error(\"Invalid distributor owner \".concat(ownerStr));case 15:info=coder.accounts.decode(\"MerkleDistributor\",account.data);return _context7.abrupt(\"return\",[key,info]);case 17:case\"end\":return _context7.stop();}}},_callee7,null,[[0,4]]);}));return function fetchDistributor(_x51,_x52){return _ref7.apply(this,arguments);};}();var fetchNeedsTemporalSigner=/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(connection,distributorStr,indexStr,claimMethod){var _yield$fetchDistribut,_yield$fetchDistribut2,key,info,_yield$PublicKey$find17,_yield$PublicKey$find18,claimCount,claimCountAccount;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:_context8.next=2;return fetchDistributor(connection,distributorStr);case 2:_yield$fetchDistribut=_context8.sent;_yield$fetchDistribut2=_slicedToArray(_yield$fetchDistribut,2);key=_yield$fetchDistribut2[0];info=_yield$fetchDistribut2[1];if(info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)){_context8.next=10;break;}return _context8.abrupt(\"return\",false);case 10:if(!(claimMethod===\"candy\")){_context8.next=22;break;}_context8.next=13;return PublicKey.findProgramAddress([Buffer.from(\"ClaimCount\"),Buffer.from(new BN(Number(indexStr)).toArray(\"le\",8)),key.toBuffer()],GUMDROP_DISTRIBUTOR_ID);case 13:_yield$PublicKey$find17=_context8.sent;_yield$PublicKey$find18=_slicedToArray(_yield$PublicKey$find17,1);claimCount=_yield$PublicKey$find18[0];_context8.next=18;return connection.getAccountInfo(claimCount);case 18:claimCountAccount=_context8.sent;return _context8.abrupt(\"return\",claimCountAccount===null);case 22:return _context8.abrupt(\"return\",true);case 23:case\"end\":return _context8.stop();}}},_callee8);}));return function fetchNeedsTemporalSigner(_x53,_x54,_x55,_x56){return _ref8.apply(this,arguments);};}();export var Claim=function Claim(props){var connection=useConnection();var wallet=useWallet();var query=props.location.search;if(query&&query.length>0){localStorage.setItem(\"claimQuery\",query);}else{var stored=localStorage.getItem(\"claimQuery\");if(stored)query=stored;}var params=queryString.parse(query);var _React$useState=React.useState(params.distributor||\"\"),_React$useState2=_slicedToArray(_React$useState,2),distributor=_React$useState2[0],setDistributor=_React$useState2[1];var _React$useState3=React.useState(params.tokenAcc?\"transfer\":params.config?\"candy\":params.master?\"edition\":\"\"),_React$useState4=_slicedToArray(_React$useState3,2),claimMethod=_React$useState4[0],setClaimMethod=_React$useState4[1];var _React$useState5=React.useState(params.tokenAcc||\"\"),_React$useState6=_slicedToArray(_React$useState5,2),tokenAcc=_React$useState6[0],setTokenAcc=_React$useState6[1];var _React$useState7=React.useState(params.config||\"\"),_React$useState8=_slicedToArray(_React$useState7,2),candyConfig=_React$useState8[0],setCandyConfig=_React$useState8[1];var _React$useState9=React.useState(params.uuid||\"\"),_React$useState10=_slicedToArray(_React$useState9,2),candyUUID=_React$useState10[0],setCandyUUID=_React$useState10[1];var _React$useState11=React.useState(params.master||\"\"),_React$useState12=_slicedToArray(_React$useState11,2),masterMint=_React$useState12[0],setMasterMint=_React$useState12[1];var _React$useState13=React.useState(params.edition||\"\"),_React$useState14=_slicedToArray(_React$useState13,2),editionStr=_React$useState14[0],setEditionStr=_React$useState14[1];var _React$useState15=React.useState(params.handle||\"\"),_React$useState16=_slicedToArray(_React$useState15,2),handle=_React$useState16[0],setHandle=_React$useState16[1];var _React$useState17=React.useState(params.amount||\"\"),_React$useState18=_slicedToArray(_React$useState17,2),amountStr=_React$useState18[0],setAmount=_React$useState18[1];var _React$useState19=React.useState(params.index||\"\"),_React$useState20=_slicedToArray(_React$useState19,2),indexStr=_React$useState20[0],setIndex=_React$useState20[1];var _React$useState21=React.useState(params.pin||\"\"),_React$useState22=_slicedToArray(_React$useState21,2),pinStr=_React$useState22[0],setPin=_React$useState22[1];var _React$useState23=React.useState(params.proof||\"\"),_React$useState24=_slicedToArray(_React$useState23,2),proofStr=_React$useState24[0],setProof=_React$useState24[1];var discordGuild=params.guild;var allFieldsPopulated=distributor.length>0&&(claimMethod===\"transfer\"?tokenAcc.length>0:claimMethod===\"candy\"?candyConfig.length>0&&candyUUID.length>0:claimMethod===\"edition\"?masterMint.length>0&&editionStr.length>0:false)&&handle.length>0&&amountStr.length>0&&indexStr.length>0;// NB: pin can be empty if handle is a public-key and we are claiming through wallets\n// NB: proof can be empty!\nvar _React$useState25=React.useState(!allFieldsPopulated),_React$useState26=_slicedToArray(_React$useState25,2),editable=_React$useState26[0],setEditable=_React$useState26[1];// temporal verification\nvar _React$useState27=React.useState(null),_React$useState28=_slicedToArray(_React$useState27,2),transaction=_React$useState28[0],setTransaction=_React$useState28[1];var _React$useState29=React.useState(\"\"),_React$useState30=_slicedToArray(_React$useState29,2),OTPStr=_React$useState30[0],setOTPStr=_React$useState30[1];// async computed\nvar _React$useState31=React.useState(true),_React$useState32=_slicedToArray(_React$useState31,2),asyncNeedsTemporalSigner=_React$useState32[0],setNeedsTemporalSigner=_React$useState32[1];React.useEffect(function(){var wrap=/*#__PURE__*/function(){var _ref9=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(){return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.prev=0;_context9.t0=setNeedsTemporalSigner;_context9.next=4;return fetchNeedsTemporalSigner(connection,distributor,indexStr,claimMethod);case 4:_context9.t1=_context9.sent;(0,_context9.t0)(_context9.t1);_context9.next=10;break;case 8:_context9.prev=8;_context9.t2=_context9[\"catch\"](0);case 10:case\"end\":return _context9.stop();}}},_callee9,null,[[0,8]]);}));return function wrap(){return _ref9.apply(this,arguments);};}();wrap();},[connection,distributor,indexStr,claimMethod]);var lambdaAPIEndpoint=\"https://{PLACEHOLDER-API-ID}.execute-api.us-east-2.amazonaws.com/send-OTP\";var skipAWSWorkflow=false;var sendOTP=/*#__PURE__*/function(){var _ref10=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(e){var index,amount,pin,_yield$fetchDistribut3,_yield$fetchDistribut4,distributorKey,distributorInfo,proof,instructions,pdaSeeds,extraSigners,_yield$buildCandyClai,_yield$buildCandyClai2,_yield$buildMintClaim,_yield$buildMintClaim2,edition,_yield$buildEditionCl,_yield$buildEditionCl2,transaction,signers,_iterator,_step,instr,_iterator2,_step2,_key2,txnNeedsTemporalSigner,otpQuery,_params,response,data,succeeded,toCheck;return _regeneratorRuntime.wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:e.preventDefault();if(!(!wallet.connected||wallet.publicKey===null)){_context10.next=3;break;}throw new Error(\"Wallet not connected\");case 3:index=Number(indexStr);amount=Number(amountStr);pin=null;if(!isNaN(amount)){_context10.next=8;break;}throw new Error(\"Could not parse amount \".concat(amountStr));case 8:if(!isNaN(index)){_context10.next=10;break;}throw new Error(\"Could not parse index \".concat(indexStr));case 10:if(!(params.pin!==\"NA\")){_context10.next=18;break;}_context10.prev=11;pin=new BN(pinStr);_context10.next=18;break;case 15:_context10.prev=15;_context10.t0=_context10[\"catch\"](11);throw new Error(\"Could not parse pin \".concat(pinStr,\": \").concat(_context10.t0));case 18:_context10.next=20;return fetchDistributor(connection,distributor);case 20:_yield$fetchDistribut3=_context10.sent;_yield$fetchDistribut4=_slicedToArray(_yield$fetchDistribut3,2);distributorKey=_yield$fetchDistribut4[0];distributorInfo=_yield$fetchDistribut4[1];console.log(\"Distributor\",distributorInfo);proof=proofStr===\"\"?[]:proofStr.split(\",\").map(function(b){var ret=Buffer.from(bs58.decode(b));if(ret.length!==32)throw new Error(\"Invalid proof hash length\");return ret;});if(!(claimMethod===\"candy\")){_context10.next=37;break;}console.log(\"Building candy claim\");_context10.next=30;return buildCandyClaim(connection,wallet.publicKey,distributorKey,distributorInfo,candyConfig,candyUUID,proof,handle,amount,index,pin);case 30:_yield$buildCandyClai=_context10.sent;_yield$buildCandyClai2=_slicedToArray(_yield$buildCandyClai,3);instructions=_yield$buildCandyClai2[0];pdaSeeds=_yield$buildCandyClai2[1];extraSigners=_yield$buildCandyClai2[2];_context10.next=61;break;case 37:if(!(claimMethod===\"transfer\")){_context10.next=47;break;}_context10.next=40;return buildMintClaim(connection,wallet.publicKey,distributorKey,distributorInfo,tokenAcc,proof,handle,amount,index,pin);case 40:_yield$buildMintClaim=_context10.sent;_yield$buildMintClaim2=_slicedToArray(_yield$buildMintClaim,3);instructions=_yield$buildMintClaim2[0];pdaSeeds=_yield$buildMintClaim2[1];extraSigners=_yield$buildMintClaim2[2];_context10.next=61;break;case 47:if(!(claimMethod===\"edition\")){_context10.next=60;break;}edition=Number(editionStr);if(!isNaN(edition)){_context10.next=51;break;}throw new Error(\"Could not parse edition \".concat(editionStr));case 51:_context10.next=53;return buildEditionClaim(connection,wallet.publicKey,distributorKey,distributorInfo,masterMint,edition,proof,handle,amount,index,pin);case 53:_yield$buildEditionCl=_context10.sent;_yield$buildEditionCl2=_slicedToArray(_yield$buildEditionCl,3);instructions=_yield$buildEditionCl2[0];pdaSeeds=_yield$buildEditionCl2[1];extraSigners=_yield$buildEditionCl2[2];_context10.next=61;break;case 60:throw new Error(\"Unknown claim method \".concat(claimMethod));case 61:if(!(pin===null&&pdaSeeds.length>0)){_context10.next=63;break;}throw new Error(\"Internal error: PDA generated when distributing to wallet directly\");case 63:_context10.t1=Transaction;_context10.t2=wallet.publicKey;_context10.next=67;return connection.getRecentBlockhash(\"singleGossip\");case 67:_context10.t3=_context10.sent.blockhash;_context10.t4={feePayer:_context10.t2,recentBlockhash:_context10.t3};transaction=new _context10.t1(_context10.t4);signers=new Set();_iterator=_createForOfIteratorHelper(instructions);try{for(_iterator.s();!(_step=_iterator.n()).done;){instr=_step.value;transaction.add(instr);_iterator2=_createForOfIteratorHelper(instr.keys);try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){_key2=_step2.value;if(_key2.isSigner)signers.add(_key2.pubkey);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}console.log(\"Expecting the following signers: \".concat(_toConsumableArray(signers).map(function(s){return s.toBase58();})));transaction.setSigners.apply(transaction,_toConsumableArray(signers));if(extraSigners.length>0){transaction.partialSign.apply(transaction,_toConsumableArray(extraSigners));}txnNeedsTemporalSigner=transaction.signatures.some(function(s){return s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER);});if(!(txnNeedsTemporalSigner&&!skipAWSWorkflow)){_context10.next=101;break;}otpQuery={method:\"send\",transaction:bs58.encode(transaction.serializeMessage()),seeds:pdaSeeds};if(discordGuild){otpQuery.discordGuild=discordGuild;}_params={method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify(otpQuery)};_context10.next=83;return fetch(lambdaAPIEndpoint,_params);case 83:response=_context10.sent;console.log(response);if(!(response.status!==200)){_context10.next=87;break;}throw new Error(\"Failed to send AWS OTP\");case 87:_context10.prev=87;_context10.next=90;return response.json();case 90:data=_context10.sent;_context10.next=96;break;case 93:_context10.prev=93;_context10.t5=_context10[\"catch\"](87);throw new Error(\"Could not parse AWS OTP response\");case 96:console.log(\"AWS OTP response data:\",data);if(discordGuild){succeeded=!!data.id;toCheck=\"discord\";}else{succeeded=!!data.MessageId;toCheck=\"email\";}if(succeeded){_context10.next=100;break;}throw new Error(\"Failed to send AWS OTP\");case 100:notify({message:\"OTP sent\",description:\"Please check your \".concat(toCheck,\" (\").concat(handle,\") for an OTP\")});case 101:return _context10.abrupt(\"return\",transaction);case 102:case\"end\":return _context10.stop();}}},_callee10,null,[[11,15],[87,93]]);}));return function sendOTP(_x57){return _ref10.apply(this,arguments);};}();var verifyOTP=/*#__PURE__*/function(){var _ref11=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(e,transaction){var txnNeedsTemporalSigner,OTP,_params2,response,blob,data,sig,fullySigned,claimResult;return _regeneratorRuntime.wrap(function _callee11$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:e.preventDefault();if(transaction){_context11.next=3;break;}throw new Error(\"Transaction not available for OTP verification\");case 3:if(!(!wallet.connected||wallet.publicKey===null)){_context11.next=5;break;}throw new Error(\"Wallet not connected\");case 5:txnNeedsTemporalSigner=transaction.signatures.some(function(s){return s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER);});if(!(txnNeedsTemporalSigner&&!skipAWSWorkflow)){_context11.next=36;break;}// TODO: distinguish between OTP failure and transaction-error. We can try\n// again on the former but not the latter\nOTP=Number(OTPStr);if(!(isNaN(OTP)||OTPStr.length===0)){_context11.next=10;break;}throw new Error(\"Could not parse OTP \".concat(OTPStr));case 10:_params2={method:\"POST\",headers:{\"Content-Type\":\"application/json\"},FunctionName:\"send-OTP\",body:JSON.stringify({method:\"verify\",otp:OTP,handle:handle// TODO?\n})};_context11.next=13;return fetch(lambdaAPIEndpoint,_params2);case 13:response=_context11.sent;console.log(response);if(!(response.status!==200)){_context11.next=18;break;}blob=JSON.stringify(response);throw new Error(\"Failed to verify AWS OTP. \".concat(blob));case 18:_context11.prev=18;_context11.next=21;return response.json();case 21:data=_context11.sent;_context11.next=27;break;case 24:_context11.prev=24;_context11.t0=_context11[\"catch\"](18);throw new Error(\"Could not parse AWS OTP verification response\");case 27:console.log(\"AWS verify response data:\",data);_context11.prev=28;sig=bs58.decode(data);_context11.next=35;break;case 32:_context11.prev=32;_context11.t1=_context11[\"catch\"](28);throw new Error(\"Could not decode transaction signature \".concat(data.body));case 35:transaction.addSignature(GUMDROP_TEMPORAL_SIGNER,sig);case 36:_context11.prev=36;_context11.next=39;return wallet.signTransaction(transaction);case 39:fullySigned=_context11.sent;_context11.next=45;break;case 42:_context11.prev=42;_context11.t2=_context11[\"catch\"](36);throw new Error(\"Failed to sign transaction\");case 45:_context11.next=47;return sendSignedTransaction({connection:connection,signedTransaction:fullySigned});case 47:claimResult=_context11.sent;console.log(claimResult);notify({message:\"Claim succeeded\",description:/*#__PURE__*/_jsx(HyperLink,{href:explorerLinkFor(claimResult.txid,connection),children:\"View transaction on explorer\"})});setTransaction(null);_context11.prev=51;_context11.t3=setNeedsTemporalSigner;_context11.next=55;return fetchNeedsTemporalSigner(connection,distributor,indexStr,claimMethod);case 55:_context11.t4=_context11.sent;(0,_context11.t3)(_context11.t4);_context11.next=61;break;case 59:_context11.prev=59;_context11.t5=_context11[\"catch\"](51);case 61:case\"end\":return _context11.stop();}}},_callee11,null,[[18,24],[28,32],[36,42],[51,59]]);}));return function verifyOTP(_x58,_x59){return _ref11.apply(this,arguments);};}();var _React$useState33=React.useState(false),_React$useState34=_slicedToArray(_React$useState33,2),loading=_React$useState34[0],setLoading=_React$useState34[1];var loadingProgress=function loadingProgress(){return/*#__PURE__*/_jsx(CircularProgress,{size:24,sx:{position:'absolute',top:'50%',left:'50%',marginTop:'-12px',marginLeft:'-12px'}});};var verifyOTPC=function verifyOTPC(_onClick){return/*#__PURE__*/_jsxs(React.Fragment,{children:[/*#__PURE__*/_jsx(TextField,{id:\"otp-text-field\",label:\"OTP\",value:OTPStr,onChange:function onChange(e){return setOTPStr(e.target.value);}}),/*#__PURE__*/_jsx(Box,{}),/*#__PURE__*/_jsxs(Box,{sx:{position:\"relative\"},children:[/*#__PURE__*/_jsx(Button,{disabled:!wallet.connected||!OTPStr||loading,variant:\"contained\",color:\"success\",style:{width:\"100%\"},onClick:function onClick(e){setLoading(true);var wrap=/*#__PURE__*/function(){var _ref12=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee12(){return _regeneratorRuntime.wrap(function _callee12$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:_context12.prev=0;_context12.next=3;return verifyOTP(e,transaction);case 3:setLoading(false);_onClick();_context12.next=11;break;case 7:_context12.prev=7;_context12.t0=_context12[\"catch\"](0);notify({message:\"Claim failed\",description:\"\".concat(_context12.t0)});setLoading(false);case 11:case\"end\":return _context12.stop();}}},_callee12,null,[[0,7]]);}));return function wrap(){return _ref12.apply(this,arguments);};}();wrap();},children:\"Claim Gumdrop\"}),loading&&loadingProgress()]})]});};var claimData=function claimData(claimMethod){if(claimMethod===\"candy\"){return/*#__PURE__*/_jsxs(React.Fragment,{children:[/*#__PURE__*/_jsx(TextField,{id:\"config-text-field\",label:\"Candy Config\",value:candyConfig,onChange:function onChange(e){return setCandyConfig(e.target.value);},disabled:!editable}),/*#__PURE__*/_jsx(TextField,{id:\"config-uuid-text-field\",label:\"Candy UUID\",value:candyUUID,onChange:function onChange(e){return setCandyUUID(e.target.value);},disabled:!editable})]});}else if(claimMethod===\"transfer\"){return/*#__PURE__*/_jsx(React.Fragment,{children:/*#__PURE__*/_jsx(TextField,{id:\"token-acc-text-field\",label:\"Source Token Account\",value:tokenAcc,onChange:function onChange(e){return setTokenAcc(e.target.value);},disabled:!editable})});}else if(claimMethod===\"edition\"){return/*#__PURE__*/_jsxs(React.Fragment,{children:[/*#__PURE__*/_jsx(TextField,{id:\"master-mint-text-field\",label:\"Master Mint\",value:masterMint,onChange:function onChange(e){return setMasterMint(e.target.value);},disabled:!editable}),/*#__PURE__*/_jsx(TextField,{id:\"edition-text-field\",label:\"Edition\",value:editionStr,onChange:function onChange(e){return setEditionStr(e.target.value);},disabled:!editable})]});}};var populateClaimC=function populateClaimC(_onClick2){return/*#__PURE__*/_jsxs(React.Fragment,{children:[/*#__PURE__*/_jsx(TextField,{id:\"distributor-text-field\",label:\"Distributor\",value:distributor,onChange:function onChange(e){return setDistributor(e.target.value);},disabled:!editable}),/*#__PURE__*/_jsxs(FormControl,{fullWidth:true,children:[/*#__PURE__*/_jsx(InputLabel,{id:\"claim-method-label\",disabled:!editable,children:\"Claim Method\"}),/*#__PURE__*/_jsxs(Select,{labelId:\"claim-method-label\",id:\"claim-method-select\",value:claimMethod,label:\"Claim Method\",onChange:function onChange(e){setClaimMethod(e.target.value);},style:{textAlign:\"left\"},disabled:!editable,children:[/*#__PURE__*/_jsx(MenuItem,{value:\"transfer\",children:\"Token Transfer\"}),/*#__PURE__*/_jsx(MenuItem,{value:\"candy\",children:\"Candy Machine\"}),/*#__PURE__*/_jsx(MenuItem,{value:\"edition\",children:\"Limited Edition\"})]})]}),claimMethod!==\"\"&&claimData(claimMethod),claimMethod!==\"edition\"&&/*#__PURE__*/_jsx(TextField,{id:\"amount-text-field\",label:\"Amount\",value:amountStr,onChange:function onChange(e){return setAmount(e.target.value);},disabled:!editable}),/*#__PURE__*/_jsx(TextField,{id:\"handle-text-field\",label:\"Handle\",value:handle,onChange:function onChange(e){return setHandle(e.target.value);},disabled:!editable}),/*#__PURE__*/_jsx(TextField,{id:\"index-text-field\",label:\"Index\",value:indexStr,onChange:function onChange(e){return setIndex(e.target.value);},disabled:!editable}),params.pin!==\"NA\"&&/*#__PURE__*/_jsx(TextField,{id:\"pin-text-field\",label:\"Pin\",value:pinStr,onChange:function onChange(e){return setPin(e.target.value);},disabled:!editable}),/*#__PURE__*/_jsx(TextField,{id:\"proof-text-field\",label:\"Proof\",multiline:true,value:proofStr,onChange:function onChange(e){return setProof(e.target.value);},disabled:!editable}),/*#__PURE__*/_jsx(Button,{color:\"info\",onClick:function onClick(){return setEditable(!editable);},children:!editable?\"Edit Claim\":\"Stop Editing\"}),/*#__PURE__*/_jsx(Box,{}),/*#__PURE__*/_jsxs(Box,{sx:{position:\"relative\"},children:[/*#__PURE__*/_jsx(Button,{disabled:!wallet.connected||!allFieldsPopulated||loading,variant:\"contained\",style:{width:\"100%\"},color:asyncNeedsTemporalSigner?\"primary\":\"success\",onClick:function onClick(e){setLoading(true);var wrap=/*#__PURE__*/function(){var _ref13=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee13(){var needsTemporalSigner,_transaction;return _regeneratorRuntime.wrap(function _callee13$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:_context13.prev=0;_context13.next=3;return fetchNeedsTemporalSigner(connection,distributor,indexStr,claimMethod);case 3:needsTemporalSigner=_context13.sent;_context13.next=6;return sendOTP(e);case 6:_transaction=_context13.sent;if(needsTemporalSigner){_context13.next=12;break;}_context13.next=10;return verifyOTP(e,_transaction);case 10:_context13.next=13;break;case 12:setTransaction(_transaction);case 13:setLoading(false);_onClick2();_context13.next=21;break;case 17:_context13.prev=17;_context13.t0=_context13[\"catch\"](0);notify({message:\"Claim failed\",description:\"\".concat(_context13.t0)});setLoading(false);case 21:case\"end\":return _context13.stop();}}},_callee13,null,[[0,17]]);}));return function wrap(){return _ref13.apply(this,arguments);};}();wrap();},children:asyncNeedsTemporalSigner?\"Next\":\"Claim Gumdrop\"}),loading&&loadingProgress()]})]});};var steps=[{name:\"Populate Claim\",inner:populateClaimC}];if(asyncNeedsTemporalSigner){steps.push({name:\"Verify OTP\",inner:verifyOTPC});}// TODO: better interaction between setting `asyncNeedsTemporalSigner` and\n// the stepper... this is pretty jank\nvar _React$useState35=React.useState(0),_React$useState36=_slicedToArray(_React$useState35,2),activeStep=_React$useState36[0],setActiveStep=_React$useState36[1];var stepToUse=Math.min(activeStep,steps.length-1);var handleNext=function handleNext(){// return to start if going past the end (claim succeeded)\nsetActiveStep(function(prev){if(prev===steps.length-1){return 0;}else{return prev+1;}});};var handleBack=function handleBack(){setActiveStep(function(prev){return prev-1;});};var stepper=/*#__PURE__*/_jsxs(React.Fragment,{children:[/*#__PURE__*/_jsx(Stepper,{activeStep:stepToUse,children:steps.map(function(s){return/*#__PURE__*/_jsx(Step,{children:/*#__PURE__*/_jsx(StepLabel,{children:s.name})},s.name);})}),/*#__PURE__*/_jsx(Box,{})]});return/*#__PURE__*/_jsxs(Stack,{spacing:2,children:[asyncNeedsTemporalSigner&&stepper,steps[stepToUse].inner(handleNext),stepToUse>0&&/*#__PURE__*/_jsx(Button,{color:\"info\",onClick:handleBack,children:\"Back\"})]});};","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/components/Claim.tsx"],"names":["React","queryString","Box","Button","CircularProgress","FormControl","Link","HyperLink","InputLabel","MenuItem","Select","Stack","Step","StepLabel","Stepper","TextField","useWallet","Keypair","PublicKey","SystemProgram","SYSVAR_RENT_PUBKEY","SYSVAR_CLOCK_PUBKEY","Transaction","TransactionInstruction","AccountLayout","MintLayout","Token","TOKEN_PROGRAM_ID","notify","sha256","BN","bs58","useConnection","CANDY_MACHINE_ID","GUMDROP_DISTRIBUTOR_ID","GUMDROP_TEMPORAL_SIGNER","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_METADATA_PROGRAM_ID","getCandyMachine","getCandyMachineAddress","getEdition","getEditionMarkerPda","getMetadata","MerkleTree","explorerLinkFor","sendSignedTransaction","chunk","coder","walletKeyOrPda","walletKey","handle","pin","seed","key","equals","Error","seeds","toBuffer","Buffer","from","toArray","findProgramAddress","claimantPda","buildMintClaim","connection","distributorKey","distributorInfo","tokenAcc","proof","amount","index","tokenAccKey","getAccountInfo","distTokenAccount","tokenAccountInfo","decode","data","mint","console","log","toBase58","secret","pdaSeeds","leaf","matches","verifyClaim","root","claimStatus","cbump","walletTokenKey","setup","push","createAssociatedTokenAccountInstruction","temporalSigner","temporal","default","claimAirdrop","programId","keys","pubkey","isSigner","isWritable","digest","slice","length","concat","buildCandyClaim","candyConfig","candyUUID","configKey","claimCount","distributorWalletKey","wbump","claimCountAccount","nftsAlreadyMinted","claimAccountInfo","accounts","count","claimant","claimantStr","nftsAvailable","candyMachineKey","candyMachine","candyMachineMints","buildSingleCandyMint","wallet","instrs","candyMachineWallet","candyMachineMint","generate","publicKey","candyMachineMetadata","candyMachineMaster","createMintAndAccount","span","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","createInitMintInstruction","createMintToInstruction","buildEditionClaim","masterMint","edition","masterMintKey","newMint","newMetadataKey","masterMetadataKey","newEdition","masterEdition","distributorTokenKey","editionMarkKey","fetchDistributor","distributorStr","account","owner","ownerStr","info","fetchNeedsTemporalSigner","indexStr","claimMethod","Number","Claim","props","query","location","search","localStorage","setItem","stored","getItem","params","parse","useState","distributor","setDistributor","config","master","setClaimMethod","setTokenAcc","setCandyConfig","uuid","setCandyUUID","setMasterMint","editionStr","setEditionStr","setHandle","amountStr","setAmount","setIndex","pinStr","setPin","proofStr","setProof","discordGuild","guild","allFieldsPopulated","editable","setEditable","transaction","setTransaction","OTPStr","setOTPStr","asyncNeedsTemporalSigner","setNeedsTemporalSigner","useEffect","wrap","lambdaAPIEndpoint","skipAWSWorkflow","sendOTP","e","preventDefault","connected","isNaN","split","map","b","ret","instructions","extraSigners","getRecentBlockhash","blockhash","feePayer","recentBlockhash","signers","Set","instr","add","s","setSigners","partialSign","txnNeedsTemporalSigner","signatures","some","otpQuery","method","encode","serializeMessage","headers","body","JSON","stringify","fetch","response","status","json","succeeded","id","toCheck","MessageId","message","description","verifyOTP","OTP","FunctionName","otp","blob","sig","addSignature","signTransaction","fullySigned","signedTransaction","claimResult","txid","loading","setLoading","loadingProgress","position","top","left","marginTop","marginLeft","verifyOTPC","onClick","target","value","width","claimData","populateClaimC","textAlign","needsTemporalSigner","steps","name","inner","activeStep","setActiveStep","stepToUse","Math","min","handleNext","prev","handleBack","stepper"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport { RouteComponentProps, } from \"react-router-dom\";\r\nimport queryString from 'query-string';\r\n\r\nimport {\r\n  Box,\r\n  Button,\r\n  CircularProgress,\r\n  FormControl,\r\n  Link as HyperLink,\r\n  InputLabel,\r\n  MenuItem,\r\n  Select,\r\n  Stack,\r\n  Step,\r\n  StepLabel,\r\n  Stepper,\r\n  TextField,\r\n} from \"@mui/material\";\r\n\r\nimport {\r\n  useWallet,\r\n} from \"@solana/wallet-adapter-react\";\r\nimport {\r\n  Connection as RPCConnection,\r\n  Keypair,\r\n  PublicKey,\r\n  SystemProgram,\r\n  SYSVAR_RENT_PUBKEY,\r\n  SYSVAR_CLOCK_PUBKEY,\r\n  Transaction,\r\n  TransactionInstruction,\r\n} from \"@solana/web3.js\";\r\nimport {\r\n  AccountLayout,\r\n  MintLayout,\r\n  Token,\r\n  TOKEN_PROGRAM_ID,\r\n} from \"@solana/spl-token\";\r\nimport {\r\n  notify,\r\n} from \"@oyster/common\";\r\nimport { sha256 } from \"js-sha256\";\r\nimport BN from 'bn.js';\r\nimport * as bs58 from \"bs58\";\r\n\r\nimport {\r\n  useConnection,\r\n} from \"../contexts\";\r\nimport {\r\n  CANDY_MACHINE_ID,\r\n  GUMDROP_DISTRIBUTOR_ID,\r\n  GUMDROP_TEMPORAL_SIGNER,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n} from \"../utils/ids\";\r\nimport {\r\n  getCandyMachine,\r\n  getCandyMachineAddress,\r\n  getEdition,\r\n  getEditionMarkerPda,\r\n  getMetadata,\r\n} from \"../utils/accounts\";\r\nimport { MerkleTree } from \"../utils/merkleTree\";\r\nimport {\r\n  explorerLinkFor,\r\n  sendSignedTransaction,\r\n} from \"../utils/transactions\";\r\nimport {\r\n  chunk,\r\n} from \"../utils/claimant\";\r\nimport { coder } from \"../utils/merkleDistributor\";\r\n\r\nconst walletKeyOrPda = async (\r\n  walletKey : PublicKey,\r\n  handle : string,\r\n  pin : BN | null,\r\n  seed : PublicKey,\r\n) : Promise<[PublicKey, Array<Buffer>]> => {\r\n  if (pin === null) {\r\n    try {\r\n      const key = new PublicKey(handle);\r\n      if (!key.equals(walletKey)) {\r\n        throw new Error(\"Claimant wallet handle does not match connected wallet\");\r\n      }\r\n      return [key, []];\r\n    } catch (err) {\r\n      throw new Error(`Invalid claimant wallet handle ${err}`);\r\n    }\r\n  } else {\r\n    const seeds = [\r\n      seed.toBuffer(),\r\n      Buffer.from(handle),\r\n      Buffer.from(pin.toArray(\"le\", 4)),\r\n    ];\r\n\r\n    const [claimantPda, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        seeds[0],\r\n        ...chunk(seeds[1], 32),\r\n        seeds[2],\r\n      ],\r\n      GUMDROP_DISTRIBUTOR_ID\r\n    );\r\n    return [claimantPda, seeds];\r\n  }\r\n}\r\n\r\n\r\nconst buildMintClaim = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorInfo : any,\r\n  tokenAcc : string,\r\n  proof : Array<Buffer>,\r\n  handle : string,\r\n  amount : number,\r\n  index : number,\r\n  pin : BN | null,\r\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\r\n  let tokenAccKey: PublicKey;\r\n  try {\r\n    tokenAccKey = new PublicKey(tokenAcc);\r\n  } catch (err) {\r\n    throw new Error(`Invalid tokenAcc key ${err}`);\r\n  }\r\n  const distTokenAccount = await connection.getAccountInfo(tokenAccKey);\r\n  if (distTokenAccount === null) {\r\n    throw new Error(`Could not fetch distributor token account`);\r\n  }\r\n\r\n  const tokenAccountInfo = AccountLayout.decode(distTokenAccount.data);\r\n  const mint = new PublicKey(tokenAccountInfo.mint);\r\n\r\n  console.log(mint.toBase58());\r\n\r\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, mint);\r\n\r\n  // TODO: since it's in the PDA do we need it to be in the leaf?\r\n  const leaf = Buffer.from(\r\n    [...new BN(index).toArray(\"le\", 8),\r\n     ...secret.toBuffer(),\r\n     ...mint.toBuffer(),\r\n     ...new BN(amount).toArray(\"le\", 8),\r\n    ]\r\n  );\r\n\r\n  const matches = MerkleTree.verifyClaim(\r\n    leaf, proof, Buffer.from(distributorInfo.root)\r\n  );\r\n\r\n  if (!matches) {\r\n    throw new Error(\"Gumdrop merkle proof does not match\");\r\n  }\r\n\r\n  const [claimStatus, cbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"ClaimStatus\"),\r\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\r\n    [\r\n      walletKey.toBuffer(),\r\n      TOKEN_PROGRAM_ID.toBuffer(),\r\n      mint.toBuffer(),\r\n    ],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n  );\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n\r\n  if (await connection.getAccountInfo(walletTokenKey) === null) {\r\n    setup.push(Token.createAssociatedTokenAccountInstruction(\r\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n        TOKEN_PROGRAM_ID,\r\n        mint,\r\n        walletTokenKey,\r\n        walletKey,\r\n        walletKey\r\n      ));\r\n  }\r\n\r\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\r\n      ? walletKey : distributorInfo.temporal;\r\n\r\n  const claimAirdrop = new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\r\n          { pubkey: claimStatus             , isSigner: false , isWritable: true  } ,\r\n          { pubkey: tokenAccKey             , isSigner: false , isWritable: true  } ,\r\n          { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\r\n          { pubkey: temporalSigner          , isSigner: true  , isWritable: false } ,\r\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,  // payer\r\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:claim\")).slice(0, 8),\r\n        ...new BN(cbump).toArray(\"le\", 1),\r\n        ...new BN(index).toArray(\"le\", 8),\r\n        ...new BN(amount).toArray(\"le\", 8),\r\n        ...secret.toBuffer(),\r\n        ...new BN(proof.length).toArray(\"le\", 4),\r\n        ...Buffer.concat(proof),\r\n      ])\r\n  })\r\n\r\n  return [[...setup, claimAirdrop], pdaSeeds, []];\r\n}\r\n\r\nconst buildCandyClaim = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorInfo : any,\r\n  candyConfig : string,\r\n  candyUUID : string,\r\n  proof : Array<Buffer>,\r\n  handle : string,\r\n  amount : number,\r\n  index : number,\r\n  pin : BN | null,\r\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\r\n\r\n  let configKey : PublicKey;\r\n  try {\r\n    configKey = new PublicKey(candyConfig);\r\n  } catch (err) {\r\n    throw new Error(`Invalid candy config key ${err}`);\r\n  }\r\n\r\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, configKey);\r\n\r\n  // TODO: since it's in the PDA do we need it to be in the leaf?\r\n  const leaf = Buffer.from(\r\n    [...new BN(index).toArray(\"le\", 8),\r\n     ...secret.toBuffer(),\r\n     ...configKey.toBuffer(),\r\n     ...new BN(amount).toArray(\"le\", 8),\r\n    ]\r\n  );\r\n\r\n  const matches = MerkleTree.verifyClaim(\r\n    leaf, proof, Buffer.from(distributorInfo.root)\r\n  );\r\n\r\n  if (!matches) {\r\n    throw new Error(\"Gumdrop merkle proof does not match\");\r\n  }\r\n\r\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"ClaimCount\"),\r\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"Wallet\"),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  // atm the contract has a special case for when the temporal key is defaulted\r\n  // (aka always passes temporal check)\r\n  // TODO: more flexible\r\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\r\n      ? walletKey : distributorInfo.temporal;\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n\r\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\r\n  let nftsAlreadyMinted = 0;\r\n  if (claimCountAccount === null) {\r\n    // nothing claimed yet\r\n  } else {\r\n    // TODO: subtract already minted?...\r\n    const claimAccountInfo = coder.accounts.decode(\r\n      \"ClaimCount\", claimCountAccount.data);\r\n    nftsAlreadyMinted = claimAccountInfo.count;\r\n    if (claimAccountInfo.claimant.equals(walletKey)) {\r\n      // we already proved this claim and verified the OTP once, contract knows\r\n      // that this wallet is OK\r\n      temporalSigner = walletKey;\r\n    } else {\r\n      // need to claim with the first wallet...\r\n      const claimantStr = claimAccountInfo.claimant.toBase58();\r\n      throw new Error(`This wallet does not match existing claimant ${claimantStr}`);\r\n    }\r\n  }\r\n\r\n  const nftsAvailable = amount;\r\n  if (nftsAlreadyMinted >= nftsAvailable) {\r\n    throw new Error(`Cannot mint another NFT. ${nftsAvailable} NFT(s) were originally allocated`\r\n      + (nftsAlreadyMinted > 0 ? ` and ${nftsAlreadyMinted} NFT(s) were already minted` : \"\"));\r\n  }\r\n\r\n\r\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUUID);\r\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\r\n  console.log(\"Candy Machine\", candyMachine);\r\n\r\n  const candyMachineMints : Array<Keypair> = [];\r\n\r\n  const [instrs, mint] = await buildSingleCandyMint(\r\n    connection,\r\n    walletKey,\r\n    distributorKey,\r\n    distributorWalletKey,\r\n    claimCount,\r\n    temporalSigner,\r\n    configKey,\r\n    candyMachineKey,\r\n    candyMachine.wallet,\r\n    Buffer.from([\r\n      ...new BN(wbump).toArray(\"le\", 1),\r\n      ...new BN(cbump).toArray(\"le\", 1),\r\n      ...new BN(index).toArray(\"le\", 8),\r\n      ...new BN(amount).toArray(\"le\", 8),\r\n      ...secret.toBuffer(),\r\n      ...new BN(proof.length).toArray(\"le\", 4),\r\n      ...Buffer.concat(proof),\r\n    ]),\r\n  );\r\n  candyMachineMints.push(mint);\r\n  setup.push(...instrs);\r\n\r\n  return [setup, pdaSeeds, candyMachineMints];\r\n}\r\n\r\nconst buildSingleCandyMint = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorWalletKey : PublicKey,\r\n  claimCount : PublicKey,\r\n  temporalSigner : PublicKey,\r\n  configKey : PublicKey,\r\n  candyMachineKey : PublicKey,\r\n  candyMachineWallet : PublicKey,\r\n  data : Buffer,\r\n) : Promise<[Array<TransactionInstruction>, Keypair]> => {\r\n  const candyMachineMint = Keypair.generate();\r\n  const candyMachineMetadata = await getMetadata(candyMachineMint.publicKey);\r\n  const candyMachineMaster = await getEdition(candyMachineMint.publicKey);\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n  await createMintAndAccount(connection, walletKey, candyMachineMint.publicKey, setup);\r\n  setup.push(new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: distributorWalletKey      , isSigner: false , isWritable: true  } ,\r\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\r\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\r\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\r\n\r\n          { pubkey: configKey                 , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineKey           , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineWallet        , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineMint.publicKey, isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineMetadata      , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineMaster        , isSigner: false , isWritable: true  } ,\r\n\r\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\r\n          { pubkey: CANDY_MACHINE_ID          , isSigner: false , isWritable: false } ,\r\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\r\n          { pubkey: SYSVAR_CLOCK_PUBKEY       , isSigner: false , isWritable: false } ,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0, 8),\r\n        ...data,\r\n      ])\r\n  }));\r\n\r\n  return [setup, candyMachineMint];\r\n}\r\n\r\nconst createMintAndAccount = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  mint : PublicKey,\r\n  setup : Array<TransactionInstruction>,\r\n) => {\r\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\r\n    [\r\n      walletKey.toBuffer(),\r\n      TOKEN_PROGRAM_ID.toBuffer(),\r\n      mint.toBuffer(),\r\n    ],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n  );\r\n\r\n  setup.push(SystemProgram.createAccount({\r\n    fromPubkey: walletKey,\r\n    newAccountPubkey: mint,\r\n    space: MintLayout.span,\r\n    lamports:\r\n      await connection.getMinimumBalanceForRentExemption(\r\n        MintLayout.span,\r\n      ),\r\n    programId: TOKEN_PROGRAM_ID,\r\n  }));\r\n\r\n  setup.push(Token.createInitMintInstruction(\r\n    TOKEN_PROGRAM_ID,\r\n    mint,\r\n    0,\r\n    walletKey,\r\n    walletKey,\r\n  ));\r\n\r\n  setup.push(Token.createAssociatedTokenAccountInstruction(\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n    TOKEN_PROGRAM_ID,\r\n    mint,\r\n    walletTokenKey,\r\n    walletKey,\r\n    walletKey\r\n  ));\r\n\r\n  setup.push(Token.createMintToInstruction(\r\n    TOKEN_PROGRAM_ID,\r\n    mint,\r\n    walletTokenKey,\r\n    walletKey,\r\n    [],\r\n    1,\r\n  ));\r\n\r\n}\r\n\r\nconst buildEditionClaim = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorInfo : any,\r\n  masterMint : string,\r\n  edition : number,\r\n  proof : Array<Buffer>,\r\n  handle : string,\r\n  amount : number,\r\n  index : number,\r\n  pin : BN | null,\r\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\r\n\r\n  let masterMintKey : PublicKey;\r\n  try {\r\n    masterMintKey = new PublicKey(masterMint);\r\n  } catch (err) {\r\n    throw new Error(`Invalid master mint key ${err}`);\r\n  }\r\n\r\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, masterMintKey);\r\n\r\n  // should we assert that the amount is 1?\r\n  const leaf = Buffer.from(\r\n    [...new BN(index).toArray(\"le\", 8),\r\n     ...secret.toBuffer(),\r\n     ...masterMintKey.toBuffer(),\r\n     ...new BN(amount).toArray(\"le\", 8),\r\n     ...new BN(edition).toArray(\"le\", 8),\r\n    ]\r\n  );\r\n\r\n  const matches = MerkleTree.verifyClaim(\r\n    leaf, proof, Buffer.from(distributorInfo.root)\r\n  );\r\n\r\n  if (!matches) {\r\n    throw new Error(\"Gumdrop merkle proof does not match\");\r\n  }\r\n\r\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"ClaimCount\"),\r\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  // atm the contract has a special case for when the temporal key is defaulted\r\n  // (aka always passes temporal check)\r\n  // TODO: more flexible\r\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\r\n      ? walletKey : distributorInfo.temporal;\r\n\r\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\r\n  if (claimCountAccount !== null) {\r\n    throw new Error(`This edition was already claimed`);\r\n  }\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n\r\n  const newMint = Keypair.generate();\r\n  const newMetadataKey = await getMetadata(newMint.publicKey);\r\n  const masterMetadataKey = await getMetadata(masterMintKey);\r\n  const newEdition = await getEdition(newMint.publicKey);\r\n  const masterEdition = await getEdition(masterMintKey);\r\n\r\n  await createMintAndAccount(connection, walletKey, newMint.publicKey, setup);\r\n\r\n  const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\r\n    [\r\n      distributorKey.toBuffer(),\r\n      TOKEN_PROGRAM_ID.toBuffer(),\r\n      masterMintKey.toBuffer(),\r\n    ],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n  );\r\n\r\n  const editionMarkKey = await getEditionMarkerPda(masterMintKey, new BN(edition));\r\n\r\n  setup.push(new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\r\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\r\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\r\n\r\n          { pubkey: newMetadataKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: newEdition                , isSigner: false , isWritable: true  } ,\r\n          { pubkey: masterEdition             , isSigner: false , isWritable: true  } ,\r\n          { pubkey: newMint.publicKey         , isSigner: false , isWritable: true  } ,\r\n          { pubkey: editionMarkKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // `newMint` auth\r\n          { pubkey: distributorTokenKey       , isSigner: false , isWritable: false } ,\r\n          { pubkey: walletKey                 , isSigner: false , isWritable: false } , // new update auth\r\n          { pubkey: masterMetadataKey         , isSigner: false , isWritable: false } ,\r\n          { pubkey: masterMintKey             , isSigner: false , isWritable: false } ,\r\n\r\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\r\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0, 8),\r\n        ...new BN(cbump).toArray(\"le\", 1),\r\n        ...new BN(index).toArray(\"le\", 8),\r\n        ...new BN(amount).toArray(\"le\", 8),\r\n        ...new BN(edition).toArray(\"le\", 8),\r\n        ...secret.toBuffer(),\r\n        ...new BN(proof.length).toArray(\"le\", 4),\r\n        ...Buffer.concat(proof),\r\n      ])\r\n  }));\r\n\r\n  return [setup, pdaSeeds, [newMint]];\r\n}\r\n\r\nconst fetchDistributor = async (\r\n  connection : RPCConnection,\r\n  distributorStr : string,\r\n) => {\r\n  let key;\r\n  try {\r\n    key = new PublicKey(distributorStr);\r\n  } catch (err) {\r\n    throw new Error(`Invalid distributor key ${err}`);\r\n  }\r\n  const account = await connection.getAccountInfo(key);\r\n  if (account === null) {\r\n    throw new Error(`Could not fetch distributor ${distributorStr}`);\r\n  }\r\n  if (!account.owner.equals(GUMDROP_DISTRIBUTOR_ID)) {\r\n    const ownerStr = account.owner.toBase58();\r\n    throw new Error(`Invalid distributor owner ${ownerStr}`);\r\n  }\r\n  const info = coder.accounts.decode(\"MerkleDistributor\", account.data);\r\n  return [key, info];\r\n};\r\n\r\nconst fetchNeedsTemporalSigner = async (\r\n  connection : RPCConnection,\r\n  distributorStr : string,\r\n  indexStr : string,\r\n  claimMethod : string,\r\n) => {\r\n  const [key, info] = await fetchDistributor(connection, distributorStr);\r\n  if (!info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)) {\r\n    // default pubkey or program itself (distribution through wallets)\r\n    return false;\r\n  } else if (claimMethod === \"candy\") {\r\n    const [claimCount, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from(\"ClaimCount\"),\r\n        Buffer.from(new BN(Number(indexStr)).toArray(\"le\", 8)),\r\n        key.toBuffer(),\r\n      ],\r\n      GUMDROP_DISTRIBUTOR_ID\r\n    );\r\n    // if someone (maybe us) has already claimed this, the contract will\r\n    // not check the existing temporal signer anymore since presumably\r\n    // they have already verified the OTP. So we need to fetch the temporal\r\n    // signer if it is null\r\n    const claimCountAccount = await connection.getAccountInfo(claimCount);\r\n    return claimCountAccount === null;\r\n  } else {\r\n    // default to need one\r\n    return true;\r\n  }\r\n};\r\n\r\nexport type ClaimProps = {};\r\n\r\nexport const Claim = (\r\n  props : RouteComponentProps<ClaimProps>,\r\n) => {\r\n  const connection = useConnection();\r\n  const wallet = useWallet();\r\n\r\n  let query = props.location.search;\r\n  if (query && query.length > 0) {\r\n    localStorage.setItem(\"claimQuery\", query);\r\n  } else {\r\n    const stored = localStorage.getItem(\"claimQuery\");\r\n    if (stored)\r\n      query = stored;\r\n  }\r\n\r\n  const params = queryString.parse(query);\r\n  const [distributor, setDistributor] = React.useState(params.distributor as string || \"\");\r\n  const [claimMethod, setClaimMethod] = React.useState(\r\n        params.tokenAcc ? \"transfer\"\r\n      : params.config   ? \"candy\"\r\n      : params.master   ? \"edition\"\r\n      :                   \"\");\r\n  const [tokenAcc, setTokenAcc] = React.useState(params.tokenAcc as string || \"\");\r\n  const [candyConfig, setCandyConfig] = React.useState(params.config as string || \"\");\r\n  const [candyUUID, setCandyUUID] = React.useState(params.uuid as string || \"\");\r\n  const [masterMint, setMasterMint] = React.useState(params.master as string || \"\");\r\n  const [editionStr, setEditionStr] = React.useState(params.edition as string || \"\");\r\n  const [handle, setHandle] = React.useState(params.handle as string || \"\");\r\n  const [amountStr, setAmount] = React.useState(params.amount as string || \"\");\r\n  const [indexStr, setIndex] = React.useState(params.index as string || \"\");\r\n  const [pinStr, setPin] = React.useState(params.pin as string || \"\");\r\n  const [proofStr, setProof] = React.useState(params.proof as string || \"\");\r\n\r\n  const discordGuild = params.guild;\r\n\r\n  const allFieldsPopulated =\r\n    distributor.length > 0\r\n    && ( claimMethod === \"transfer\" ? tokenAcc.length > 0\r\n       : claimMethod === \"candy\"    ? candyConfig.length > 0 && candyUUID.length > 0\r\n       : claimMethod === \"edition\"  ? masterMint.length > 0 && editionStr.length > 0\r\n       :                              false\r\n       )\r\n    && handle.length > 0\r\n    && amountStr.length > 0\r\n    && indexStr.length > 0;\r\n    // NB: pin can be empty if handle is a public-key and we are claiming through wallets\r\n    // NB: proof can be empty!\r\n\r\n  const [editable, setEditable] = React.useState(!allFieldsPopulated);\r\n\r\n  // temporal verification\r\n  const [transaction, setTransaction] = React.useState<Transaction | null>(null);\r\n  const [OTPStr, setOTPStr] = React.useState(\"\");\r\n\r\n  // async computed\r\n  const [asyncNeedsTemporalSigner, setNeedsTemporalSigner] = React.useState<boolean>(true);\r\n\r\n  React.useEffect(() => {\r\n    const wrap = async () => {\r\n      try {\r\n        setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\r\n          connection, distributor, indexStr, claimMethod));\r\n      } catch {\r\n        // TODO: log?\r\n      }\r\n    };\r\n    wrap();\r\n  }, [connection, distributor, indexStr, claimMethod]);\r\n\r\n  const lambdaAPIEndpoint = \"https://{PLACEHOLDER-API-ID}.execute-api.us-east-2.amazonaws.com/send-OTP\";\r\n\r\n  const skipAWSWorkflow = false;\r\n\r\n  const sendOTP = async (e : React.SyntheticEvent) => {\r\n    e.preventDefault();\r\n\r\n    if (!wallet.connected || wallet.publicKey === null) {\r\n      throw new Error(`Wallet not connected`);\r\n    }\r\n\r\n    const index = Number(indexStr);\r\n    const amount = Number(amountStr);\r\n    let pin : BN | null = null;\r\n\r\n    if (isNaN(amount)) {\r\n      throw new Error(`Could not parse amount ${amountStr}`);\r\n    }\r\n    if (isNaN(index)) {\r\n      throw new Error(`Could not parse index ${indexStr}`);\r\n    }\r\n    if (params.pin !== \"NA\") {\r\n      try {\r\n        pin = new BN(pinStr);\r\n      } catch (err) {\r\n        throw new Error(`Could not parse pin ${pinStr}: ${err}`);\r\n      }\r\n    }\r\n\r\n    // TODO: use cached?\r\n    const [distributorKey, distributorInfo] =\r\n        await fetchDistributor(connection, distributor);\r\n\r\n    console.log(\"Distributor\", distributorInfo);\r\n\r\n    const proof = proofStr === \"\" ? [] : proofStr.split(\",\").map(b => {\r\n      const ret = Buffer.from(bs58.decode(b))\r\n      if (ret.length !== 32)\r\n        throw new Error(`Invalid proof hash length`);\r\n      return ret;\r\n    });\r\n\r\n    let instructions, pdaSeeds, extraSigners;\r\n    if (claimMethod === \"candy\") {\r\n      console.log(\"Building candy claim\");\r\n      [instructions, pdaSeeds, extraSigners] = await buildCandyClaim(\r\n        connection, wallet.publicKey, distributorKey, distributorInfo,\r\n        candyConfig, candyUUID,\r\n        proof, handle, amount, index, pin\r\n      );\r\n    } else if (claimMethod === \"transfer\") {\r\n      [instructions, pdaSeeds, extraSigners] = await buildMintClaim(\r\n        connection, wallet.publicKey, distributorKey, distributorInfo,\r\n        tokenAcc,\r\n        proof, handle, amount, index, pin\r\n      );\r\n    } else if (claimMethod === \"edition\") {\r\n      const edition = Number(editionStr);\r\n      if (isNaN(edition)) {\r\n        throw new Error(`Could not parse edition ${editionStr}`);\r\n      }\r\n      [instructions, pdaSeeds, extraSigners] = await buildEditionClaim(\r\n        connection, wallet.publicKey, distributorKey, distributorInfo,\r\n        masterMint, edition,\r\n        proof, handle, amount, index, pin\r\n      );\r\n    } else {\r\n      throw new Error(`Unknown claim method ${claimMethod}`);\r\n    }\r\n\r\n    // NB: if we're claiming through wallets then pdaSeeds should be empty\r\n    // since the secret is the wallet key (which is also a signer)\r\n    if (pin === null && pdaSeeds.length > 0) {\r\n      throw new Error(`Internal error: PDA generated when distributing to wallet directly`);\r\n    }\r\n\r\n    const transaction = new Transaction({\r\n      feePayer: wallet.publicKey,\r\n      recentBlockhash: (await connection.getRecentBlockhash(\"singleGossip\")).blockhash,\r\n    });\r\n\r\n    const signers = new Set<PublicKey>();\r\n    for (const instr of instructions) {\r\n      transaction.add(instr);\r\n      for (const key of instr.keys)\r\n        if (key.isSigner)\r\n          signers.add(key.pubkey);\r\n    }\r\n    console.log(`Expecting the following signers: ${[...signers].map(s => s.toBase58())}`);\r\n    transaction.setSigners(...signers);\r\n\r\n    if (extraSigners.length > 0) {\r\n      transaction.partialSign(...extraSigners);\r\n    }\r\n\r\n    const txnNeedsTemporalSigner =\r\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\r\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\r\n      const otpQuery : { [key: string] : any } = {\r\n        method: \"send\",\r\n        transaction: bs58.encode(transaction.serializeMessage()),\r\n        seeds: pdaSeeds,\r\n      };\r\n      if (discordGuild) {\r\n        otpQuery.discordGuild = discordGuild;\r\n      }\r\n      const params = {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify(otpQuery),\r\n      };\r\n\r\n      const response = await fetch(lambdaAPIEndpoint, params);\r\n      console.log(response);\r\n\r\n      if (response.status !== 200) {\r\n        throw new Error(`Failed to send AWS OTP`);\r\n      }\r\n\r\n      let data;\r\n      try {\r\n        data = await response.json();\r\n      } catch {\r\n        throw new Error(`Could not parse AWS OTP response`);\r\n      }\r\n\r\n      console.log(\"AWS OTP response data:\", data);\r\n\r\n      let succeeded, toCheck;\r\n      if (discordGuild) {\r\n        succeeded = !!data.id;\r\n        toCheck = \"discord\";\r\n      } else {\r\n        succeeded = !!data.MessageId;\r\n        toCheck = \"email\";\r\n      }\r\n\r\n      if (!succeeded) {\r\n        throw new Error(`Failed to send AWS OTP`);\r\n      }\r\n\r\n      notify({\r\n        message: \"OTP sent\",\r\n        description: `Please check your ${toCheck} (${handle}) for an OTP`,\r\n      });\r\n    }\r\n\r\n    return transaction;\r\n  };\r\n\r\n  const verifyOTP = async (\r\n    e : React.SyntheticEvent,\r\n    transaction : Transaction | null,\r\n  ) => {\r\n    e.preventDefault();\r\n\r\n    if (!transaction) {\r\n      throw new Error(`Transaction not available for OTP verification`);\r\n    }\r\n\r\n    if (!wallet.connected || wallet.publicKey === null) {\r\n      throw new Error(`Wallet not connected`);\r\n    }\r\n\r\n    const txnNeedsTemporalSigner =\r\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\r\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\r\n      // TODO: distinguish between OTP failure and transaction-error. We can try\r\n      // again on the former but not the latter\r\n      const OTP = Number(OTPStr);\r\n      if (isNaN(OTP) || OTPStr.length === 0) {\r\n        throw new Error(`Could not parse OTP ${OTPStr}`);\r\n      }\r\n\r\n      const params = {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        FunctionName: \"send-OTP\",\r\n        body: JSON.stringify({\r\n          method: \"verify\",\r\n          otp: OTP,\r\n          handle: handle,  // TODO?\r\n        }),\r\n      };\r\n\r\n      const response = await fetch(lambdaAPIEndpoint, params);\r\n      console.log(response);\r\n\r\n      if (response.status !== 200) {\r\n        const blob = JSON.stringify(response);\r\n        throw new Error(`Failed to verify AWS OTP. ${blob}`);\r\n      }\r\n\r\n      let data;\r\n      try {\r\n        data = await response.json();\r\n      } catch {\r\n        throw new Error(`Could not parse AWS OTP verification response`);\r\n      }\r\n\r\n      console.log(\"AWS verify response data:\", data);\r\n\r\n      let sig;\r\n      try {\r\n        sig = bs58.decode(data);\r\n      } catch {\r\n        throw new Error(`Could not decode transaction signature ${data.body}`);\r\n      }\r\n\r\n      transaction.addSignature(GUMDROP_TEMPORAL_SIGNER, sig);\r\n    }\r\n\r\n    let fullySigned;\r\n    try {\r\n      fullySigned = await wallet.signTransaction(transaction);\r\n    } catch {\r\n      throw new Error(\"Failed to sign transaction\");\r\n    }\r\n\r\n    const claimResult = await sendSignedTransaction({\r\n      connection,\r\n      signedTransaction: fullySigned,\r\n    });\r\n\r\n    console.log(claimResult);\r\n    notify({\r\n      message: \"Claim succeeded\",\r\n      description: (\r\n        <HyperLink href={explorerLinkFor(claimResult.txid, connection)}>\r\n          View transaction on explorer\r\n        </HyperLink>\r\n      ),\r\n    });\r\n    setTransaction(null);\r\n    try {\r\n      setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\r\n        connection, distributor, indexStr, claimMethod));\r\n    } catch {\r\n      // TODO: log?\r\n    }\r\n  };\r\n\r\n  const [loading, setLoading] = React.useState(false);\r\n  const loadingProgress = () => (\r\n    <CircularProgress\r\n      size={24}\r\n      sx={{\r\n        position: 'absolute',\r\n        top: '50%',\r\n        left: '50%',\r\n        marginTop: '-12px',\r\n        marginLeft: '-12px',\r\n      }}\r\n    />\r\n  );\r\n\r\n  const verifyOTPC = (onClick) => (\r\n    <React.Fragment>\r\n      <TextField\r\n        id=\"otp-text-field\"\r\n        label=\"OTP\"\r\n        value={OTPStr}\r\n        onChange={(e) => setOTPStr(e.target.value)}\r\n      />\r\n      <Box />\r\n\r\n      <Box sx={{ position: \"relative\" }}>\r\n      <Button\r\n        disabled={!wallet.connected || !OTPStr || loading}\r\n        variant=\"contained\"\r\n        color=\"success\"\r\n        style={{ width: \"100%\" }}\r\n        onClick={(e) => {\r\n          setLoading(true);\r\n          const wrap = async () => {\r\n            try {\r\n              await verifyOTP(e, transaction);\r\n              setLoading(false);\r\n              onClick();\r\n            } catch (err) {\r\n              notify({\r\n                message: \"Claim failed\",\r\n                description: `${err}`,\r\n              });\r\n              setLoading(false);\r\n            }\r\n          };\r\n          wrap();\r\n        }}\r\n      >\r\n        Claim Gumdrop\r\n      </Button>\r\n      {loading && loadingProgress()}\r\n      </Box>\r\n    </React.Fragment>\r\n  );\r\n\r\n  const claimData = (claimMethod) => {\r\n    if (claimMethod === \"candy\") {\r\n      return (\r\n        <React.Fragment>\r\n          <TextField\r\n            id=\"config-text-field\"\r\n            label=\"Candy Config\"\r\n            value={candyConfig}\r\n            onChange={e => setCandyConfig(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n          <TextField\r\n            id=\"config-uuid-text-field\"\r\n            label=\"Candy UUID\"\r\n            value={candyUUID}\r\n            onChange={e => setCandyUUID(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n        </React.Fragment>\r\n      );\r\n    } else if (claimMethod === \"transfer\") {\r\n      return (\r\n        <React.Fragment>\r\n          <TextField\r\n            id=\"token-acc-text-field\"\r\n            label=\"Source Token Account\"\r\n            value={tokenAcc}\r\n            onChange={(e) => setTokenAcc(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n        </React.Fragment>\r\n      );\r\n    } else if (claimMethod === \"edition\") {\r\n      return (\r\n        <React.Fragment>\r\n          <TextField\r\n            id=\"master-mint-text-field\"\r\n            label=\"Master Mint\"\r\n            value={masterMint}\r\n            onChange={(e) => setMasterMint(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n          <TextField\r\n            id=\"edition-text-field\"\r\n            label=\"Edition\"\r\n            value={editionStr}\r\n            onChange={(e) => setEditionStr(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n        </React.Fragment>\r\n      );\r\n    }\r\n  };\r\n\r\n  const populateClaimC = (onClick) => (\r\n    <React.Fragment>\r\n      <TextField\r\n        id=\"distributor-text-field\"\r\n        label=\"Distributor\"\r\n        value={distributor}\r\n        onChange={(e) => setDistributor(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      <FormControl fullWidth>\r\n        <InputLabel\r\n          id=\"claim-method-label\"\r\n          disabled={!editable}\r\n        >\r\n          Claim Method\r\n        </InputLabel>\r\n        <Select\r\n          labelId=\"claim-method-label\"\r\n          id=\"claim-method-select\"\r\n          value={claimMethod}\r\n          label=\"Claim Method\"\r\n          onChange={(e) => { setClaimMethod(e.target.value); }}\r\n          style={{textAlign: \"left\"}}\r\n          disabled={!editable}\r\n        >\r\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\r\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\r\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\r\n        </Select>\r\n      </FormControl>\r\n      {claimMethod !== \"\" && claimData(claimMethod)}\r\n      {claimMethod !== \"edition\" && <TextField\r\n        id=\"amount-text-field\"\r\n        label=\"Amount\"\r\n        value={amountStr}\r\n        onChange={(e) => setAmount(e.target.value)}\r\n        disabled={!editable}\r\n      />}\r\n      <TextField\r\n        id=\"handle-text-field\"\r\n        label=\"Handle\"\r\n        value={handle}\r\n        onChange={(e) => setHandle(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      <TextField\r\n        id=\"index-text-field\"\r\n        label=\"Index\"\r\n        value={indexStr}\r\n        onChange={(e) => setIndex(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      {params.pin !== \"NA\" && <TextField\r\n        id=\"pin-text-field\"\r\n        label=\"Pin\"\r\n        value={pinStr}\r\n        onChange={(e) => setPin(e.target.value)}\r\n        disabled={!editable}\r\n      />}\r\n      <TextField\r\n        id=\"proof-text-field\"\r\n        label=\"Proof\"\r\n        multiline\r\n        value={proofStr}\r\n        onChange={(e) => setProof(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      <Button\r\n        color=\"info\"\r\n        onClick={() => setEditable(!editable)}\r\n      >\r\n        {!editable ? \"Edit Claim\" : \"Stop Editing\"}\r\n      </Button>\r\n      <Box />\r\n\r\n      <Box sx={{ position: \"relative\" }}>\r\n      <Button\r\n        disabled={!wallet.connected || !allFieldsPopulated || loading}\r\n        variant=\"contained\"\r\n        style={{ width: \"100%\" }}\r\n        color={asyncNeedsTemporalSigner ? \"primary\" : \"success\"}\r\n        onClick={(e) => {\r\n          setLoading(true);\r\n          const wrap = async () => {\r\n            try {\r\n              const needsTemporalSigner = await fetchNeedsTemporalSigner(\r\n                  connection, distributor, indexStr, claimMethod);\r\n              const transaction = await sendOTP(e);\r\n              if (!needsTemporalSigner) {\r\n                await verifyOTP(e, transaction);\r\n              } else {\r\n                setTransaction(transaction);\r\n              }\r\n              setLoading(false);\r\n              onClick();\r\n            } catch (err) {\r\n              notify({\r\n                message: \"Claim failed\",\r\n                description: `${err}`,\r\n              });\r\n              setLoading(false);\r\n            }\r\n          };\r\n          wrap();\r\n        }}\r\n      >\r\n        {asyncNeedsTemporalSigner ? \"Next\" : \"Claim Gumdrop\"}\r\n      </Button>\r\n      {loading && loadingProgress()}\r\n      </Box>\r\n    </React.Fragment>\r\n  );\r\n\r\n  const steps = [\r\n    { name: \"Populate Claim\", inner: populateClaimC },\r\n  ];\r\n  if (asyncNeedsTemporalSigner) {\r\n    steps.push(\r\n    { name: \"Verify OTP\"    , inner: verifyOTPC     }\r\n    );\r\n  }\r\n\r\n  // TODO: better interaction between setting `asyncNeedsTemporalSigner` and\r\n  // the stepper... this is pretty jank\r\n  const [activeStep, setActiveStep] = React.useState(0);\r\n  const stepToUse = Math.min(activeStep, steps.length - 1);\r\n\r\n  const handleNext = () => {\r\n    // return to start if going past the end (claim succeeded)\r\n    setActiveStep(prev => {\r\n      if (prev === steps.length - 1) {\r\n        return 0;\r\n      } else {\r\n        return prev + 1;\r\n      }\r\n    });\r\n  };\r\n  const handleBack = () => {\r\n    setActiveStep(prev => prev - 1);\r\n  };\r\n\r\n  const stepper = (\r\n    <React.Fragment>\r\n      <Stepper activeStep={stepToUse}>\r\n        {steps.map(s => {\r\n          return (\r\n            <Step key={s.name}>\r\n              <StepLabel>{s.name}</StepLabel>\r\n            </Step>\r\n          );\r\n        })}\r\n      </Stepper>\r\n      <Box />\r\n    </React.Fragment>\r\n  );\r\n\r\n  return (\r\n    <Stack spacing={2}>\r\n      {asyncNeedsTemporalSigner && stepper}\r\n      {steps[stepToUse].inner(handleNext)}\r\n      {stepToUse > 0 && (\r\n        <Button\r\n          color=\"info\"\r\n          onClick={handleBack}\r\n        >\r\n          Back\r\n        </Button>\r\n      )}\r\n    </Stack>\r\n  );\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}