{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCachedAccount = exports.cache = exports.genericCache = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst eventEmitter_1 = require(\"../../utils/eventEmitter\");\n\nconst deserialize_1 = require(\"./deserialize\");\n\nexports.genericCache = new Map();\nconst mintCache = new Map();\nconst pendingCalls = new Map();\nconst pendingMintCalls = new Map();\nconst keyToAccountParser = new Map();\n\nconst getMintInfo = async (connection, pubKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n  return deserialize_1.deserializeMint(data);\n};\n\nexports.cache = {\n  emitter: new eventEmitter_1.EventEmitter(),\n  query: async (connection, pubKey, parser) => {\n    let id;\n\n    if (typeof pubKey === 'string') {\n      id = new web3_js_1.PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    const account = exports.genericCache.get(address);\n\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n\n    if (query) {\n      return query;\n    } // TODO: refactor to use multiple accounts query with flush like behavior\n\n\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return exports.cache.add(id, data, parser);\n    });\n    pendingCalls.set(address, query);\n    return query;\n  },\n  add: (id, obj, parser, isActive) => {\n    const address = typeof id === 'string' ? id : id === null || id === void 0 ? void 0 : id.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n\n    if (!deserialize) {\n      throw new Error('Deserializer needs to be registered or passed as a parameter');\n    }\n\n    exports.cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;else if (isActive instanceof Function) isActive = isActive(account);\n    const isNew = !exports.genericCache.has(address);\n    exports.genericCache.set(address, account);\n    exports.cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: pubKey => {\n    let key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return exports.genericCache.get(key);\n  },\n  delete: pubKey => {\n    let key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (exports.genericCache.get(key)) {\n      exports.genericCache.delete(key);\n      exports.cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n\n    return false;\n  },\n  byParser: parser => {\n    const result = [];\n\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey, parser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey === null || pubkey === void 0 ? void 0 : pubkey.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection, pubKey) => {\n    let id;\n\n    if (typeof pubKey === 'string') {\n      id = new web3_js_1.PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    const mint = mintCache.get(address);\n\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n      mintCache.set(address, data);\n      return data;\n    });\n    pendingMintCalls.set(address, query);\n    return query;\n  },\n  getMint: pubKey => {\n    let key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey, obj) => {\n    const mint = deserialize_1.deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  }\n};\n\nconst getCachedAccount = predicate => {\n  for (const account of exports.genericCache.values()) {\n    if (predicate(account)) {\n      return account;\n    }\n  }\n};\n\nexports.getCachedAccount = getCachedAccount;","map":{"version":3,"sources":["../../../../src/contexts/accounts/cache.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getCachedAccount = exports.cache = exports.genericCache = void 0;\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\nconst eventEmitter_1 = require(\"../../utils/eventEmitter\");\r\nconst deserialize_1 = require(\"./deserialize\");\r\nexports.genericCache = new Map();\r\nconst mintCache = new Map();\r\nconst pendingCalls = new Map();\r\nconst pendingMintCalls = new Map();\r\nconst keyToAccountParser = new Map();\r\nconst getMintInfo = async (connection, pubKey) => {\r\n    const info = await connection.getAccountInfo(pubKey);\r\n    if (info === null) {\r\n        throw new Error('Failed to find mint account');\r\n    }\r\n    const data = Buffer.from(info.data);\r\n    return deserialize_1.deserializeMint(data);\r\n};\r\nexports.cache = {\r\n    emitter: new eventEmitter_1.EventEmitter(),\r\n    query: async (connection, pubKey, parser) => {\r\n        let id;\r\n        if (typeof pubKey === 'string') {\r\n            id = new web3_js_1.PublicKey(pubKey);\r\n        }\r\n        else {\r\n            id = pubKey;\r\n        }\r\n        const address = id.toBase58();\r\n        const account = exports.genericCache.get(address);\r\n        if (account) {\r\n            return account;\r\n        }\r\n        let query = pendingCalls.get(address);\r\n        if (query) {\r\n            return query;\r\n        }\r\n        // TODO: refactor to use multiple accounts query with flush like behavior\r\n        query = connection.getAccountInfo(id).then(data => {\r\n            if (!data) {\r\n                throw new Error('Account not found');\r\n            }\r\n            return exports.cache.add(id, data, parser);\r\n        });\r\n        pendingCalls.set(address, query);\r\n        return query;\r\n    },\r\n    add: (id, obj, parser, isActive) => {\r\n        const address = typeof id === 'string' ? id : id === null || id === void 0 ? void 0 : id.toBase58();\r\n        const deserialize = parser ? parser : keyToAccountParser.get(address);\r\n        if (!deserialize) {\r\n            throw new Error('Deserializer needs to be registered or passed as a parameter');\r\n        }\r\n        exports.cache.registerParser(id, deserialize);\r\n        pendingCalls.delete(address);\r\n        const account = deserialize(address, obj);\r\n        if (!account) {\r\n            return;\r\n        }\r\n        if (isActive === undefined)\r\n            isActive = true;\r\n        else if (isActive instanceof Function)\r\n            isActive = isActive(account);\r\n        const isNew = !exports.genericCache.has(address);\r\n        exports.genericCache.set(address, account);\r\n        exports.cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\r\n        return account;\r\n    },\r\n    get: (pubKey) => {\r\n        let key;\r\n        if (typeof pubKey !== 'string') {\r\n            key = pubKey.toBase58();\r\n        }\r\n        else {\r\n            key = pubKey;\r\n        }\r\n        return exports.genericCache.get(key);\r\n    },\r\n    delete: (pubKey) => {\r\n        let key;\r\n        if (typeof pubKey !== 'string') {\r\n            key = pubKey.toBase58();\r\n        }\r\n        else {\r\n            key = pubKey;\r\n        }\r\n        if (exports.genericCache.get(key)) {\r\n            exports.genericCache.delete(key);\r\n            exports.cache.emitter.raiseCacheDeleted(key);\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n    byParser: (parser) => {\r\n        const result = [];\r\n        for (const id of keyToAccountParser.keys()) {\r\n            if (keyToAccountParser.get(id) === parser) {\r\n                result.push(id);\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    registerParser: (pubkey, parser) => {\r\n        if (pubkey) {\r\n            const address = typeof pubkey === 'string' ? pubkey : pubkey === null || pubkey === void 0 ? void 0 : pubkey.toBase58();\r\n            keyToAccountParser.set(address, parser);\r\n        }\r\n        return pubkey;\r\n    },\r\n    queryMint: async (connection, pubKey) => {\r\n        let id;\r\n        if (typeof pubKey === 'string') {\r\n            id = new web3_js_1.PublicKey(pubKey);\r\n        }\r\n        else {\r\n            id = pubKey;\r\n        }\r\n        const address = id.toBase58();\r\n        const mint = mintCache.get(address);\r\n        if (mint) {\r\n            return mint;\r\n        }\r\n        let query = pendingMintCalls.get(address);\r\n        if (query) {\r\n            return query;\r\n        }\r\n        query = getMintInfo(connection, id).then(data => {\r\n            pendingMintCalls.delete(address);\r\n            mintCache.set(address, data);\r\n            return data;\r\n        });\r\n        pendingMintCalls.set(address, query);\r\n        return query;\r\n    },\r\n    getMint: (pubKey) => {\r\n        let key;\r\n        if (typeof pubKey !== 'string') {\r\n            key = pubKey.toBase58();\r\n        }\r\n        else {\r\n            key = pubKey;\r\n        }\r\n        return mintCache.get(key);\r\n    },\r\n    addMint: (pubKey, obj) => {\r\n        const mint = deserialize_1.deserializeMint(obj.data);\r\n        const id = pubKey.toBase58();\r\n        mintCache.set(id, mint);\r\n        return mint;\r\n    },\r\n};\r\nconst getCachedAccount = (predicate) => {\r\n    for (const account of exports.genericCache.values()) {\r\n        if (predicate(account)) {\r\n            return account;\r\n        }\r\n    }\r\n};\r\nexports.getCachedAccount = getCachedAccount;\r\n//# sourceMappingURL=cache.js.map"]},"metadata":{},"sourceType":"script"}