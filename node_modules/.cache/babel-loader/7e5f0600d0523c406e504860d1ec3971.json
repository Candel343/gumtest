{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryExtendedMetadata = void 0;\n\nconst accounts_1 = require(\"../accounts\");\n\nconst accounts_2 = require(\"../accounts\");\n\nconst accounts_3 = require(\"../accounts\");\n\nconst queryExtendedMetadata = async (connection, mintToMeta) => {\n  const mintToMetadata = { ...mintToMeta\n  };\n  const mints = await accounts_2.getMultipleAccounts(connection, [...Object.keys(mintToMetadata)].filter(k => !accounts_1.cache.get(k)), 'single');\n  mints.keys.forEach((key, index) => {\n    const mintAccount = mints.array[index];\n\n    if (mintAccount) {\n      const mint = accounts_1.cache.add(key, mintAccount, accounts_3.MintParser, false);\n\n      if (!mint.info.supply.eqn(1) || mint.info.decimals !== 0) {\n        // naive not NFT check\n        delete mintToMetadata[key];\n      } else {// const metadata = mintToMetadata[key];\n      }\n    }\n  }); // await Promise.all([...extendedMetadataFetch.values()]);\n\n  const metadata = [...Object.values(mintToMetadata)];\n  return {\n    metadata,\n    mintToMetadata\n  };\n};\n\nexports.queryExtendedMetadata = queryExtendedMetadata;","map":{"version":3,"sources":["../../../../src/contexts/meta/queryExtendedMetadata.ts"],"names":[],"mappings":";;;;;;;AAIA,MAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEO,MAAM,qBAAqB,GAAG,OACnC,UADmC,EAEnC,UAFmC,KAGjC;AACF,QAAM,cAAc,GAAG,EAAE,GAAG;AAAL,GAAvB;AAEA,QAAM,KAAK,GAAG,MAAM,UAAA,CAAA,mBAAA,CAClB,UADkB,EAElB,CAAC,GAAG,MAAM,CAAC,IAAP,CAAY,cAAZ,CAAJ,EAAiC,MAAjC,CAAwC,CAAC,IAAI,CAAC,UAAA,CAAA,KAAA,CAAM,GAAN,CAAU,CAAV,CAA9C,CAFkB,EAGlB,QAHkB,CAApB;AAMA,EAAA,KAAK,CAAC,IAAN,CAAW,OAAX,CAAmB,CAAC,GAAD,EAAM,KAAN,KAAe;AAChC,UAAM,WAAW,GAAG,KAAK,CAAC,KAAN,CAAY,KAAZ,CAApB;;AACA,QAAI,WAAJ,EAAiB;AACf,YAAM,IAAI,GAAG,UAAA,CAAA,KAAA,CAAM,GAAN,CACX,GADW,EAEX,WAFW,EAGX,UAAA,CAAA,UAHW,EAIX,KAJW,CAAb;;AAMA,UAAI,CAAC,IAAI,CAAC,IAAL,CAAU,MAAV,CAAiB,GAAjB,CAAqB,CAArB,CAAD,IAA4B,IAAI,CAAC,IAAL,CAAU,QAAV,KAAuB,CAAvD,EAA0D;AACxD;AACA,eAAO,cAAc,CAAC,GAAD,CAArB;AACD,OAHD,MAGO,CACL;AACD;AACF;AACF,GAhBD,EATE,CA2BF;;AACA,QAAM,QAAQ,GAAG,CAAC,GAAG,MAAM,CAAC,MAAP,CAAc,cAAd,CAAJ,CAAjB;AAEA,SAAO;AACL,IAAA,QADK;AAEL,IAAA;AAFK,GAAP;AAID,CArCM;;AAAM,OAAA,CAAA,qBAAA,GAAqB,qBAArB","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.queryExtendedMetadata = void 0;\r\nconst accounts_1 = require(\"../accounts\");\r\nconst accounts_2 = require(\"../accounts\");\r\nconst accounts_3 = require(\"../accounts\");\r\nconst queryExtendedMetadata = async (connection, mintToMeta) => {\r\n    const mintToMetadata = { ...mintToMeta };\r\n    const mints = await accounts_2.getMultipleAccounts(connection, [...Object.keys(mintToMetadata)].filter(k => !accounts_1.cache.get(k)), 'single');\r\n    mints.keys.forEach((key, index) => {\r\n        const mintAccount = mints.array[index];\r\n        if (mintAccount) {\r\n            const mint = accounts_1.cache.add(key, mintAccount, accounts_3.MintParser, false);\r\n            if (!mint.info.supply.eqn(1) || mint.info.decimals !== 0) {\r\n                // naive not NFT check\r\n                delete mintToMetadata[key];\r\n            }\r\n            else {\r\n                // const metadata = mintToMetadata[key];\r\n            }\r\n        }\r\n    });\r\n    // await Promise.all([...extendedMetadataFetch.values()]);\r\n    const metadata = [...Object.values(mintToMetadata)];\r\n    return {\r\n        metadata,\r\n        mintToMetadata,\r\n    };\r\n};\r\nexports.queryExtendedMetadata = queryExtendedMetadata;\r\n//# sourceMappingURL=queryExtendedMetadata.js.map"]},"metadata":{},"sourceType":"script"}