{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendSignedTransaction = exports.getUnixTs = exports.sendTransactionWithRetry = exports.sendTransaction = exports.sendTransactions = exports.sendTransactionsWithManualRetry = exports.SequenceType = exports.getErrorForTransaction = exports.useConnectionConfig = exports.useConnection = exports.ConnectionProvider = exports.ENDPOINTS = void 0;\n\nconst utils_1 = require(\"../utils/utils\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst react_1 = __importStar(require(\"react\"));\n\nconst notifications_1 = require(\"../utils/notifications\");\n\nconst ExplorerLink_1 = require(\"../components/ExplorerLink\");\n\nconst hooks_1 = require(\"../hooks\");\n\nconst spl_token_registry_1 = require(\"@solana/spl-token-registry\");\n\nconst wallet_adapter_base_1 = require(\"@solana/wallet-adapter-base\");\n\nexports.ENDPOINTS = [{\n  name: 'mainnet-beta',\n  endpoint: 'https://api.metaplex.solana.com/',\n  ChainId: spl_token_registry_1.ENV.MainnetBeta\n}, {\n  name: 'mainnet-beta (Solana)',\n  endpoint: 'https://api.mainnet-beta.solana.com',\n  ChainId: spl_token_registry_1.ENV.MainnetBeta\n}, {\n  name: 'mainnet-beta (Serum)',\n  endpoint: 'https://solana-api.projectserum.com/',\n  ChainId: spl_token_registry_1.ENV.MainnetBeta\n}, {\n  name: 'testnet',\n  endpoint: web3_js_1.clusterApiUrl('testnet'),\n  ChainId: spl_token_registry_1.ENV.Testnet\n}, {\n  name: 'devnet',\n  endpoint: web3_js_1.clusterApiUrl('devnet'),\n  ChainId: spl_token_registry_1.ENV.Devnet\n}];\nconst DEFAULT = exports.ENDPOINTS[0].endpoint;\nconst ConnectionContext = react_1.default.createContext({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new web3_js_1.Connection(DEFAULT, 'recent'),\n  env: exports.ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map()\n});\n\nfunction ConnectionProvider({\n  children = undefined\n}) {\n  var _a, _b;\n\n  const searchParams = hooks_1.useQuerySearch();\n  const network = searchParams.get('network');\n  const queryEndpoint = network && ((_a = exports.ENDPOINTS.find(({\n    name\n  }) => name.startsWith(network))) === null || _a === void 0 ? void 0 : _a.endpoint);\n  const [savedEndpoint, setEndpoint] = utils_1.useLocalStorageState('connectionEndpoint', exports.ENDPOINTS[0].endpoint);\n  const endpoint = queryEndpoint || savedEndpoint;\n  const connection = react_1.useMemo(() => new web3_js_1.Connection(endpoint, 'recent'), [endpoint]);\n  const env = ((_b = exports.ENDPOINTS.find(end => end.endpoint === endpoint)) === null || _b === void 0 ? void 0 : _b.name) || exports.ENDPOINTS[0].name;\n  const [tokens, setTokens] = react_1.useState([]);\n  const [tokenMap, setTokenMap] = react_1.useState(new Map());\n  react_1.useEffect(() => {\n    // fetch token files\n    new spl_token_registry_1.TokenListProvider().resolve().then(container => {\n      var _a;\n\n      const list = container.excludeByTag('nft').filterByChainId(((_a = exports.ENDPOINTS.find(end => end.endpoint === endpoint)) === null || _a === void 0 ? void 0 : _a.ChainId) || spl_token_registry_1.ENV.MainnetBeta).getList();\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map());\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env]); // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n\n  react_1.useEffect(() => {\n    const id = connection.onAccountChange(web3_js_1.Keypair.generate().publicKey, () => {});\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n  react_1.useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n  return react_1.default.createElement(ConnectionContext.Provider, {\n    value: {\n      endpoint,\n      setEndpoint,\n      connection,\n      tokens,\n      tokenMap,\n      env\n    }\n  }, children);\n}\n\nexports.ConnectionProvider = ConnectionProvider;\n\nfunction useConnection() {\n  return react_1.useContext(ConnectionContext).connection;\n}\n\nexports.useConnection = useConnection;\n\nfunction useConnectionConfig() {\n  const context = react_1.useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap\n  };\n}\n\nexports.useConnectionConfig = useConnectionConfig;\n\nconst getErrorForTransaction = async (connection, txid) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n  const errors = [];\n\n  if ((tx === null || tx === void 0 ? void 0 : tx.meta) && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexports.getErrorForTransaction = getErrorForTransaction;\nvar SequenceType;\n\n(function (SequenceType) {\n  SequenceType[SequenceType[\"Sequential\"] = 0] = \"Sequential\";\n  SequenceType[SequenceType[\"Parallel\"] = 1] = \"Parallel\";\n  SequenceType[SequenceType[\"StopOnFailure\"] = 2] = \"StopOnFailure\";\n})(SequenceType = exports.SequenceType || (exports.SequenceType = {}));\n\nasync function sendTransactionsWithManualRetry(connection, wallet, instructions, signers) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        await exports.sendTransactionWithRetry(connection, wallet, instructions[0], filteredSigners[0], 'single');\n        stopPoint = 1;\n      } else {\n        stopPoint = await exports.sendTransactions(connection, wallet, instructions, filteredSigners, SequenceType.StopOnFailure, 'single');\n      }\n    } catch (e) {\n      console.error(e);\n    }\n\n    console.log('Died on ', stopPoint, 'retrying from instruction', instructions[stopPoint], 'instructions length is', instructions.length);\n    lastInstructionsLength = instructions.length;\n  }\n}\n\nexports.sendTransactionsWithManualRetry = sendTransactionsWithManualRetry;\n\nconst sendTransactions = async (connection, wallet, instructionSet, signersSet, sequenceType = SequenceType.Parallel, commitment = 'singleGossip', successCallback = (txid, ind) => {}, failCallback = (txid, ind) => false, block) => {\n  if (!wallet.publicKey) throw new wallet_adapter_base_1.WalletNotConnectedError();\n  const unsignedTxns = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new web3_js_1.Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n  const pendingTxns = [];\n  let breakEarlyObject = {\n    breakEarly: false,\n    i: 0\n  };\n  console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);\n\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i]\n    });\n    signedTxnPromise.then(({\n      txid,\n      slot\n    }) => {\n      successCallback(txid, i);\n    }).catch(reason => {\n      // @ts-ignore\n      failCallback(signedTxns[i], i);\n\n      if (sequenceType === SequenceType.StopOnFailure) {\n        breakEarlyObject.breakEarly = true;\n        breakEarlyObject.i = i;\n      }\n    });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          return breakEarlyObject.i; // Return the txn we failed on by index\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return signedTxns.length;\n};\n\nexports.sendTransactions = sendTransactions;\n\nconst sendTransaction = async (connection, wallet, instructions, signers, awaitConfirmation = true, commitment = 'singleGossip', includesFeePayer = false, block) => {\n  if (!wallet.publicKey) throw new wallet_adapter_base_1.WalletNotConnectedError();\n  let transaction = new web3_js_1.Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment\n  };\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, DEFAULT_TIMEOUT, connection, commitment);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n\n    if (confirmation === null || confirmation === void 0 ? void 0 : confirmation.err) {\n      const errors = await exports.getErrorForTransaction(connection, txid);\n      notifications_1.notify({\n        message: 'Transaction failed...',\n        description: react_1.default.createElement(react_1.default.Fragment, null, errors.map(err => react_1.default.createElement(\"div\", null, err)), react_1.default.createElement(ExplorerLink_1.ExplorerLink, {\n          address: txid,\n          type: \"transaction\"\n        })),\n        type: 'error'\n      });\n      throw new Error(`Raw transaction ${txid} failed (${JSON.stringify(status)})`);\n    }\n  }\n\n  return {\n    txid,\n    slot\n  };\n};\n\nexports.sendTransaction = sendTransaction;\n\nconst sendTransactionWithRetry = async (connection, wallet, instructions, signers, commitment = 'singleGossip', includesFeePayer = false, block, beforeSend) => {\n  if (!wallet.publicKey) throw new wallet_adapter_base_1.WalletNotConnectedError();\n  let transaction = new web3_js_1.Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const {\n    txid,\n    slot\n  } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction\n  });\n  return {\n    txid,\n    slot\n  };\n};\n\nexports.sendTransactionWithRetry = sendTransactionWithRetry;\n\nconst getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexports.getUnixTs = getUnixTs;\nconst DEFAULT_TIMEOUT = 15000;\n\nasync function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT\n}) {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = exports.getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n  console.log('Started awaiting confirmation for', txid);\n  let done = false;\n\n  (async () => {\n    while (!done && exports.getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await utils_1.sleep(500);\n    }\n  })();\n\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n  } catch (err) {\n    console.error('Timeout Error caught', err);\n\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n\n    let simulateResult = null;\n\n    try {\n      simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;\n    } catch (e) {}\n\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n\n          if (line.startsWith('Program log: ')) {\n            throw new Error('Transaction failed: ' + line.slice('Program log: '.length));\n          }\n        }\n      }\n\n      throw new Error(JSON.stringify(simulateResult.err));\n    } // throw new Error('Transaction failed');\n\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, exports.getUnixTs() - startTime);\n  return {\n    txid,\n    slot\n  };\n}\n\nexports.sendSignedTransaction = sendSignedTransaction;\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = {\n    encoding: 'base64',\n    commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest('simulateTransaction', args);\n\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection, commitment = 'recent', queryStatus = false) {\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    try {\n      subId = connection.onSignature(txid, (result, context) => {\n        done = true;\n        status = {\n          err: result.err,\n          slot: context.slot,\n          confirmations: 0\n        };\n\n        if (result.err) {\n          console.log('Rejected via websocket', result.err);\n          reject(status);\n        } else {\n          console.log('Resolved via websocket', result);\n          resolve(status);\n        }\n      }, commitment);\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await utils_1.sleep(2000);\n    }\n  }); //@ts-ignore\n\n  if (connection._signatureSubscriptions[subId]) connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}","map":{"version":3,"sources":["../../../src/contexts/connection.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sendSignedTransaction = exports.getUnixTs = exports.sendTransactionWithRetry = exports.sendTransaction = exports.sendTransactions = exports.sendTransactionsWithManualRetry = exports.SequenceType = exports.getErrorForTransaction = exports.useConnectionConfig = exports.useConnection = exports.ConnectionProvider = exports.ENDPOINTS = void 0;\r\nconst utils_1 = require(\"../utils/utils\");\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\nconst react_1 = __importStar(require(\"react\"));\r\nconst notifications_1 = require(\"../utils/notifications\");\r\nconst ExplorerLink_1 = require(\"../components/ExplorerLink\");\r\nconst hooks_1 = require(\"../hooks\");\r\nconst spl_token_registry_1 = require(\"@solana/spl-token-registry\");\r\nconst wallet_adapter_base_1 = require(\"@solana/wallet-adapter-base\");\r\nexports.ENDPOINTS = [\r\n    {\r\n        name: 'mainnet-beta',\r\n        endpoint: 'https://api.metaplex.solana.com/',\r\n        ChainId: spl_token_registry_1.ENV.MainnetBeta,\r\n    },\r\n    {\r\n        name: 'mainnet-beta (Solana)',\r\n        endpoint: 'https://api.mainnet-beta.solana.com',\r\n        ChainId: spl_token_registry_1.ENV.MainnetBeta,\r\n    },\r\n    {\r\n        name: 'mainnet-beta (Serum)',\r\n        endpoint: 'https://solana-api.projectserum.com/',\r\n        ChainId: spl_token_registry_1.ENV.MainnetBeta,\r\n    },\r\n    {\r\n        name: 'testnet',\r\n        endpoint: web3_js_1.clusterApiUrl('testnet'),\r\n        ChainId: spl_token_registry_1.ENV.Testnet,\r\n    },\r\n    {\r\n        name: 'devnet',\r\n        endpoint: web3_js_1.clusterApiUrl('devnet'),\r\n        ChainId: spl_token_registry_1.ENV.Devnet,\r\n    },\r\n];\r\nconst DEFAULT = exports.ENDPOINTS[0].endpoint;\r\nconst ConnectionContext = react_1.default.createContext({\r\n    endpoint: DEFAULT,\r\n    setEndpoint: () => { },\r\n    connection: new web3_js_1.Connection(DEFAULT, 'recent'),\r\n    env: exports.ENDPOINTS[0].name,\r\n    tokens: [],\r\n    tokenMap: new Map(),\r\n});\r\nfunction ConnectionProvider({ children = undefined }) {\r\n    var _a, _b;\r\n    const searchParams = hooks_1.useQuerySearch();\r\n    const network = searchParams.get('network');\r\n    const queryEndpoint = network && ((_a = exports.ENDPOINTS.find(({ name }) => name.startsWith(network))) === null || _a === void 0 ? void 0 : _a.endpoint);\r\n    const [savedEndpoint, setEndpoint] = utils_1.useLocalStorageState('connectionEndpoint', exports.ENDPOINTS[0].endpoint);\r\n    const endpoint = queryEndpoint || savedEndpoint;\r\n    const connection = react_1.useMemo(() => new web3_js_1.Connection(endpoint, 'recent'), [endpoint]);\r\n    const env = ((_b = exports.ENDPOINTS.find(end => end.endpoint === endpoint)) === null || _b === void 0 ? void 0 : _b.name) || exports.ENDPOINTS[0].name;\r\n    const [tokens, setTokens] = react_1.useState([]);\r\n    const [tokenMap, setTokenMap] = react_1.useState(new Map());\r\n    react_1.useEffect(() => {\r\n        // fetch token files\r\n        new spl_token_registry_1.TokenListProvider().resolve().then(container => {\r\n            var _a;\r\n            const list = container\r\n                .excludeByTag('nft')\r\n                .filterByChainId(((_a = exports.ENDPOINTS.find(end => end.endpoint === endpoint)) === null || _a === void 0 ? void 0 : _a.ChainId) ||\r\n                spl_token_registry_1.ENV.MainnetBeta)\r\n                .getList();\r\n            const knownMints = [...list].reduce((map, item) => {\r\n                map.set(item.address, item);\r\n                return map;\r\n            }, new Map());\r\n            setTokenMap(knownMints);\r\n            setTokens(list);\r\n        });\r\n    }, [env]);\r\n    // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\r\n    // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\r\n    // This is a hack to prevent the list from every getting empty\r\n    react_1.useEffect(() => {\r\n        const id = connection.onAccountChange(web3_js_1.Keypair.generate().publicKey, () => { });\r\n        return () => {\r\n            connection.removeAccountChangeListener(id);\r\n        };\r\n    }, [connection]);\r\n    react_1.useEffect(() => {\r\n        const id = connection.onSlotChange(() => null);\r\n        return () => {\r\n            connection.removeSlotChangeListener(id);\r\n        };\r\n    }, [connection]);\r\n    return (react_1.default.createElement(ConnectionContext.Provider, { value: {\r\n            endpoint,\r\n            setEndpoint,\r\n            connection,\r\n            tokens,\r\n            tokenMap,\r\n            env,\r\n        } }, children));\r\n}\r\nexports.ConnectionProvider = ConnectionProvider;\r\nfunction useConnection() {\r\n    return react_1.useContext(ConnectionContext).connection;\r\n}\r\nexports.useConnection = useConnection;\r\nfunction useConnectionConfig() {\r\n    const context = react_1.useContext(ConnectionContext);\r\n    return {\r\n        endpoint: context.endpoint,\r\n        setEndpoint: context.setEndpoint,\r\n        env: context.env,\r\n        tokens: context.tokens,\r\n        tokenMap: context.tokenMap,\r\n    };\r\n}\r\nexports.useConnectionConfig = useConnectionConfig;\r\nconst getErrorForTransaction = async (connection, txid) => {\r\n    // wait for all confirmation before geting transaction\r\n    await connection.confirmTransaction(txid, 'max');\r\n    const tx = await connection.getParsedConfirmedTransaction(txid);\r\n    const errors = [];\r\n    if ((tx === null || tx === void 0 ? void 0 : tx.meta) && tx.meta.logMessages) {\r\n        tx.meta.logMessages.forEach(log => {\r\n            const regex = /Error: (.*)/gm;\r\n            let m;\r\n            while ((m = regex.exec(log)) !== null) {\r\n                // This is necessary to avoid infinite loops with zero-width matches\r\n                if (m.index === regex.lastIndex) {\r\n                    regex.lastIndex++;\r\n                }\r\n                if (m.length > 1) {\r\n                    errors.push(m[1]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return errors;\r\n};\r\nexports.getErrorForTransaction = getErrorForTransaction;\r\nvar SequenceType;\r\n(function (SequenceType) {\r\n    SequenceType[SequenceType[\"Sequential\"] = 0] = \"Sequential\";\r\n    SequenceType[SequenceType[\"Parallel\"] = 1] = \"Parallel\";\r\n    SequenceType[SequenceType[\"StopOnFailure\"] = 2] = \"StopOnFailure\";\r\n})(SequenceType = exports.SequenceType || (exports.SequenceType = {}));\r\nasync function sendTransactionsWithManualRetry(connection, wallet, instructions, signers) {\r\n    let stopPoint = 0;\r\n    let tries = 0;\r\n    let lastInstructionsLength = null;\r\n    let toRemoveSigners = {};\r\n    instructions = instructions.filter((instr, i) => {\r\n        if (instr.length > 0) {\r\n            return true;\r\n        }\r\n        else {\r\n            toRemoveSigners[i] = true;\r\n            return false;\r\n        }\r\n    });\r\n    let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\r\n    while (stopPoint < instructions.length && tries < 3) {\r\n        instructions = instructions.slice(stopPoint, instructions.length);\r\n        filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\r\n        if (instructions.length === lastInstructionsLength)\r\n            tries = tries + 1;\r\n        else\r\n            tries = 0;\r\n        try {\r\n            if (instructions.length === 1) {\r\n                await exports.sendTransactionWithRetry(connection, wallet, instructions[0], filteredSigners[0], 'single');\r\n                stopPoint = 1;\r\n            }\r\n            else {\r\n                stopPoint = await exports.sendTransactions(connection, wallet, instructions, filteredSigners, SequenceType.StopOnFailure, 'single');\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n        console.log('Died on ', stopPoint, 'retrying from instruction', instructions[stopPoint], 'instructions length is', instructions.length);\r\n        lastInstructionsLength = instructions.length;\r\n    }\r\n}\r\nexports.sendTransactionsWithManualRetry = sendTransactionsWithManualRetry;\r\nconst sendTransactions = async (connection, wallet, instructionSet, signersSet, sequenceType = SequenceType.Parallel, commitment = 'singleGossip', successCallback = (txid, ind) => { }, failCallback = (txid, ind) => false, block) => {\r\n    if (!wallet.publicKey)\r\n        throw new wallet_adapter_base_1.WalletNotConnectedError();\r\n    const unsignedTxns = [];\r\n    if (!block) {\r\n        block = await connection.getRecentBlockhash(commitment);\r\n    }\r\n    for (let i = 0; i < instructionSet.length; i++) {\r\n        const instructions = instructionSet[i];\r\n        const signers = signersSet[i];\r\n        if (instructions.length === 0) {\r\n            continue;\r\n        }\r\n        let transaction = new web3_js_1.Transaction();\r\n        instructions.forEach(instruction => transaction.add(instruction));\r\n        transaction.recentBlockhash = block.blockhash;\r\n        transaction.setSigners(\r\n        // fee payed by the wallet owner\r\n        wallet.publicKey, ...signers.map(s => s.publicKey));\r\n        if (signers.length > 0) {\r\n            transaction.partialSign(...signers);\r\n        }\r\n        unsignedTxns.push(transaction);\r\n    }\r\n    const signedTxns = await wallet.signAllTransactions(unsignedTxns);\r\n    const pendingTxns = [];\r\n    let breakEarlyObject = { breakEarly: false, i: 0 };\r\n    console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);\r\n    for (let i = 0; i < signedTxns.length; i++) {\r\n        const signedTxnPromise = sendSignedTransaction({\r\n            connection,\r\n            signedTransaction: signedTxns[i],\r\n        });\r\n        signedTxnPromise\r\n            .then(({ txid, slot }) => {\r\n            successCallback(txid, i);\r\n        })\r\n            .catch(reason => {\r\n            // @ts-ignore\r\n            failCallback(signedTxns[i], i);\r\n            if (sequenceType === SequenceType.StopOnFailure) {\r\n                breakEarlyObject.breakEarly = true;\r\n                breakEarlyObject.i = i;\r\n            }\r\n        });\r\n        if (sequenceType !== SequenceType.Parallel) {\r\n            try {\r\n                await signedTxnPromise;\r\n            }\r\n            catch (e) {\r\n                console.log('Caught failure', e);\r\n                if (breakEarlyObject.breakEarly) {\r\n                    console.log('Died on ', breakEarlyObject.i);\r\n                    return breakEarlyObject.i; // Return the txn we failed on by index\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            pendingTxns.push(signedTxnPromise);\r\n        }\r\n    }\r\n    if (sequenceType !== SequenceType.Parallel) {\r\n        await Promise.all(pendingTxns);\r\n    }\r\n    return signedTxns.length;\r\n};\r\nexports.sendTransactions = sendTransactions;\r\nconst sendTransaction = async (connection, wallet, instructions, signers, awaitConfirmation = true, commitment = 'singleGossip', includesFeePayer = false, block) => {\r\n    if (!wallet.publicKey)\r\n        throw new wallet_adapter_base_1.WalletNotConnectedError();\r\n    let transaction = new web3_js_1.Transaction();\r\n    instructions.forEach(instruction => transaction.add(instruction));\r\n    transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\r\n    if (includesFeePayer) {\r\n        transaction.setSigners(...signers.map(s => s.publicKey));\r\n    }\r\n    else {\r\n        transaction.setSigners(\r\n        // fee payed by the wallet owner\r\n        wallet.publicKey, ...signers.map(s => s.publicKey));\r\n    }\r\n    if (signers.length > 0) {\r\n        transaction.partialSign(...signers);\r\n    }\r\n    if (!includesFeePayer) {\r\n        transaction = await wallet.signTransaction(transaction);\r\n    }\r\n    const rawTransaction = transaction.serialize();\r\n    let options = {\r\n        skipPreflight: true,\r\n        commitment,\r\n    };\r\n    const txid = await connection.sendRawTransaction(rawTransaction, options);\r\n    let slot = 0;\r\n    if (awaitConfirmation) {\r\n        const confirmation = await awaitTransactionSignatureConfirmation(txid, DEFAULT_TIMEOUT, connection, commitment);\r\n        if (!confirmation)\r\n            throw new Error('Timed out awaiting confirmation on transaction');\r\n        slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\r\n        if (confirmation === null || confirmation === void 0 ? void 0 : confirmation.err) {\r\n            const errors = await exports.getErrorForTransaction(connection, txid);\r\n            notifications_1.notify({\r\n                message: 'Transaction failed...',\r\n                description: (react_1.default.createElement(react_1.default.Fragment, null,\r\n                    errors.map(err => (react_1.default.createElement(\"div\", null, err))),\r\n                    react_1.default.createElement(ExplorerLink_1.ExplorerLink, { address: txid, type: \"transaction\" }))),\r\n                type: 'error',\r\n            });\r\n            throw new Error(`Raw transaction ${txid} failed (${JSON.stringify(status)})`);\r\n        }\r\n    }\r\n    return { txid, slot };\r\n};\r\nexports.sendTransaction = sendTransaction;\r\nconst sendTransactionWithRetry = async (connection, wallet, instructions, signers, commitment = 'singleGossip', includesFeePayer = false, block, beforeSend) => {\r\n    if (!wallet.publicKey)\r\n        throw new wallet_adapter_base_1.WalletNotConnectedError();\r\n    let transaction = new web3_js_1.Transaction();\r\n    instructions.forEach(instruction => transaction.add(instruction));\r\n    transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\r\n    if (includesFeePayer) {\r\n        transaction.setSigners(...signers.map(s => s.publicKey));\r\n    }\r\n    else {\r\n        transaction.setSigners(\r\n        // fee payed by the wallet owner\r\n        wallet.publicKey, ...signers.map(s => s.publicKey));\r\n    }\r\n    if (signers.length > 0) {\r\n        transaction.partialSign(...signers);\r\n    }\r\n    if (!includesFeePayer) {\r\n        transaction = await wallet.signTransaction(transaction);\r\n    }\r\n    if (beforeSend) {\r\n        beforeSend();\r\n    }\r\n    const { txid, slot } = await sendSignedTransaction({\r\n        connection,\r\n        signedTransaction: transaction,\r\n    });\r\n    return { txid, slot };\r\n};\r\nexports.sendTransactionWithRetry = sendTransactionWithRetry;\r\nconst getUnixTs = () => {\r\n    return new Date().getTime() / 1000;\r\n};\r\nexports.getUnixTs = getUnixTs;\r\nconst DEFAULT_TIMEOUT = 15000;\r\nasync function sendSignedTransaction({ signedTransaction, connection, timeout = DEFAULT_TIMEOUT, }) {\r\n    const rawTransaction = signedTransaction.serialize();\r\n    const startTime = exports.getUnixTs();\r\n    let slot = 0;\r\n    const txid = await connection.sendRawTransaction(rawTransaction, {\r\n        skipPreflight: true,\r\n    });\r\n    console.log('Started awaiting confirmation for', txid);\r\n    let done = false;\r\n    (async () => {\r\n        while (!done && exports.getUnixTs() - startTime < timeout) {\r\n            connection.sendRawTransaction(rawTransaction, {\r\n                skipPreflight: true,\r\n            });\r\n            await utils_1.sleep(500);\r\n        }\r\n    })();\r\n    try {\r\n        const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);\r\n        if (!confirmation)\r\n            throw new Error('Timed out awaiting confirmation on transaction');\r\n        if (confirmation.err) {\r\n            console.error(confirmation.err);\r\n            throw new Error('Transaction failed: Custom instruction error');\r\n        }\r\n        slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\r\n    }\r\n    catch (err) {\r\n        console.error('Timeout Error caught', err);\r\n        if (err.timeout) {\r\n            throw new Error('Timed out awaiting confirmation on transaction');\r\n        }\r\n        let simulateResult = null;\r\n        try {\r\n            simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;\r\n        }\r\n        catch (e) { }\r\n        if (simulateResult && simulateResult.err) {\r\n            if (simulateResult.logs) {\r\n                for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n                    const line = simulateResult.logs[i];\r\n                    if (line.startsWith('Program log: ')) {\r\n                        throw new Error('Transaction failed: ' + line.slice('Program log: '.length));\r\n                    }\r\n                }\r\n            }\r\n            throw new Error(JSON.stringify(simulateResult.err));\r\n        }\r\n        // throw new Error('Transaction failed');\r\n    }\r\n    finally {\r\n        done = true;\r\n    }\r\n    console.log('Latency', txid, exports.getUnixTs() - startTime);\r\n    return { txid, slot };\r\n}\r\nexports.sendSignedTransaction = sendSignedTransaction;\r\nasync function simulateTransaction(connection, transaction, commitment) {\r\n    // @ts-ignore\r\n    transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching);\r\n    const signData = transaction.serializeMessage();\r\n    // @ts-ignore\r\n    const wireTransaction = transaction._serialize(signData);\r\n    const encodedTransaction = wireTransaction.toString('base64');\r\n    const config = { encoding: 'base64', commitment };\r\n    const args = [encodedTransaction, config];\r\n    // @ts-ignore\r\n    const res = await connection._rpcRequest('simulateTransaction', args);\r\n    if (res.error) {\r\n        throw new Error('failed to simulate transaction: ' + res.error.message);\r\n    }\r\n    return res.result;\r\n}\r\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection, commitment = 'recent', queryStatus = false) {\r\n    let done = false;\r\n    let status = {\r\n        slot: 0,\r\n        confirmations: 0,\r\n        err: null,\r\n    };\r\n    let subId = 0;\r\n    status = await new Promise(async (resolve, reject) => {\r\n        setTimeout(() => {\r\n            if (done) {\r\n                return;\r\n            }\r\n            done = true;\r\n            console.log('Rejecting for timeout...');\r\n            reject({ timeout: true });\r\n        }, timeout);\r\n        try {\r\n            subId = connection.onSignature(txid, (result, context) => {\r\n                done = true;\r\n                status = {\r\n                    err: result.err,\r\n                    slot: context.slot,\r\n                    confirmations: 0,\r\n                };\r\n                if (result.err) {\r\n                    console.log('Rejected via websocket', result.err);\r\n                    reject(status);\r\n                }\r\n                else {\r\n                    console.log('Resolved via websocket', result);\r\n                    resolve(status);\r\n                }\r\n            }, commitment);\r\n        }\r\n        catch (e) {\r\n            done = true;\r\n            console.error('WS error in setup', txid, e);\r\n        }\r\n        while (!done && queryStatus) {\r\n            // eslint-disable-next-line no-loop-func\r\n            (async () => {\r\n                try {\r\n                    const signatureStatuses = await connection.getSignatureStatuses([\r\n                        txid,\r\n                    ]);\r\n                    status = signatureStatuses && signatureStatuses.value[0];\r\n                    if (!done) {\r\n                        if (!status) {\r\n                            console.log('REST null result for', txid, status);\r\n                        }\r\n                        else if (status.err) {\r\n                            console.log('REST error for', txid, status);\r\n                            done = true;\r\n                            reject(status.err);\r\n                        }\r\n                        else if (!status.confirmations) {\r\n                            console.log('REST no confirmations for', txid, status);\r\n                        }\r\n                        else {\r\n                            console.log('REST confirmation for', txid, status);\r\n                            done = true;\r\n                            resolve(status);\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    if (!done) {\r\n                        console.log('REST connection error: txid', txid, e);\r\n                    }\r\n                }\r\n            })();\r\n            await utils_1.sleep(2000);\r\n        }\r\n    });\r\n    //@ts-ignore\r\n    if (connection._signatureSubscriptions[subId])\r\n        connection.removeSignatureListener(subId);\r\n    done = true;\r\n    console.log('Returning status', status);\r\n    return status;\r\n}\r\n//# sourceMappingURL=connection.js.map"]},"metadata":{},"sourceType":"script"}