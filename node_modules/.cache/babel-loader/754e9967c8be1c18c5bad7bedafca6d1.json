{"ast":null,"code":"import { PublicKey, SystemProgram, TransactionInstruction } from \"@solana/web3.js\";\nimport { Token } from \"@solana/spl-token\";\nimport { SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"@oyster/common\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\nimport { getCandyConfig, getCandyMachineAddress, getCandyMachine, getCreatorTokenAccount, getEdition, getEditionMarkerPda, getMintInfo } from \"./accounts\";\nimport { CANDY_MACHINE_ID, GUMDROP_DISTRIBUTOR_ID } from \"./ids\";\nimport { MerkleTree } from \"./merkleTree\";\n\nconst csvStringToArray = strData => {\n  const objPattern = new RegExp(\"(\\\\,|\\\\r?\\\\n|\\\\r|^)(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|([^\\\\,\\\\r\\\\n]*))\", \"gi\");\n  let arrMatches = null;\n  const arrData = [[]];\n\n  while (arrMatches = objPattern.exec(strData)) {\n    if (arrMatches[1].length && arrMatches[1] !== \",\") arrData.push([]);\n    arrData[arrData.length - 1].push(arrMatches[2] ? arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\") : arrMatches[3]);\n  }\n\n  return arrData;\n};\n\nexport const parseClaimants = (input, filename, method) => {\n  const extension = filename.match(/\\.[0-9a-z]+$/i);\n\n  if (extension === null) {\n    throw new Error(`Could not parse file extension from ${filename}`);\n  }\n\n  switch (extension[0]) {\n    case \".csv\":\n      {\n        const arr = csvStringToArray(input); // TODO: more robust\n\n        let search;\n\n        if (method === \"aws-sms\") {\n          search = \"phone number\";\n        } else if (method === \"aws-email\") {\n          search = \"email\";\n        } else {\n          throw new Error(`Cannot parse csv for ${method}`);\n        }\n\n        const foundIdx = arr[0].findIndex(s => s.includes(search));\n        if (foundIdx === -1) throw new Error(`Could not find ${search} index`);\n        const numbers = new Set(arr.slice(1).filter(arr => arr[foundIdx].length > 0).map(arr => arr[foundIdx]));\n        return [...numbers].map((n, idx) => {\n          return {\n            handle: n,\n            amount: 1,\n            edition: idx\n          };\n        });\n      }\n\n    case \".json\":\n      {\n        const json = JSON.parse(input);\n        return json.map(obj => {\n          return {\n            handle: obj.handle,\n            amount: obj.amount,\n            edition: obj.edition,\n            url: obj.url\n          };\n        });\n      }\n\n    default:\n      {\n        throw new Error(`Cannot parse file format ${extension} from ${filename}`);\n      }\n  }\n};\n\nconst explorerUrlFor = (env, key) => {\n  return `https://explorer.solana.com/address/${key}?cluster=${env}`;\n};\n\nexport const dropInfoFor = (env, integration, tokenMint, candyConfig, masterMint) => {\n  switch (integration) {\n    case \"transfer\":\n      return {\n        type: \"Token\",\n        meta: explorerUrlFor(env, tokenMint)\n      };\n\n    case \"candy\":\n      return {\n        type: \"Candy\",\n        meta: explorerUrlFor(env, candyConfig)\n      };\n\n    case \"edition\":\n      return {\n        type: \"Edition\",\n        meta: explorerUrlFor(env, masterMint)\n      };\n\n    default:\n      throw new Error(`Unknown claim integration method ${integration}`);\n  }\n};\nexport const validateTransferClaims = async (connection, walletKey, claimants, mintStr) => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const mint = await getMintInfo(connection, mintStr);\n  const source = await getCreatorTokenAccount(walletKey, connection, mint.key, total);\n  return {\n    total: total,\n    mint: mint,\n    source: source\n  };\n};\nexport const validateCandyClaims = async (connection, walletKey, claimants, candyConfig, candyUuid) => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const configKey = await getCandyConfig(connection, candyConfig);\n  const [candyMachineKey] = await getCandyMachineAddress(configKey, candyUuid);\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n  const remaining = candyMachine.data.itemsAvailable.toNumber() - candyMachine.itemsRedeemed.toNumber();\n\n  if (isNaN(remaining)) {\n    // TODO: should this have an override?\n    throw new Error(`Could not calculate how many candy machine items are remaining`);\n  }\n\n  if (remaining < total) {\n    throw new Error(`Distributor is allocated more mints (${total}) ` + `than the candy machine has remaining (${remaining})`);\n  }\n\n  if (!candyMachine.authority.equals(walletKey)) {\n    throw new Error(`Candy machine authority does not match wallet public key`);\n  }\n\n  return {\n    total: total,\n    config: configKey,\n    uuid: candyUuid,\n    candyMachineKey: candyMachineKey\n  };\n};\n\nconst getOffsetFromStart = edition => {\n  return edition.mod(new BN(31 * 8));\n};\n\nconst getIndex = offsetFromStart => {\n  return offsetFromStart.div(new BN(8));\n};\n\nconst getOffsetFromRight = offsetFromStart => {\n  return new BN(7).sub(offsetFromStart.mod(new BN(8)));\n};\n\nconst getIndexAndMask = edition => {\n  const offsetFromStart = getOffsetFromStart(edition);\n  return {\n    index: getIndex(offsetFromStart).toNumber(),\n    mask: new BN(1).shln(getOffsetFromRight(offsetFromStart).toNumber()).toNumber()\n  };\n};\n\nconst editionTaken = (marker, edition) => {\n  const m = getIndexAndMask(edition);\n  return (marker[m.index] & m.mask) !== 0;\n};\n\nconst setEditionTaken = (marker, edition) => {\n  const m = getIndexAndMask(edition);\n  marker[m.index] = marker[m.index] | m.mask;\n};\n\nexport const validateEditionClaims = async (connection, walletKey, claimants, masterMintStr) => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n\n    if (c.amount !== 1) {\n      throw new Error(`Claimant ${idx} has amount ${c.amount}. Expected 1 for edition gumdrop`);\n    }\n  });\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const masterMint = await getMintInfo(connection, masterMintStr);\n  const masterTokenAccount = await getCreatorTokenAccount(walletKey, connection, masterMint.key, 1 // just check that the creator has the master mint\n  );\n  const masterEditionKey = await getEdition(masterMint.key);\n  const masterEdition = await connection.getAccountInfo(masterEditionKey);\n\n  if (masterEdition === null) {\n    throw new Error(`Could not fetch master edition`);\n  }\n\n  console.log(\"Master edition\", masterEdition); // maxSupply is an option, 9 bytes, first is 0 means is none\n\n  const currentSupply = new BN(masterEdition.data.slice(1, 1 + 8), 8, \"le\").toNumber();\n  let maxSupply;\n\n  if (masterEdition.data[9] === 0) {\n    maxSupply = null;\n  } else {\n    maxSupply = new BN(masterEdition.data.slice(10, 10 + 8), 8, \"le\").toNumber();\n  }\n\n  console.log(\"Max supply\", maxSupply);\n  console.log(\"Current supply\", currentSupply);\n\n  if (maxSupply !== null && maxSupply < total) {\n    throw new Error(`Distributor is allocated more editions (${total}) ` + `than the master has total (${maxSupply})`);\n  } // Whether an edition has been claimed is a single bit in a paginated account\n  // (pda off of master mint). The following code does some sanity checks\n  // around max supply and internally whether the distribution list has\n  // duplicate editions, and also checks if the editions were already taken on\n  // chain.\n  //\n  // There is a race condition since the authority to mint is still currently\n  // the wallet but it seems like a user error to have other editions being\n  // minted while a gumdrop is being created\n\n\n  const editions = {};\n  const editionMarkers = [];\n\n  for (let idx = 0; idx < claimants.length; ++idx) {\n    const c = claimants[idx];\n    if (c.edition === undefined) throw new Error(`Claimant ${idx} doesn't have edition`);\n\n    if (c.edition <= 0) {\n      throw new Error(`Claimant ${idx} assigned invalid edition ${c.edition}`);\n    }\n\n    if (maxSupply !== null && c.edition > maxSupply) {\n      throw new Error(`Claimant ${idx} assigned edition ${c.edition} which is beyond the max supply`);\n    }\n\n    if (c.edition in editions) {\n      throw new Error(`Claimant ${idx} and ${editions[c.edition]} are both assigned to edition ${c.edition}`);\n    }\n\n    const edition = new BN(c.edition);\n    const markerKey = await getEditionMarkerPda(masterMint.key, edition);\n    let markerData = editionMarkers.find(pm => pm[0].equals(markerKey));\n\n    if (markerData === undefined) {\n      const markerAcc = await connection.getAccountInfo(markerKey);\n\n      if (markerAcc === null) {\n        editionMarkers.push([markerKey, Array(31)]);\n      } else {\n        editionMarkers.push([markerKey, [...markerAcc.data.slice(1, 32)]]);\n      }\n\n      markerData = editionMarkers[editionMarkers.length - 1];\n    }\n\n    if (markerData === undefined) {\n      throw new Error(`Internal Error: Edition marker info still undefined ${c.edition}`);\n    }\n\n    if (editionTaken(markerData[1], edition)) {\n      throw new Error(`Claimant ${idx} is assigned to edition ${c.edition} which is already taken`);\n    }\n\n    setEditionTaken(markerData[1], edition);\n    editions[c.edition] = idx;\n  }\n\n  return {\n    total: total,\n    masterMint: masterMint,\n    masterTokenAccount: masterTokenAccount\n  };\n};\nexport const chunk = (arr, len) => {\n  const chunks = [];\n  const n = arr.length;\n  let i = 0;\n\n  while (i < n) {\n    chunks.push(arr.slice(i, i += len));\n  }\n\n  return chunks;\n};\nexport const buildGumdrop = async (connection, walletKey, needsPin, claimIntegration, host, baseKey, temporalSigner, claimants, claimInfo, extraParams = []) => {\n  const leafs = [];\n\n  for (let idx = 0; idx < claimants.length; ++idx) {\n    const claimant = claimants[idx];\n\n    if (!needsPin) {\n      try {\n        claimant.secret = new PublicKey(claimant.handle);\n      } catch (err) {\n        throw new Error(`Invalid claimant wallet handle ${err}`);\n      }\n    } else {\n      const seeds = [claimant.seed.toBuffer(), ...chunk(Buffer.from(claimant.handle), 32), Buffer.from(claimant.pin.toArray(\"le\", 4))];\n      const [claimantPda] = await PublicKey.findProgramAddress(seeds.map(s => s.slice(0, 32)), GUMDROP_DISTRIBUTOR_ID);\n      claimant.secret = claimantPda;\n    } // TODO: get this clarified with jordan... we can either just assign some\n    // range of editions to a user or give them an amount and just keep a\n    // counter on the distributor... the latter is much less work but we lose\n    // the ability to use gumdrop for auction house winnings and such?\n\n\n    const extra = claimIntegration === \"edition\" ? [...new BN(claimant.edition).toArray(\"le\", 8)] : [];\n    leafs.push(Buffer.from([...new BN(idx).toArray(\"le\", 8), ...claimant.secret.toBuffer(), ...claimant.seed.toBuffer(), ...new BN(claimant.amount).toArray(\"le\", 8), ...extra]));\n  }\n\n  const tree = new MerkleTree(leafs);\n  const root = tree.getRoot();\n  const [distributor, dbump] = await PublicKey.findProgramAddress([Buffer.from(\"MerkleDistributor\"), baseKey.toBuffer()], GUMDROP_DISTRIBUTOR_ID);\n\n  for (let idx = 0; idx < claimants.length; ++idx) {\n    const proof = tree.getProof(idx);\n    const verified = tree.verifyProof(idx, proof, root);\n\n    if (!verified) {\n      throw new Error(\"Gumdrop merkle tree verification failed\");\n    }\n\n    const claimant = claimants[idx];\n    const params = [`distributor=${distributor}`, `handle=${encodeURIComponent(claimant.handle)}`, `amount=${claimant.amount}`, `index=${idx}`, `proof=${proof.map(b => bs58.encode(b))}`, ...extraParams];\n\n    if (needsPin) {\n      params.push(`pin=${claimant.pin.toNumber()}`);\n    } else {\n      params.push(`pin=NA`);\n    }\n\n    if (claimIntegration === \"transfer\") {\n      params.push(`tokenAcc=${claimInfo.source}`);\n    } else if (claimIntegration === \"candy\") {\n      params.push(`config=${claimInfo.config}`);\n      params.push(`uuid=${claimInfo.uuid}`);\n    } else {\n      params.push(`master=${claimInfo.masterMint.key}`);\n      params.push(`edition=${claimant.edition}`);\n    }\n\n    const query = params.join(\"&\");\n    claimant.url = `${host}/claim?${query}`;\n  } // initial merkle-distributor state\n\n\n  const instructions = Array();\n  instructions.push(new TransactionInstruction({\n    programId: GUMDROP_DISTRIBUTOR_ID,\n    keys: [{\n      pubkey: baseKey,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: distributor,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: walletKey,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }],\n    data: Buffer.from([...Buffer.from(sha256.digest(\"global:new_distributor\")).slice(0, 8), ...new BN(dbump).toArray(\"le\", 1), ...root, ...temporalSigner.toBuffer()])\n  }));\n\n  if (claimIntegration === \"transfer\") {\n    instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, claimInfo.source, distributor, walletKey, [], claimInfo.total));\n  } else if (claimIntegration === \"candy\") {\n    const [distributorWalletKey] = await PublicKey.findProgramAddress([Buffer.from(\"Wallet\"), distributor.toBuffer()], GUMDROP_DISTRIBUTOR_ID);\n    instructions.push(new TransactionInstruction({\n      programId: CANDY_MACHINE_ID,\n      keys: [{\n        pubkey: claimInfo.candyMachineKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: walletKey,\n        isSigner: true,\n        isWritable: false\n      }],\n      data: Buffer.from([...Buffer.from(sha256.digest(\"global:update_authority\")).slice(0, 8), ...new BN(1).toArray(\"le\", 1), // optional exists...\n      ...distributorWalletKey.toBuffer()])\n    }));\n  } else if (claimIntegration === \"edition\") {\n    // transfer master edition to distributor\n    const [distributorTokenKey] = await PublicKey.findProgramAddress([distributor.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), claimInfo.masterMint.key.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n    instructions.push(Token.createAssociatedTokenAccountInstruction(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_PROGRAM_ID, claimInfo.masterMint.key, distributorTokenKey, distributor, walletKey));\n    instructions.push(Token.createTransferInstruction(TOKEN_PROGRAM_ID, claimInfo.masterTokenAccount, distributorTokenKey, walletKey, [], 1));\n  }\n\n  return instructions;\n};\nexport const closeGumdrop = async (connection, walletKey, base, claimMethod, transferMint, candyConfig, candyUuid, masterMint) => {\n  const [distributorKey, dbump] = await PublicKey.findProgramAddress([Buffer.from(\"MerkleDistributor\"), base.publicKey.toBuffer()], GUMDROP_DISTRIBUTOR_ID);\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress([Buffer.from(\"Wallet\"), distributorKey.toBuffer()], GUMDROP_DISTRIBUTOR_ID);\n  let extraKeys;\n  const instructions = Array();\n\n  if (claimMethod === \"transfer\") {\n    const mint = await getMintInfo(connection, transferMint);\n    const source = await getCreatorTokenAccount(walletKey, connection, mint.key, 0); // distributor is about to be closed anyway so this is redundant but...\n\n    instructions.push(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, source, walletKey, []));\n  }\n\n  if (claimMethod === \"candy\") {\n    const configKey = await getCandyConfig(connection, candyConfig);\n    const [candyMachineKey] = await getCandyMachineAddress(configKey, candyUuid);\n    extraKeys = [{\n      pubkey: candyMachineKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: CANDY_MACHINE_ID,\n      isSigner: false,\n      isWritable: false\n    }];\n  } else {\n    extraKeys = [];\n  }\n\n  if (claimMethod === \"edition\") {\n    let masterMintKey;\n\n    try {\n      masterMintKey = new PublicKey(masterMint);\n    } catch (err) {\n      throw new Error(`Invalid mint key ${err}`);\n    }\n\n    const [distributorTokenKey] = await PublicKey.findProgramAddress([distributorKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), masterMintKey.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n    const [walletTokenKey] = await PublicKey.findProgramAddress([walletKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), masterMintKey.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n    instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [{\n        pubkey: base.publicKey,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: distributorKey,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: distributorTokenKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: walletTokenKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: walletKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }],\n      data: Buffer.from([...Buffer.from(sha256.digest(\"global:close_distributor_token_account\")).slice(0, 8), ...new BN(dbump).toArray(\"le\", 1)])\n    }));\n  }\n\n  instructions.push(new TransactionInstruction({\n    programId: GUMDROP_DISTRIBUTOR_ID,\n    keys: [{\n      pubkey: base.publicKey,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: distributorKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: distributorWalletKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: walletKey,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, ...extraKeys],\n    data: Buffer.from([...Buffer.from(sha256.digest(\"global:close_distributor\")).slice(0, 8), ...new BN(dbump).toArray(\"le\", 1), ...new BN(wbump).toArray(\"le\", 1)])\n  }));\n  return instructions;\n};","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/utils/claimant.ts"],"names":["PublicKey","SystemProgram","TransactionInstruction","Token","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_PROGRAM_ID","sha256","BN","bs58","getCandyConfig","getCandyMachineAddress","getCandyMachine","getCreatorTokenAccount","getEdition","getEditionMarkerPda","getMintInfo","CANDY_MACHINE_ID","GUMDROP_DISTRIBUTOR_ID","MerkleTree","csvStringToArray","strData","objPattern","RegExp","arrMatches","arrData","exec","length","push","replace","parseClaimants","input","filename","method","extension","match","Error","arr","search","foundIdx","findIndex","s","includes","numbers","Set","slice","filter","map","n","idx","handle","amount","edition","json","JSON","parse","obj","url","explorerUrlFor","env","key","dropInfoFor","integration","tokenMint","candyConfig","masterMint","type","meta","validateTransferClaims","connection","walletKey","claimants","mintStr","forEach","c","total","reduce","acc","mint","source","validateCandyClaims","candyUuid","configKey","candyMachineKey","candyMachine","remaining","data","itemsAvailable","toNumber","itemsRedeemed","isNaN","authority","equals","config","uuid","getOffsetFromStart","mod","getIndex","offsetFromStart","div","getOffsetFromRight","sub","getIndexAndMask","index","mask","shln","editionTaken","marker","m","setEditionTaken","validateEditionClaims","masterMintStr","masterTokenAccount","masterEditionKey","masterEdition","getAccountInfo","console","log","currentSupply","maxSupply","editions","editionMarkers","undefined","markerKey","markerData","find","pm","markerAcc","Array","chunk","len","chunks","i","buildGumdrop","needsPin","claimIntegration","host","baseKey","temporalSigner","claimInfo","extraParams","leafs","claimant","secret","err","seeds","seed","toBuffer","Buffer","from","pin","toArray","claimantPda","findProgramAddress","extra","tree","root","getRoot","distributor","dbump","proof","getProof","verified","verifyProof","params","encodeURIComponent","b","encode","query","join","instructions","programId","keys","pubkey","isSigner","isWritable","digest","createApproveInstruction","distributorWalletKey","distributorTokenKey","createAssociatedTokenAccountInstruction","createTransferInstruction","closeGumdrop","base","claimMethod","transferMint","distributorKey","publicKey","wbump","extraKeys","createRevokeInstruction","masterMintKey","walletTokenKey"],"mappings":"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","sourcesContent":["import {\r\n  AccountMeta,\r\n  Connection as RPCConnection,\r\n  Keypair,\r\n  PublicKey,\r\n  SystemProgram,\r\n  TransactionInstruction,\r\n} from \"@solana/web3.js\";\r\nimport {\r\n  Token,\r\n} from \"@solana/spl-token\";\r\nimport {\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n  TOKEN_PROGRAM_ID,\r\n} from \"@oyster/common\";\r\nimport { sha256 } from \"js-sha256\";\r\nimport BN from 'bn.js';\r\nimport * as bs58 from \"bs58\";\r\n\r\nimport {\r\n  getCandyConfig,\r\n  getCandyMachineAddress,\r\n  getCandyMachine,\r\n  getCreatorTokenAccount,\r\n  getEdition,\r\n  getEditionMarkerPda,\r\n  getMintInfo,\r\n} from \"./accounts\";\r\nimport {\r\n  CANDY_MACHINE_ID,\r\n  GUMDROP_DISTRIBUTOR_ID,\r\n} from \"./ids\";\r\nimport {\r\n  MerkleTree,\r\n} from \"./merkleTree\";\r\n\r\nexport type ClaimantInfo = {\r\n  handle : string,\r\n  amount : number,\r\n  edition : number,\r\n\r\n  pin    : BN,\r\n  url    : string,\r\n\r\n  seed   : PublicKey,\r\n  secret : PublicKey,\r\n};\r\n\r\nconst csvStringToArray = (strData : any) => {\r\n  const objPattern = new RegExp((\"(\\\\,|\\\\r?\\\\n|\\\\r|^)(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|([^\\\\,\\\\r\\\\n]*))\"),\"gi\");\r\n  let arrMatches : RegExpExecArray | null = null;\r\n  const arrData : Array<Array<string>> = [[]];\r\n  while ((arrMatches = objPattern.exec(strData))) {\r\n    if (arrMatches[1].length && arrMatches[1] !== \",\")\r\n      arrData.push([]);\r\n    arrData[arrData.length - 1].push(\r\n      arrMatches[2]\r\n        ? arrMatches[2].replace(new RegExp( \"\\\"\\\"\", \"g\" ), \"\\\"\")\r\n        : arrMatches[3]);\r\n  }\r\n  return arrData;\r\n}\r\n\r\nexport type Claimants = Array<ClaimantInfo>;\r\nexport const parseClaimants = (\r\n  input : string,\r\n  filename : string,\r\n  method : string,\r\n) : Claimants => {\r\n  const extension = filename.match(/\\.[0-9a-z]+$/i);\r\n  if (extension === null) {\r\n    throw new Error(`Could not parse file extension from ${filename}`);\r\n  }\r\n  switch (extension[0]) {\r\n    case \".csv\": {\r\n      const arr = csvStringToArray(input);\r\n      // TODO: more robust\r\n      let search : string;\r\n      if (method === \"aws-sms\") {\r\n        search = \"phone number\";\r\n      } else if (method === \"aws-email\") {\r\n        search = \"email\";\r\n      } else {\r\n        throw new Error(`Cannot parse csv for ${method}`);\r\n      }\r\n      const foundIdx = arr[0].findIndex(s => s.includes(search));\r\n      if (foundIdx === -1)\r\n        throw new Error(`Could not find ${search} index`);\r\n\r\n      const numbers = new Set(\r\n        arr.slice(1)\r\n           .filter(arr => arr[foundIdx].length > 0)\r\n           .map(arr => arr[foundIdx])\r\n      );\r\n\r\n      return [...numbers].map((n, idx) => {\r\n        return {\r\n          handle : n,\r\n          amount : 1,\r\n          edition : idx,\r\n        } as any;\r\n      });\r\n    }\r\n    case \".json\": {\r\n      const json = JSON.parse(input);\r\n      return json.map((obj : any) => {\r\n        return {\r\n          handle : obj.handle,\r\n          amount : obj.amount,\r\n          edition: obj.edition,\r\n          url    : obj.url,\r\n        };\r\n      });\r\n    }\r\n    default: {\r\n      throw new Error(`Cannot parse file format ${extension} from ${filename}`);\r\n    }\r\n  }\r\n};\r\n\r\nconst explorerUrlFor = (env : string, key : string) => {\r\n  return `https://explorer.solana.com/address/${key}?cluster=${env}`;\r\n}\r\n\r\nexport type ClaimInfo = { [key: string]: any };\r\n\r\nexport const dropInfoFor = (\r\n  env : string,\r\n  integration : string,\r\n  tokenMint : string,\r\n  candyConfig : string,\r\n  masterMint : string,\r\n) => {\r\n  switch (integration) {\r\n    case \"transfer\":\r\n      return { type: \"Token\", meta: explorerUrlFor(env, tokenMint) };\r\n    case \"candy\":\r\n      return { type: \"Candy\", meta: explorerUrlFor(env, candyConfig) };\r\n    case \"edition\":\r\n      return { type: \"Edition\", meta: explorerUrlFor(env, masterMint) };\r\n    default:\r\n      throw new Error(`Unknown claim integration method ${integration}`);\r\n  }\r\n}\r\n\r\nexport const validateTransferClaims = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  claimants : Claimants,\r\n  mintStr : string,\r\n) : Promise<ClaimInfo> => {\r\n  claimants.forEach((c, idx) => {\r\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\r\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\r\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\r\n  });\r\n\r\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\r\n  const mint = await getMintInfo(connection, mintStr);\r\n  const source = await getCreatorTokenAccount(\r\n    walletKey,\r\n    connection,\r\n    mint.key,\r\n    total\r\n  );\r\n\r\n  return {\r\n    total: total,\r\n    mint: mint,\r\n    source: source,\r\n  };\r\n}\r\n\r\nexport const validateCandyClaims = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  claimants : Claimants,\r\n  candyConfig : string,\r\n  candyUuid : string,\r\n) : Promise<ClaimInfo> => {\r\n  claimants.forEach((c, idx) => {\r\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\r\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\r\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\r\n  });\r\n\r\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\r\n  const configKey = await getCandyConfig(connection, candyConfig);\r\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUuid);\r\n\r\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\r\n\r\n  const remaining = candyMachine.data.itemsAvailable.toNumber() - candyMachine.itemsRedeemed.toNumber();\r\n  if (isNaN(remaining)) {\r\n    // TODO: should this have an override?\r\n    throw new Error(`Could not calculate how many candy machine items are remaining`);\r\n  }\r\n  if (remaining < total) {\r\n    throw new Error(`Distributor is allocated more mints (${total}) `\r\n                  + `than the candy machine has remaining (${remaining})`);\r\n  }\r\n  if (!candyMachine.authority.equals(walletKey)) {\r\n    throw new Error(`Candy machine authority does not match wallet public key`);\r\n  }\r\n\r\n  return {\r\n    total: total,\r\n    config: configKey,\r\n    uuid: candyUuid,\r\n    candyMachineKey: candyMachineKey,\r\n  };\r\n}\r\n\r\nconst getOffsetFromStart = (edition: BN) => {\r\n  return edition.mod(new BN(31 * 8));\r\n};\r\n\r\nconst getIndex = (offsetFromStart: BN) => {\r\n  return offsetFromStart.div(new BN(8));\r\n};\r\n\r\nconst getOffsetFromRight = (offsetFromStart: BN) => {\r\n  return new BN(7).sub(offsetFromStart.mod(new BN(8)));\r\n};\r\n\r\nconst getIndexAndMask = (edition: BN) => {\r\n  const offsetFromStart = getOffsetFromStart(edition);\r\n  return {\r\n    index: getIndex(offsetFromStart).toNumber(),\r\n    mask: new BN(1).shln(getOffsetFromRight(offsetFromStart).toNumber()).toNumber(),\r\n  };\r\n};\r\n\r\nconst editionTaken = (marker : Array<number>, edition : BN) : boolean => {\r\n  const m = getIndexAndMask(edition);\r\n  return (marker[m.index] & m.mask) !== 0;\r\n}\r\n\r\nconst setEditionTaken = (marker : Array<number>, edition : BN) => {\r\n  const m = getIndexAndMask(edition);\r\n  marker[m.index] = marker[m.index] | m.mask;\r\n}\r\n\r\nexport const validateEditionClaims = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  claimants : Claimants,\r\n  masterMintStr : string,\r\n) : Promise<ClaimInfo> => {\r\n  claimants.forEach((c, idx) => {\r\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\r\n    if (c.amount !== 1) {\r\n      throw new Error(`Claimant ${idx} has amount ${c.amount}. Expected 1 for edition gumdrop`);\r\n    }\r\n  });\r\n\r\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\r\n  const masterMint = await getMintInfo(connection, masterMintStr);\r\n  const masterTokenAccount = await getCreatorTokenAccount(\r\n    walletKey,\r\n    connection,\r\n    masterMint.key,\r\n    1 // just check that the creator has the master mint\r\n  );\r\n\r\n  const masterEditionKey = await getEdition(masterMint.key);\r\n  const masterEdition = await connection.getAccountInfo(masterEditionKey);\r\n  if (masterEdition === null) {\r\n    throw new Error(`Could not fetch master edition`);\r\n  }\r\n  console.log(\"Master edition\", masterEdition);\r\n\r\n  // maxSupply is an option, 9 bytes, first is 0 means is none\r\n  const currentSupply = new BN(masterEdition.data.slice(1, 1+8), 8, \"le\").toNumber();\r\n  let maxSupply;\r\n  if (masterEdition.data[9] === 0) {\r\n      maxSupply = null;\r\n  } else {\r\n      maxSupply = new BN(masterEdition.data.slice(10, 10+8), 8, \"le\").toNumber();\r\n  }\r\n  console.log(\"Max supply\", maxSupply);\r\n  console.log(\"Current supply\", currentSupply);\r\n\r\n  if (maxSupply !== null && maxSupply < total) {\r\n    throw new Error(`Distributor is allocated more editions (${total}) `\r\n                  + `than the master has total (${maxSupply})`);\r\n  }\r\n\r\n  // Whether an edition has been claimed is a single bit in a paginated account\r\n  // (pda off of master mint). The following code does some sanity checks\r\n  // around max supply and internally whether the distribution list has\r\n  // duplicate editions, and also checks if the editions were already taken on\r\n  // chain.\r\n  //\r\n  // There is a race condition since the authority to mint is still currently\r\n  // the wallet but it seems like a user error to have other editions being\r\n  // minted while a gumdrop is being created\r\n  const editions : { [key: number]: number } = {};\r\n  const editionMarkers : Array<[PublicKey, Array<number>]> = [];\r\n  for (let idx = 0; idx < claimants.length; ++idx ) {\r\n    const c = claimants[idx];\r\n    if (c.edition === undefined) throw new Error(`Claimant ${idx} doesn't have edition`);\r\n    if (c.edition <= 0) {\r\n      throw new Error(`Claimant ${idx} assigned invalid edition ${c.edition}`);\r\n    }\r\n    if (maxSupply !== null && c.edition > maxSupply) {\r\n      throw new Error(`Claimant ${idx} assigned edition ${c.edition} which is beyond the max supply`);\r\n    }\r\n    if (c.edition in editions) {\r\n      throw new Error(`Claimant ${idx} and ${editions[c.edition]} are both assigned to edition ${c.edition}`);\r\n    }\r\n    const edition = new BN(c.edition);\r\n    const markerKey = await getEditionMarkerPda(masterMint.key, edition);\r\n    let markerData = editionMarkers.find(pm => pm[0].equals(markerKey));\r\n    if (markerData === undefined) {\r\n      const markerAcc = await connection.getAccountInfo(markerKey);\r\n      if (markerAcc === null) {\r\n        editionMarkers.push([markerKey, Array<number>(31)]);\r\n      } else {\r\n        editionMarkers.push([markerKey, [...markerAcc.data.slice(1, 32)]]);\r\n      }\r\n      markerData = editionMarkers[editionMarkers.length - 1];\r\n    }\r\n\r\n    if (markerData === undefined) {\r\n      throw new Error(`Internal Error: Edition marker info still undefined ${c.edition}`);\r\n    }\r\n\r\n    if (editionTaken(markerData[1], edition)) {\r\n      throw new Error(`Claimant ${idx} is assigned to edition ${c.edition} which is already taken`);\r\n    }\r\n\r\n    setEditionTaken(markerData[1], edition);\r\n\r\n    editions[c.edition] = idx;\r\n  }\r\n\r\n  return {\r\n    total: total,\r\n    masterMint: masterMint,\r\n    masterTokenAccount: masterTokenAccount,\r\n  };\r\n}\r\n\r\nexport const chunk = (\r\n  arr : Buffer,\r\n  len : number,\r\n) : Array<Buffer> => {\r\n  const chunks : Array<Buffer> = [];\r\n  const n = arr.length;\r\n  let i = 0;\r\n\r\n  while (i < n) {\r\n    chunks.push(arr.slice(i, i += len));\r\n  }\r\n\r\n  return chunks;\r\n}\r\n\r\nexport const buildGumdrop = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  needsPin : boolean,\r\n  claimIntegration : string,\r\n  host : string,\r\n  baseKey : PublicKey,\r\n  temporalSigner : PublicKey,\r\n  claimants : Claimants,\r\n  claimInfo  : ClaimInfo,\r\n  extraParams : Array<string> = [],\r\n) : Promise<Array<TransactionInstruction>> => {\r\n\r\n  const leafs : Array<Buffer> = [];\r\n  for (let idx = 0; idx < claimants.length; ++idx ) {\r\n    const claimant = claimants[idx];\r\n    if (!needsPin) {\r\n      try {\r\n        claimant.secret = new PublicKey(claimant.handle);\r\n      } catch (err) {\r\n        throw new Error(`Invalid claimant wallet handle ${err}`);\r\n      }\r\n    } else {\r\n      const seeds = [\r\n        claimant.seed.toBuffer(),\r\n        ...chunk(Buffer.from(claimant.handle), 32),\r\n        Buffer.from(claimant.pin.toArray(\"le\", 4)),\r\n      ];\r\n      const [claimantPda, ] = await PublicKey.findProgramAddress(\r\n          seeds.map(s => s.slice(0, 32)), GUMDROP_DISTRIBUTOR_ID);\r\n      claimant.secret = claimantPda;\r\n    }\r\n    // TODO: get this clarified with jordan... we can either just assign some\r\n    // range of editions to a user or give them an amount and just keep a\r\n    // counter on the distributor... the latter is much less work but we lose\r\n    // the ability to use gumdrop for auction house winnings and such?\r\n    const extra = claimIntegration === \"edition\"\r\n      ? [...new BN(claimant.edition).toArray(\"le\", 8)]\r\n      : []\r\n    leafs.push(Buffer.from(\r\n      [...new BN(idx).toArray(\"le\", 8),\r\n       ...claimant.secret.toBuffer(),\r\n       ...claimant.seed.toBuffer(),\r\n       ...new BN(claimant.amount).toArray(\"le\", 8),\r\n       ...extra\r\n      ]\r\n    ));\r\n  }\r\n\r\n  const tree = new MerkleTree(leafs);\r\n  const root = tree.getRoot();\r\n\r\n  const [distributor, dbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"MerkleDistributor\"),\r\n      baseKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID);\r\n\r\n  for (let idx = 0; idx < claimants.length; ++idx) {\r\n    const proof = tree.getProof(idx);\r\n    const verified = tree.verifyProof(idx, proof, root);\r\n\r\n    if (!verified) {\r\n      throw new Error(\"Gumdrop merkle tree verification failed\");\r\n    }\r\n\r\n    const claimant = claimants[idx];\r\n    const params = [\r\n      `distributor=${distributor}`,\r\n      `handle=${encodeURIComponent(claimant.handle)}`,\r\n      `amount=${claimant.amount}`,\r\n      `index=${idx}`,\r\n      `proof=${proof.map(b => bs58.encode(b))}`,\r\n      ...extraParams,\r\n    ];\r\n    if (needsPin) {\r\n      params.push(`pin=${claimant.pin.toNumber()}`);\r\n    } else {\r\n      params.push(`pin=NA`);\r\n    }\r\n    if (claimIntegration === \"transfer\") {\r\n      params.push(`tokenAcc=${claimInfo.source}`);\r\n    } else if (claimIntegration === \"candy\") {\r\n      params.push(`config=${claimInfo.config}`);\r\n      params.push(`uuid=${claimInfo.uuid}`);\r\n    } else {\r\n      params.push(`master=${claimInfo.masterMint.key}`);\r\n      params.push(`edition=${claimant.edition}`);\r\n    }\r\n    const query = params.join(\"&\");\r\n\r\n    claimant.url = `${host}/claim?${query}`;\r\n  }\r\n\r\n  // initial merkle-distributor state\r\n  const instructions = Array<TransactionInstruction>();\r\n  instructions.push(new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: baseKey                 , isSigner: true  , isWritable: false } ,\r\n          { pubkey: distributor             , isSigner: false , isWritable: true  } ,\r\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\r\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:new_distributor\")).slice(0, 8),\r\n        ...new BN(dbump).toArray(\"le\", 1),\r\n        ...root,\r\n        ...temporalSigner.toBuffer(),\r\n      ])\r\n  }));\r\n\r\n  if (claimIntegration === \"transfer\") {\r\n    instructions.push(Token.createApproveInstruction(\r\n      TOKEN_PROGRAM_ID,\r\n      claimInfo.source,\r\n      distributor,\r\n      walletKey,\r\n      [],\r\n      claimInfo.total\r\n    ));\r\n  } else if (claimIntegration === \"candy\") {\r\n    const [distributorWalletKey, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from(\"Wallet\"),\r\n        distributor.toBuffer(),\r\n      ],\r\n      GUMDROP_DISTRIBUTOR_ID\r\n    );\r\n\r\n    instructions.push(new TransactionInstruction({\r\n        programId: CANDY_MACHINE_ID,\r\n        keys: [\r\n            { pubkey: claimInfo.candyMachineKey,isSigner: false , isWritable: true  } ,\r\n            { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\r\n        ],\r\n        data: Buffer.from([\r\n          ...Buffer.from(sha256.digest(\"global:update_authority\")).slice(0, 8),\r\n          ...new BN(1).toArray(\"le\", 1),  // optional exists...\r\n          ...distributorWalletKey.toBuffer(),\r\n        ])\r\n    }));\r\n  } else if (claimIntegration === \"edition\") {\r\n    // transfer master edition to distributor\r\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        distributor.toBuffer(),\r\n        TOKEN_PROGRAM_ID.toBuffer(),\r\n        claimInfo.masterMint.key.toBuffer(),\r\n      ],\r\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n    );\r\n\r\n    instructions.push(Token.createAssociatedTokenAccountInstruction(\r\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n        TOKEN_PROGRAM_ID,\r\n        claimInfo.masterMint.key,\r\n        distributorTokenKey,\r\n        distributor,\r\n        walletKey,\r\n      ));\r\n\r\n    instructions.push(Token.createTransferInstruction(\r\n        TOKEN_PROGRAM_ID,\r\n        claimInfo.masterTokenAccount,\r\n        distributorTokenKey,\r\n        walletKey,\r\n        [],\r\n        1\r\n      ));\r\n  }\r\n\r\n  return instructions;\r\n}\r\n\r\nexport const closeGumdrop = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  base : Keypair,\r\n  claimMethod : string,\r\n  transferMint : string,\r\n  candyConfig : string,\r\n  candyUuid : string,\r\n  masterMint : string,\r\n) : Promise<Array<TransactionInstruction>> => {\r\n  const [distributorKey, dbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"MerkleDistributor\"),\r\n      base.publicKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID);\r\n\r\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"Wallet\"),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  let extraKeys : Array<AccountMeta>;\r\n  const instructions = Array<TransactionInstruction>();\r\n\r\n  if (claimMethod === \"transfer\") {\r\n    const mint = await getMintInfo(connection, transferMint);\r\n    const source = await getCreatorTokenAccount(\r\n      walletKey, connection, mint.key, 0\r\n    );\r\n    // distributor is about to be closed anyway so this is redundant but...\r\n    instructions.push(Token.createRevokeInstruction(\r\n      TOKEN_PROGRAM_ID,\r\n      source,\r\n      walletKey,\r\n      [],\r\n    ));\r\n  }\r\n\r\n  if (claimMethod === \"candy\") {\r\n    const configKey = await getCandyConfig(connection, candyConfig);\r\n    const [candyMachineKey, ] = await getCandyMachineAddress(\r\n      configKey, candyUuid);\r\n\r\n   extraKeys = [\r\n          { pubkey: candyMachineKey         , isSigner: false , isWritable: true  } ,\r\n          { pubkey: CANDY_MACHINE_ID        , isSigner: false , isWritable: false } ,\r\n    ];\r\n  } else {\r\n    extraKeys = [];\r\n  }\r\n\r\n  if (claimMethod === \"edition\") {\r\n    let masterMintKey: PublicKey;\r\n    try {\r\n      masterMintKey = new PublicKey(masterMint);\r\n    } catch (err) {\r\n      throw new Error(`Invalid mint key ${err}`);\r\n    }\r\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        distributorKey.toBuffer(),\r\n        TOKEN_PROGRAM_ID.toBuffer(),\r\n        masterMintKey.toBuffer(),\r\n      ],\r\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n    );\r\n\r\n    const [walletTokenKey, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        walletKey.toBuffer(),\r\n        TOKEN_PROGRAM_ID.toBuffer(),\r\n        masterMintKey.toBuffer(),\r\n      ],\r\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n    );\r\n\r\n    instructions.push(new TransactionInstruction({\r\n        programId: GUMDROP_DISTRIBUTOR_ID,\r\n        keys: [\r\n            { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\r\n            { pubkey: distributorKey          , isSigner: false , isWritable: false } ,\r\n            { pubkey: distributorTokenKey     , isSigner: false , isWritable: true  } ,\r\n            { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\r\n            { pubkey: walletKey               , isSigner: false , isWritable: true  } ,\r\n            { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\r\n            { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\r\n        ],\r\n        data: Buffer.from([\r\n          ...Buffer.from(sha256.digest(\"global:close_distributor_token_account\")).slice(0, 8),\r\n          ...new BN(dbump).toArray(\"le\", 1),\r\n        ])\r\n    }));\r\n  }\r\n\r\n  instructions.push(new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\r\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\r\n          { pubkey: distributorWalletKey    , isSigner: false , isWritable: true  } ,\r\n          { pubkey: walletKey               , isSigner: true  , isWritable: true  } ,\r\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\r\n          ...extraKeys,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:close_distributor\")).slice(0, 8),\r\n        ...new BN(dbump).toArray(\"le\", 1),\r\n        ...new BN(wbump).toArray(\"le\", 1),\r\n      ])\r\n  }));\r\n\r\n  return instructions;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}