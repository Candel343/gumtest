{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribeAccountsChange = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst loadAccounts_1 = require(\"./loadAccounts\");\n\nconst onChangeAccount_1 = require(\"./onChangeAccount\");\n\nconst processAuctions_1 = require(\"./processAuctions\");\n\nconst processMetaData_1 = require(\"./processMetaData\");\n\nconst processMetaplexAccounts_1 = require(\"./processMetaplexAccounts\");\n\nconst processVaultData_1 = require(\"./processVaultData\");\n\nconst subscribeAccountsChange = (connection, getState, setState) => {\n  const subscriptions = [];\n\n  const updateStateValue = (prop, key, value) => {\n    const state = getState();\n    const nextState = loadAccounts_1.makeSetter({ ...state\n    })(prop, key, value);\n    setState(nextState);\n  };\n\n  subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.VAULT_ID), onChangeAccount_1.onChangeAccount(processVaultData_1.processVaultData, updateStateValue)));\n  subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.AUCTION_ID), onChangeAccount_1.onChangeAccount(processAuctions_1.processAuctions, updateStateValue)));\n  subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.METAPLEX_ID), onChangeAccount_1.onChangeAccount(processMetaplexAccounts_1.processMetaplexAccounts, updateStateValue)));\n  subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.METADATA_PROGRAM_ID), onChangeAccount_1.onChangeAccount(processMetaData_1.processMetaData, async (prop, key, value) => {\n    const state = { ...getState()\n    };\n    const setter = loadAccounts_1.makeSetter(state);\n    let hasChanges = false;\n\n    const updater = (...args) => {\n      hasChanges = true;\n      setter(...args);\n    };\n\n    if (prop === 'metadataByMint') {\n      await loadAccounts_1.initMetadata(value, state.whitelistedCreatorsByCreator, updater);\n    } else {\n      updater(prop, key, value);\n    }\n\n    if (hasChanges) {\n      setState(state);\n    }\n  })));\n  return () => {\n    subscriptions.forEach(subscriptionId => {\n      connection.removeProgramAccountChangeListener(subscriptionId);\n    });\n  };\n};\n\nexports.subscribeAccountsChange = subscribeAccountsChange;","map":{"version":3,"sources":["../../../../src/contexts/meta/subscribeAccountsChange.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAOA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,yBAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AACA,MAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAGO,MAAM,uBAAuB,GAAG,CACrC,UADqC,EAErC,QAFqC,EAGrC,QAHqC,KAInC;AACF,QAAM,aAAa,GAAa,EAAhC;;AAEA,QAAM,gBAAgB,GAAyB,CAAC,IAAD,EAAO,GAAP,EAAY,KAAZ,KAAqB;AAClE,UAAM,KAAK,GAAG,QAAQ,EAAtB;AACA,UAAM,SAAS,GAAG,cAAA,CAAA,UAAA,CAAW,EAAE,GAAG;AAAL,KAAX,EAAyB,IAAzB,EAA+B,GAA/B,EAAoC,KAApC,CAAlB;AACA,IAAA,QAAQ,CAAC,SAAD,CAAR;AACD,GAJD;;AAMA,EAAA,aAAa,CAAC,IAAd,CACE,UAAU,CAAC,sBAAX,CACE,OAAA,CAAA,WAAA,CAAY,OAAA,CAAA,QAAZ,CADF,EAEE,iBAAA,CAAA,eAAA,CAAgB,kBAAA,CAAA,gBAAhB,EAAkC,gBAAlC,CAFF,CADF;AAOA,EAAA,aAAa,CAAC,IAAd,CACE,UAAU,CAAC,sBAAX,CACE,OAAA,CAAA,WAAA,CAAY,OAAA,CAAA,UAAZ,CADF,EAEE,iBAAA,CAAA,eAAA,CAAgB,iBAAA,CAAA,eAAhB,EAAiC,gBAAjC,CAFF,CADF;AAOA,EAAA,aAAa,CAAC,IAAd,CACE,UAAU,CAAC,sBAAX,CACE,OAAA,CAAA,WAAA,CAAY,OAAA,CAAA,WAAZ,CADF,EAEE,iBAAA,CAAA,eAAA,CAAgB,yBAAA,CAAA,uBAAhB,EAAyC,gBAAzC,CAFF,CADF;AAOA,EAAA,aAAa,CAAC,IAAd,CACE,UAAU,CAAC,sBAAX,CACE,OAAA,CAAA,WAAA,CAAY,OAAA,CAAA,mBAAZ,CADF,EAEE,iBAAA,CAAA,eAAA,CAAgB,iBAAA,CAAA,eAAhB,EAAiC,OAAO,IAAP,EAAa,GAAb,EAAkB,KAAlB,KAA2B;AAC1D,UAAM,KAAK,GAAG,EAAE,GAAG,QAAQ;AAAb,KAAd;AACA,UAAM,MAAM,GAAG,cAAA,CAAA,UAAA,CAAW,KAAX,CAAf;AACA,QAAI,UAAU,GAAG,KAAjB;;AACA,UAAM,OAAO,GAAyB,CAAC,GAAG,IAAJ,KAAY;AAChD,MAAA,UAAU,GAAG,IAAb;AACA,MAAA,MAAM,CAAC,GAAG,IAAJ,CAAN;AACD,KAHD;;AAKA,QAAI,IAAI,KAAK,gBAAb,EAA+B;AAC7B,YAAM,cAAA,CAAA,YAAA,CACJ,KADI,EAEJ,KAAK,CAAC,4BAFF,EAGJ,OAHI,CAAN;AAKD,KAND,MAMO;AACL,MAAA,OAAO,CAAC,IAAD,EAAO,GAAP,EAAY,KAAZ,CAAP;AACD;;AACD,QAAI,UAAJ,EAAgB;AACd,MAAA,QAAQ,CAAC,KAAD,CAAR;AACD;AACF,GArBD,CAFF,CADF;AA4BA,SAAO,MAAK;AACV,IAAA,aAAa,CAAC,OAAd,CAAsB,cAAc,IAAG;AACrC,MAAA,UAAU,CAAC,kCAAX,CAA8C,cAA9C;AACD,KAFD;AAGD,GAJD;AAKD,CAnEM;;AAAM,OAAA,CAAA,uBAAA,GAAuB,uBAAvB","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.subscribeAccountsChange = void 0;\r\nconst utils_1 = require(\"../../utils\");\r\nconst loadAccounts_1 = require(\"./loadAccounts\");\r\nconst onChangeAccount_1 = require(\"./onChangeAccount\");\r\nconst processAuctions_1 = require(\"./processAuctions\");\r\nconst processMetaData_1 = require(\"./processMetaData\");\r\nconst processMetaplexAccounts_1 = require(\"./processMetaplexAccounts\");\r\nconst processVaultData_1 = require(\"./processVaultData\");\r\nconst subscribeAccountsChange = (connection, getState, setState) => {\r\n    const subscriptions = [];\r\n    const updateStateValue = (prop, key, value) => {\r\n        const state = getState();\r\n        const nextState = loadAccounts_1.makeSetter({ ...state })(prop, key, value);\r\n        setState(nextState);\r\n    };\r\n    subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.VAULT_ID), onChangeAccount_1.onChangeAccount(processVaultData_1.processVaultData, updateStateValue)));\r\n    subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.AUCTION_ID), onChangeAccount_1.onChangeAccount(processAuctions_1.processAuctions, updateStateValue)));\r\n    subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.METAPLEX_ID), onChangeAccount_1.onChangeAccount(processMetaplexAccounts_1.processMetaplexAccounts, updateStateValue)));\r\n    subscriptions.push(connection.onProgramAccountChange(utils_1.toPublicKey(utils_1.METADATA_PROGRAM_ID), onChangeAccount_1.onChangeAccount(processMetaData_1.processMetaData, async (prop, key, value) => {\r\n        const state = { ...getState() };\r\n        const setter = loadAccounts_1.makeSetter(state);\r\n        let hasChanges = false;\r\n        const updater = (...args) => {\r\n            hasChanges = true;\r\n            setter(...args);\r\n        };\r\n        if (prop === 'metadataByMint') {\r\n            await loadAccounts_1.initMetadata(value, state.whitelistedCreatorsByCreator, updater);\r\n        }\r\n        else {\r\n            updater(prop, key, value);\r\n        }\r\n        if (hasChanges) {\r\n            setState(state);\r\n        }\r\n    })));\r\n    return () => {\r\n        subscriptions.forEach(subscriptionId => {\r\n            connection.removeProgramAccountChangeListener(subscriptionId);\r\n        });\r\n    };\r\n};\r\nexports.subscribeAccountsChange = subscribeAccountsChange;\r\n//# sourceMappingURL=subscribeAccountsChange.js.map"]},"metadata":{},"sourceType":"script"}