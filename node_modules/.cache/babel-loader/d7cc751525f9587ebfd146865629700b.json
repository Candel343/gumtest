{"ast":null,"code":"import * as anchor from '@project-serum/anchor';\nimport { PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintLayout, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport BN from 'bn.js';\nimport { CANDY_MACHINE_ID, SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_METADATA_PROGRAM_ID } from \"./ids\";\nexport const getMintInfo = async (connection, mint) => {\n  let mintKey;\n\n  try {\n    mintKey = new PublicKey(mint);\n  } catch (err) {\n    throw new Error(`Invalid mint key ${err}`);\n  }\n\n  const mintAccount = await connection.getAccountInfo(mintKey);\n\n  if (mintAccount === null) {\n    throw new Error(`Could not fetch mint`);\n  }\n\n  if (!mintAccount.owner.equals(TOKEN_PROGRAM_ID)) {\n    const mintOwner = mintAccount.owner.toBase58();\n    throw new Error(`Invalid mint owner ${mintOwner}`);\n  }\n\n  if (mintAccount.data.length !== MintLayout.span) {\n    throw new Error(`Invalid mint size ${mintAccount.data.length}`);\n  }\n\n  const mintInfo = MintLayout.decode(Buffer.from(mintAccount.data));\n  return {\n    key: mintKey,\n    info: mintInfo\n  };\n};\nexport const getCreatorTokenAccount = async (walletKey, connection, mintKey, totalClaim) => {\n  const [creatorTokenKey] = await PublicKey.findProgramAddress([walletKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintKey.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n  const creatorTokenAccount = await connection.getAccountInfo(creatorTokenKey);\n\n  if (creatorTokenAccount === null) {\n    throw new Error(`Could not fetch creator token account`);\n  }\n\n  if (creatorTokenAccount.data.length !== AccountLayout.span) {\n    throw new Error(`Invalid token account size ${creatorTokenAccount.data.length}`);\n  }\n\n  const creatorTokenInfo = AccountLayout.decode(Buffer.from(creatorTokenAccount.data));\n\n  if (new BN(creatorTokenInfo.amount, 8, \"le\").toNumber() < totalClaim) {\n    throw new Error(`Creator token account does not have enough tokens`);\n  }\n\n  return creatorTokenKey;\n};\nexport const fetchCoder = async (address, connection) => {\n  return new anchor.Coder(await anchor.Program.fetchIdl(address, {\n    connection: connection\n  }));\n};\nexport const getCandyConfig = async (connection, config) => {\n  let configKey;\n\n  try {\n    configKey = new PublicKey(config);\n  } catch (err) {\n    throw new Error(`Invalid config key ${err}`);\n  }\n\n  const configAccount = await connection.getAccountInfo(configKey);\n\n  if (configAccount === null) {\n    throw new Error(`Could not fetch config`);\n  }\n\n  if (!configAccount.owner.equals(CANDY_MACHINE_ID)) {\n    throw new Error(`Invalid config owner ${configAccount.owner.toBase58()}`);\n  }\n\n  return configKey;\n};\nexport const getCandyMachineAddress = async (config, uuid) => {\n  return await PublicKey.findProgramAddress([Buffer.from(\"candy_machine\"), config.toBuffer(), Buffer.from(uuid)], CANDY_MACHINE_ID);\n};\nexport const getCandyMachine = async (connection, candyMachineKey) => {\n  const candyMachineCoder = await fetchCoder(CANDY_MACHINE_ID, connection);\n\n  if (candyMachineCoder === null) {\n    throw new Error(`Could not fetch candy machine IDL`);\n  }\n\n  const candyMachineAccount = await connection.getAccountInfo(candyMachineKey);\n\n  if (candyMachineAccount === null) {\n    throw new Error(`Could not fetch candy machine`);\n  }\n\n  return candyMachineCoder.accounts.decode(\"CandyMachine\", candyMachineAccount.data);\n};\nexport const getMetadata = async mint => {\n  return (await PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()], TOKEN_METADATA_PROGRAM_ID))[0];\n};\nexport const getEdition = async mint => {\n  return (await PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer(), Buffer.from('edition')], TOKEN_METADATA_PROGRAM_ID))[0];\n};\nexport const getEditionMarkerPda = async (mint, edition) => {\n  // editions are divided into pages of 31-bytes (248-bits) for more efficient\n  // packing to check if an edition is occupied. The offset is determined from\n  // the edition passed in through data\n  const editionPageNumber = edition.div(new BN(248)).toNumber();\n  return (await PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer(), Buffer.from('edition'), Buffer.from(String(editionPageNumber))], TOKEN_METADATA_PROGRAM_ID))[0];\n};","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/utils/accounts.ts"],"names":["anchor","PublicKey","AccountLayout","MintLayout","TOKEN_PROGRAM_ID","BN","CANDY_MACHINE_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_METADATA_PROGRAM_ID","getMintInfo","connection","mint","mintKey","err","Error","mintAccount","getAccountInfo","owner","equals","mintOwner","toBase58","data","length","span","mintInfo","decode","Buffer","from","key","info","getCreatorTokenAccount","walletKey","totalClaim","creatorTokenKey","findProgramAddress","toBuffer","creatorTokenAccount","creatorTokenInfo","amount","toNumber","fetchCoder","address","Coder","Program","fetchIdl","getCandyConfig","config","configKey","configAccount","getCandyMachineAddress","uuid","getCandyMachine","candyMachineKey","candyMachineCoder","candyMachineAccount","accounts","getMetadata","getEdition","getEditionMarkerPda","edition","editionPageNumber","div","String"],"mappings":"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","sourcesContent":["import * as anchor from '@project-serum/anchor';\r\nimport { Connection, PublicKey } from '@solana/web3.js';\r\nimport {\r\n  AccountLayout,\r\n  MintInfo,\r\n  MintLayout,\r\n  TOKEN_PROGRAM_ID,\r\n} from \"@solana/spl-token\";\r\nimport BN from 'bn.js';\r\n\r\nimport {\r\n  CANDY_MACHINE_ID,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n} from \"./ids\";\r\n\r\nexport const getMintInfo = async (\r\n  connection : Connection,\r\n  mint : string\r\n) : Promise<{ key: PublicKey, info: MintInfo }> => {\r\n  let mintKey : PublicKey;\r\n  try {\r\n    mintKey = new PublicKey(mint);\r\n  } catch (err) {\r\n    throw new Error(`Invalid mint key ${err}`);\r\n  }\r\n  const mintAccount = await connection.getAccountInfo(mintKey);\r\n  if (mintAccount === null) {\r\n    throw new Error(`Could not fetch mint`);\r\n  }\r\n  if (!mintAccount.owner.equals(TOKEN_PROGRAM_ID)) {\r\n    const mintOwner = mintAccount.owner.toBase58();\r\n    throw new Error(`Invalid mint owner ${mintOwner}`);\r\n  }\r\n  if (mintAccount.data.length !== MintLayout.span) {\r\n    throw new Error(`Invalid mint size ${mintAccount.data.length}`);\r\n  }\r\n  const mintInfo = MintLayout.decode(Buffer.from(mintAccount.data));\r\n  return {\r\n    key: mintKey,\r\n    info: mintInfo,\r\n  };\r\n};\r\n\r\nexport const getCreatorTokenAccount = async (\r\n  walletKey : PublicKey,\r\n  connection : Connection,\r\n  mintKey : PublicKey,\r\n  totalClaim : number,\r\n) => {\r\n  const [creatorTokenKey, ] = await PublicKey.findProgramAddress(\r\n    [\r\n      walletKey.toBuffer(),\r\n      TOKEN_PROGRAM_ID.toBuffer(),\r\n      mintKey.toBuffer(),\r\n    ],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n  );\r\n  const creatorTokenAccount = await connection.getAccountInfo(creatorTokenKey);\r\n  if (creatorTokenAccount === null) {\r\n    throw new Error(`Could not fetch creator token account`);\r\n  }\r\n  if (creatorTokenAccount.data.length !== AccountLayout.span) {\r\n    throw new Error(`Invalid token account size ${creatorTokenAccount.data.length}`);\r\n  }\r\n  const creatorTokenInfo = AccountLayout.decode(Buffer.from(creatorTokenAccount.data));\r\n  if (new BN(creatorTokenInfo.amount, 8, \"le\").toNumber() < totalClaim) {\r\n    throw new Error(`Creator token account does not have enough tokens`);\r\n  }\r\n  return creatorTokenKey;\r\n};\r\n\r\nexport const fetchCoder = async (\r\n  address : anchor.Address,\r\n  connection : Connection,\r\n) : Promise<anchor.Coder | null> => {\r\n  return new anchor.Coder(await anchor.Program.fetchIdl(\r\n      address, { connection: connection } as anchor.Provider));\r\n}\r\n\r\nexport const getCandyConfig = async (\r\n  connection : Connection,\r\n  config : string\r\n) : Promise<PublicKey> => {\r\n  let configKey : PublicKey;\r\n  try {\r\n    configKey = new PublicKey(config);\r\n  } catch (err) {\r\n    throw new Error(`Invalid config key ${err}`);\r\n  }\r\n  const configAccount = await connection.getAccountInfo(configKey);\r\n  if (configAccount === null) {\r\n    throw new Error(`Could not fetch config`);\r\n  }\r\n  if (!configAccount.owner.equals(CANDY_MACHINE_ID)) {\r\n    throw new Error(`Invalid config owner ${configAccount.owner.toBase58()}`);\r\n  }\r\n  return configKey;\r\n};\r\n\r\nexport const getCandyMachineAddress = async (\r\n  config: PublicKey,\r\n  uuid: string,\r\n) => {\r\n  return await PublicKey.findProgramAddress(\r\n    [Buffer.from(\"candy_machine\"), config.toBuffer(), Buffer.from(uuid)],\r\n    CANDY_MACHINE_ID,\r\n  );\r\n};\r\n\r\nexport const getCandyMachine = async (\r\n  connection : Connection,\r\n  candyMachineKey : PublicKey,\r\n) => {\r\n  const candyMachineCoder = await fetchCoder(CANDY_MACHINE_ID, connection);\r\n  if (candyMachineCoder === null) {\r\n    throw new Error(`Could not fetch candy machine IDL`);\r\n  }\r\n  const candyMachineAccount = await connection.getAccountInfo(candyMachineKey);\r\n  if (candyMachineAccount === null) {\r\n    throw new Error(`Could not fetch candy machine`);\r\n  }\r\n  return candyMachineCoder.accounts.decode(\r\n      \"CandyMachine\", candyMachineAccount.data);\r\n}\r\n\r\nexport const getMetadata = async (\r\n  mint: PublicKey,\r\n): Promise<PublicKey> => {\r\n  return (\r\n    await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from('metadata'),\r\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n        mint.toBuffer(),\r\n      ],\r\n      TOKEN_METADATA_PROGRAM_ID,\r\n    )\r\n  )[0];\r\n};\r\n\r\nexport const getEdition = async (\r\n  mint: PublicKey,\r\n): Promise<PublicKey> => {\r\n  return (\r\n    await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from('metadata'),\r\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n        mint.toBuffer(),\r\n        Buffer.from('edition'),\r\n      ],\r\n      TOKEN_METADATA_PROGRAM_ID,\r\n    )\r\n  )[0];\r\n};\r\n\r\nexport const getEditionMarkerPda = async (\r\n  mint: PublicKey,\r\n  edition: BN,\r\n) : Promise<PublicKey> => {\r\n  // editions are divided into pages of 31-bytes (248-bits) for more efficient\r\n  // packing to check if an edition is occupied. The offset is determined from\r\n  // the edition passed in through data\r\n  const editionPageNumber = edition.div(new BN(248)).toNumber();\r\n\r\n  return (\r\n    await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from('metadata'),\r\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n        mint.toBuffer(),\r\n        Buffer.from('edition'),\r\n        Buffer.from(String(editionPageNumber)),\r\n      ],\r\n      TOKEN_METADATA_PROGRAM_ID,\r\n    )\r\n  )[0];\r\n}\r\n"]},"metadata":{},"sourceType":"module"}