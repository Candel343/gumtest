{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Diego\\\\metaplex\\\\js\\\\packages\\\\gumdrop\\\\src\\\\contexts\\\\ConnectionContext.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { useLocalStorageState } from \"@oyster/common\";\nimport { Keypair, Connection, Transaction } from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { sendSignedTransaction } from \"../utils/transactions\";\nimport { TokenListProvider, ENV as ChainId } from \"@solana/spl-token-registry\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ENDPOINTS = [{\n  name: \"mainnet-beta\",\n  endpoint: \"https://api.mainnet-beta.solana.com\",\n  ChainId: ChainId.MainnetBeta\n}, {\n  name: \"devnet\",\n  endpoint: \"https://api.devnet.solana.com\",\n  ChainId: ChainId.Devnet\n}];\nconst DEFAULT = ENDPOINTS[0].endpoint;\nconst ConnectionContext = /*#__PURE__*/React.createContext({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map()\n});\nexport function ConnectionProvider({\n  children = undefined\n}) {\n  _s();\n\n  var _ENDPOINTS$find;\n\n  const [endpoint, setEndpoint] = useLocalStorageState(\"connectionEndpoint\", ENDPOINTS[0].endpoint);\n  const connection = useMemo(() => new Connection(endpoint, \"recent\"), [endpoint]);\n  const env = ((_ENDPOINTS$find = ENDPOINTS.find(end => end.endpoint === endpoint)) === null || _ENDPOINTS$find === void 0 ? void 0 : _ENDPOINTS$find.name) || ENDPOINTS[0].name;\n  const [tokens, setTokens] = useState([]);\n  const [tokenMap, setTokenMap] = useState(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then(container => {\n      var _ENDPOINTS$find2;\n\n      const list = container.excludeByTag(\"nft\").filterByChainId(((_ENDPOINTS$find2 = ENDPOINTS.find(end => end.endpoint === endpoint)) === null || _ENDPOINTS$find2 === void 0 ? void 0 : _ENDPOINTS$find2.ChainId) || ChainId.MainnetBeta).getList();\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map());\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]); // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n\n  useEffect(() => {\n    const id = connection.onAccountChange(Keypair.generate().publicKey, () => {});\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n  return /*#__PURE__*/_jsxDEV(ConnectionContext.Provider, {\n    value: {\n      endpoint,\n      setEndpoint,\n      connection,\n      tokens,\n      tokenMap,\n      env\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 122,\n    columnNumber: 5\n  }, this);\n}\n\n_s(ConnectionProvider, \"w+AC22Fs6Cwfhhyz0TThZPSukOI=\", false, function () {\n  return [useLocalStorageState];\n});\n\n_c = ConnectionProvider;\nexport function useConnection() {\n  _s2();\n\n  return useContext(ConnectionContext).connection;\n}\n\n_s2(useConnection, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nexport function useConnectionConfig() {\n  _s3();\n\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap\n  };\n}\n\n_s3(useConnectionConfig, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nexport const getErrorForTransaction = async (connection, txid) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n  const errors = [];\n\n  if ((tx === null || tx === void 0 ? void 0 : tx.meta) && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\nexport let SequenceType;\n\n(function (SequenceType) {\n  SequenceType[SequenceType[\"Sequential\"] = 0] = \"Sequential\";\n  SequenceType[SequenceType[\"Parallel\"] = 1] = \"Parallel\";\n  SequenceType[SequenceType[\"StopOnFailure\"] = 2] = \"StopOnFailure\";\n})(SequenceType || (SequenceType = {}));\n\nexport const sendTransactionWithRetry = async (connection, wallet, instructions, signers, commitment = \"singleGossip\", includesFeePayer = false, block, beforeSend) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return \"Failed to sign transaction\";\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  console.log(\"About to send\");\n\n  try {\n    const {\n      txid,\n      slot\n    } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction\n    });\n    return {\n      txid,\n      slot\n    };\n  } catch (error) {\n    console.error(error);\n    return \"See console logs\";\n  }\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"ConnectionProvider\");","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/contexts/ConnectionContext.tsx"],"names":["useLocalStorageState","Keypair","Connection","Transaction","React","useContext","useEffect","useMemo","useState","sendSignedTransaction","TokenListProvider","ENV","ChainId","WalletNotConnectedError","ENDPOINTS","name","endpoint","MainnetBeta","Devnet","DEFAULT","ConnectionContext","createContext","setEndpoint","connection","env","tokens","tokenMap","Map","ConnectionProvider","children","undefined","find","end","setTokens","setTokenMap","resolve","then","container","list","excludeByTag","filterByChainId","getList","knownMints","reduce","map","item","set","address","id","onAccountChange","generate","publicKey","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","useConnection","useConnectionConfig","context","getErrorForTransaction","txid","confirmTransaction","tx","getParsedConfirmedTransaction","errors","meta","logMessages","forEach","log","regex","m","exec","index","lastIndex","length","push","SequenceType","sendTransactionWithRetry","wallet","instructions","signers","commitment","includesFeePayer","block","beforeSend","transaction","instruction","add","recentBlockhash","getRecentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","console","slot","signedTransaction","error"],"mappings":"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","sourcesContent":["import { useLocalStorageState } from \"@oyster/common\";\r\nimport {\r\n  Keypair,\r\n  Commitment,\r\n  Connection,\r\n  Transaction,\r\n  TransactionInstruction,\r\n  Blockhash,\r\n  FeeCalculator,\r\n} from \"@solana/web3.js\";\r\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\r\nimport {\r\n  sendSignedTransaction,\r\n} from \"../utils/transactions\";\r\nimport {\r\n  TokenInfo,\r\n  TokenListProvider,\r\n  ENV as ChainId,\r\n} from \"@solana/spl-token-registry\";\r\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\r\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\r\n\r\ninterface BlockhashAndFeeCalculator {\r\n  blockhash: Blockhash;\r\n  feeCalculator: FeeCalculator;\r\n}\r\n\r\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\r\n\r\nexport const ENDPOINTS = [\r\n  {\r\n    name: \"mainnet-beta\" as ENV,\r\n    endpoint: \"https://api.mainnet-beta.solana.com\",\r\n    ChainId: ChainId.MainnetBeta,\r\n  },\r\n  {\r\n    name: \"devnet\" as ENV,\r\n    endpoint: \"https://api.devnet.solana.com\",\r\n    ChainId: ChainId.Devnet,\r\n  },\r\n];\r\n\r\nconst DEFAULT = ENDPOINTS[0].endpoint;\r\n\r\ninterface ConnectionConfig {\r\n  connection: Connection;\r\n  endpoint: string;\r\n  env: ENV;\r\n  setEndpoint: (val: string) => void;\r\n  tokens: TokenInfo[];\r\n  tokenMap: Map<string, TokenInfo>;\r\n}\r\n\r\nconst ConnectionContext = React.createContext<ConnectionConfig>({\r\n  endpoint: DEFAULT,\r\n  setEndpoint: () => {},\r\n  connection: new Connection(DEFAULT, \"recent\"),\r\n  env: ENDPOINTS[0].name,\r\n  tokens: [],\r\n  tokenMap: new Map<string, TokenInfo>(),\r\n});\r\n\r\nexport function ConnectionProvider({ children = undefined } : { children : React.ReactNode }) {\r\n  const [endpoint, setEndpoint] = useLocalStorageState(\r\n    \"connectionEndpoint\",\r\n    ENDPOINTS[0].endpoint\r\n  );\r\n\r\n  const connection = useMemo(\r\n    () => new Connection(endpoint, \"recent\"),\r\n    [endpoint]\r\n  );\r\n\r\n  const env =\r\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\r\n    ENDPOINTS[0].name;\r\n\r\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\r\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\r\n  useEffect(() => {\r\n    // fetch token files\r\n    new TokenListProvider().resolve().then((container) => {\r\n      const list = container\r\n        .excludeByTag(\"nft\")\r\n        .filterByChainId(\r\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\r\n            ChainId.MainnetBeta\r\n        )\r\n        .getList();\r\n\r\n      const knownMints = [...list].reduce((map, item) => {\r\n        map.set(item.address, item);\r\n        return map;\r\n      }, new Map<string, TokenInfo>());\r\n\r\n      setTokenMap(knownMints);\r\n      setTokens(list);\r\n    });\r\n  }, [env, endpoint]);\r\n\r\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\r\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\r\n  // This is a hack to prevent the list from every getting empty\r\n  useEffect(() => {\r\n    const id = connection.onAccountChange(\r\n      Keypair.generate().publicKey,\r\n      () => {}\r\n    );\r\n    return () => {\r\n      connection.removeAccountChangeListener(id);\r\n    };\r\n  }, [connection]);\r\n\r\n  useEffect(() => {\r\n    const id = connection.onSlotChange(() => null);\r\n    return () => {\r\n      connection.removeSlotChangeListener(id);\r\n    };\r\n  }, [connection]);\r\n\r\n  return (\r\n    <ConnectionContext.Provider\r\n      value={{\r\n        endpoint,\r\n        setEndpoint,\r\n        connection,\r\n        tokens,\r\n        tokenMap,\r\n        env,\r\n      }}\r\n    >\r\n      {children}\r\n    </ConnectionContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useConnection() {\r\n  return useContext(ConnectionContext).connection as Connection;\r\n}\r\n\r\nexport function useConnectionConfig() {\r\n  const context = useContext(ConnectionContext);\r\n  return {\r\n    endpoint: context.endpoint,\r\n    setEndpoint: context.setEndpoint,\r\n    env: context.env,\r\n    tokens: context.tokens,\r\n    tokenMap: context.tokenMap,\r\n  };\r\n}\r\n\r\nexport const getErrorForTransaction = async (\r\n  connection: Connection,\r\n  txid: string\r\n) => {\r\n  // wait for all confirmation before geting transaction\r\n  await connection.confirmTransaction(txid, \"max\");\r\n\r\n  const tx = await connection.getParsedConfirmedTransaction(txid);\r\n\r\n  const errors: string[] = [];\r\n  if (tx?.meta && tx.meta.logMessages) {\r\n    tx.meta.logMessages.forEach((log) => {\r\n      const regex = /Error: (.*)/gm;\r\n      let m;\r\n      while ((m = regex.exec(log)) !== null) {\r\n        // This is necessary to avoid infinite loops with zero-width matches\r\n        if (m.index === regex.lastIndex) {\r\n          regex.lastIndex++;\r\n        }\r\n\r\n        if (m.length > 1) {\r\n          errors.push(m[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  return errors;\r\n};\r\n\r\nexport enum SequenceType {\r\n  Sequential,\r\n  Parallel,\r\n  StopOnFailure,\r\n}\r\n\r\nexport const sendTransactionWithRetry = async (\r\n  connection: Connection,\r\n  wallet: WalletSigner,\r\n  instructions: TransactionInstruction[],\r\n  signers: Keypair[],\r\n  commitment: Commitment = \"singleGossip\",\r\n  includesFeePayer: boolean = false,\r\n  block?: BlockhashAndFeeCalculator,\r\n  beforeSend?: () => void\r\n) : Promise<string| { txid: string; slot: number }> => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  let transaction = new Transaction();\r\n  instructions.forEach((instruction) => transaction.add(instruction));\r\n  transaction.recentBlockhash = (\r\n    block || (await connection.getRecentBlockhash(commitment))\r\n  ).blockhash;\r\n\r\n  if (includesFeePayer) {\r\n    transaction.setSigners(...signers.map((s) => s.publicKey));\r\n  } else {\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map((s) => s.publicKey)\r\n    );\r\n  }\r\n\r\n  if (signers.length > 0) {\r\n    transaction.partialSign(...signers);\r\n  }\r\n  if (!includesFeePayer) {\r\n    try {\r\n      transaction = await wallet.signTransaction(transaction);\r\n    } catch {\r\n      return \"Failed to sign transaction\";\r\n    }\r\n  }\r\n\r\n  if (beforeSend) {\r\n    beforeSend();\r\n  }\r\n  console.log(\"About to send\");\r\n  try {\r\n    const { txid, slot } = await sendSignedTransaction({\r\n      connection,\r\n      signedTransaction: transaction,\r\n    });\r\n\r\n    return { txid, slot };\r\n  } catch (error) {\r\n    console.error(error);\r\n    return \"See console logs\";\r\n  }\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}