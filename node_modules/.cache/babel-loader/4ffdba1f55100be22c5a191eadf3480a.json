{"ast":null,"code":"import { Transaction } from '@solana/web3.js';\nimport { sleep } from \"@oyster/common\";\nimport log from 'loglevel';\nexport const DEFAULT_TIMEOUT = 15000;\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\nexport const envFor = connection => {\n  const endpoint = connection._rpcEndpoint;\n  const regex = /https:\\/\\/api.([^.]*).solana.com/;\n  const match = endpoint.match(regex);\n\n  if (match[1]) {\n    return match[1];\n  }\n\n  return \"mainnet-beta\";\n};\nexport const explorerLinkFor = (txid, connection) => {\n  return `https://explorer.solana.com/tx/${txid}?cluster=${envFor(connection)}`;\n};\nexport const sendTransactionWithRetryWithKeypair = async (connection, wallet, instructions, signers, commitment = 'singleGossip', includesFeePayer = false, block, beforeSend) => {\n  const transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.sign(...[wallet, ...signers]);\n  } else {\n    transaction.sign(wallet);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const {\n    txid,\n    slot\n  } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction\n  });\n  return {\n    txid,\n    slot\n  };\n};\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT\n}) {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n  log.debug('Started awaiting confirmation for', txid);\n  let done = false;\n\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleep(500);\n    }\n  })();\n\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'confirmed', true);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      log.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n  } catch (err) {\n    log.error('Timeout Error caught', err);\n\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n\n    let simulateResult = null;\n\n    try {\n      simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;\n    } catch (e) {\n      log.error('Simulate Transaction error', e);\n    }\n\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n\n          if (line.startsWith('Program log: ')) {\n            throw new Error('Transaction failed: ' + line.slice('Program log: '.length));\n          }\n        }\n      }\n\n      throw new Error(JSON.stringify(simulateResult.err));\n    } // throw new Error('Transaction failed');\n\n  } finally {\n    done = true;\n  }\n\n  log.debug('Latency (ms)', txid, getUnixTs() - startTime);\n  return {\n    txid,\n    slot\n  };\n}\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = {\n    encoding: 'base64',\n    commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest('simulateTransaction', args);\n\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n\n  return res.result;\n}\n\nexport async function awaitTransactionSignatureConfirmation(txid, timeout, connection, commitment = 'recent', queryStatus = false) {\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0; // eslint-disable-next-line no-async-promise-executor\n\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      log.warn('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    try {\n      subId = connection.onSignature(txid, (result, context) => {\n        done = true;\n        status = {\n          err: result.err,\n          slot: context.slot,\n          confirmations: 0\n        };\n\n        if (result.err) {\n          log.warn('Rejected via websocket', result.err);\n          reject(status);\n        } else {\n          log.debug('Resolved via websocket', result);\n          resolve(status);\n        }\n      }, commitment);\n    } catch (e) {\n      done = true;\n      log.error('WS error in setup', txid, e);\n    }\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(explorerLinkFor(txid, connection));\n\n          if (!done) {\n            if (!status) {\n              log.debug('REST null result for', txid, status);\n            } else if (status.err) {\n              log.error('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              log.error('REST no confirmations for', txid, status);\n            } else {\n              log.debug('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            log.error('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await sleep(2000);\n    }\n  }); //@ts-ignore\n\n  if (connection._signatureSubscriptions[subId]) connection.removeSignatureListener(subId);\n  done = true;\n  log.debug('Returning status', status);\n  return status;\n}","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/utils/transactions.ts"],"names":["Transaction","sleep","log","DEFAULT_TIMEOUT","getUnixTs","Date","getTime","envFor","connection","endpoint","_rpcEndpoint","regex","match","explorerLinkFor","txid","sendTransactionWithRetryWithKeypair","wallet","instructions","signers","commitment","includesFeePayer","block","beforeSend","transaction","forEach","instruction","add","recentBlockhash","getRecentBlockhash","blockhash","setSigners","map","s","publicKey","length","sign","slot","sendSignedTransaction","signedTransaction","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","debug","done","confirmation","awaitTransactionSignatureConfirmation","Error","err","error","simulateResult","simulateTransaction","value","e","logs","i","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding","args","res","_rpcRequest","message","result","queryStatus","status","confirmations","subId","Promise","resolve","reject","setTimeout","warn","onSignature","context","signatureStatuses","getSignatureStatuses","console","_signatureSubscriptions","removeSignatureListener"],"mappings":"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","sourcesContent":["import {\r\n  Blockhash,\r\n  Commitment,\r\n  Connection,\r\n  FeeCalculator,\r\n  Keypair,\r\n  RpcResponseAndContext,\r\n  SignatureStatus,\r\n  SimulatedTransactionResponse,\r\n  Transaction,\r\n  TransactionInstruction,\r\n  TransactionSignature,\r\n} from '@solana/web3.js';\r\nimport { sleep } from \"@oyster/common\";\r\nimport log from 'loglevel';\r\n\r\ninterface BlockhashAndFeeCalculator {\r\n  blockhash: Blockhash;\r\n  feeCalculator: FeeCalculator;\r\n}\r\n\r\nexport const DEFAULT_TIMEOUT = 15000;\r\n\r\nexport const getUnixTs = () => {\r\n  return new Date().getTime() / 1000;\r\n};\r\n\r\nexport const envFor = (\r\n  connection: Connection\r\n) : string => {\r\n  const endpoint = (connection as any)._rpcEndpoint;\r\n  const regex = /https:\\/\\/api.([^.]*).solana.com/;\r\n  const match = endpoint.match(regex);\r\n  if (match[1]) {\r\n    return match[1];\r\n  }\r\n  return \"mainnet-beta\";\r\n}\r\n\r\nexport const explorerLinkFor = (\r\n  txid: TransactionSignature,\r\n  connection: Connection\r\n) : string => {\r\n  return `https://explorer.solana.com/tx/${txid}?cluster=${envFor(connection)}`;\r\n}\r\n\r\nexport const sendTransactionWithRetryWithKeypair = async (\r\n  connection: Connection,\r\n  wallet: Keypair,\r\n  instructions: TransactionInstruction[],\r\n  signers: Keypair[],\r\n  commitment: Commitment = 'singleGossip',\r\n  includesFeePayer: boolean = false,\r\n  block?: BlockhashAndFeeCalculator,\r\n  beforeSend?: () => void,\r\n) => {\r\n  const transaction = new Transaction();\r\n  instructions.forEach(instruction => transaction.add(instruction));\r\n  transaction.recentBlockhash = (\r\n    block || (await connection.getRecentBlockhash(commitment))\r\n  ).blockhash;\r\n\r\n  if (includesFeePayer) {\r\n    transaction.setSigners(...signers.map(s => s.publicKey));\r\n  } else {\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map(s => s.publicKey),\r\n    );\r\n  }\r\n\r\n  if (signers.length > 0) {\r\n    transaction.sign(...[wallet, ...signers]);\r\n  } else {\r\n    transaction.sign(wallet);\r\n  }\r\n\r\n  if (beforeSend) {\r\n    beforeSend();\r\n  }\r\n\r\n  const { txid, slot } = await sendSignedTransaction({\r\n    connection,\r\n    signedTransaction: transaction,\r\n  });\r\n\r\n  return { txid, slot };\r\n};\r\n\r\nexport async function sendSignedTransaction({\r\n  signedTransaction,\r\n  connection,\r\n  timeout = DEFAULT_TIMEOUT,\r\n}: {\r\n  signedTransaction: Transaction;\r\n  connection: Connection;\r\n  sendingMessage?: string;\r\n  sentMessage?: string;\r\n  successMessage?: string;\r\n  timeout?: number;\r\n}): Promise<{ txid: string; slot: number }> {\r\n  const rawTransaction = signedTransaction.serialize();\r\n  const startTime = getUnixTs();\r\n  let slot = 0;\r\n  const txid: TransactionSignature = await connection.sendRawTransaction(\r\n    rawTransaction,\r\n    {\r\n      skipPreflight: true,\r\n    },\r\n  );\r\n\r\n  log.debug('Started awaiting confirmation for', txid);\r\n\r\n  let done = false;\r\n  (async () => {\r\n    while (!done && getUnixTs() - startTime < timeout) {\r\n      connection.sendRawTransaction(rawTransaction, {\r\n        skipPreflight: true,\r\n      });\r\n      await sleep(500);\r\n    }\r\n  })();\r\n  try {\r\n    const confirmation = await awaitTransactionSignatureConfirmation(\r\n      txid,\r\n      timeout,\r\n      connection,\r\n      'confirmed',\r\n      true,\r\n    );\r\n\r\n    if (!confirmation)\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n\r\n    if (confirmation.err) {\r\n      log.error(confirmation.err);\r\n      throw new Error('Transaction failed: Custom instruction error');\r\n    }\r\n\r\n    slot = confirmation?.slot || 0;\r\n  } catch (err) {\r\n    log.error('Timeout Error caught', err);\r\n    if (err.timeout) {\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n    }\r\n    let simulateResult: SimulatedTransactionResponse | null = null;\r\n    try {\r\n      simulateResult = (\r\n        await simulateTransaction(connection, signedTransaction, 'single')\r\n      ).value;\r\n    } catch (e) {\r\n      log.error('Simulate Transaction error', e);\r\n    }\r\n    if (simulateResult && simulateResult.err) {\r\n      if (simulateResult.logs) {\r\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n          const line = simulateResult.logs[i];\r\n          if (line.startsWith('Program log: ')) {\r\n            throw new Error(\r\n              'Transaction failed: ' + line.slice('Program log: '.length),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      throw new Error(JSON.stringify(simulateResult.err));\r\n    }\r\n    // throw new Error('Transaction failed');\r\n  } finally {\r\n    done = true;\r\n  }\r\n\r\n  log.debug('Latency (ms)', txid, getUnixTs() - startTime);\r\n  return { txid, slot };\r\n}\r\n\r\nasync function simulateTransaction(\r\n  connection: Connection,\r\n  transaction: Transaction,\r\n  commitment: Commitment,\r\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\r\n  // @ts-ignore\r\n  transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching,\r\n  );\r\n\r\n  const signData = transaction.serializeMessage();\r\n  // @ts-ignore\r\n  const wireTransaction = transaction._serialize(signData);\r\n  const encodedTransaction = wireTransaction.toString('base64');\r\n  const config: any = { encoding: 'base64', commitment };\r\n  const args = [encodedTransaction, config];\r\n\r\n  // @ts-ignore\r\n  const res = await connection._rpcRequest('simulateTransaction', args);\r\n  if (res.error) {\r\n    throw new Error('failed to simulate transaction: ' + res.error.message);\r\n  }\r\n  return res.result;\r\n}\r\n\r\nexport async function awaitTransactionSignatureConfirmation(\r\n  txid: TransactionSignature,\r\n  timeout: number,\r\n  connection: Connection,\r\n  commitment: Commitment = 'recent',\r\n  queryStatus = false,\r\n): Promise<SignatureStatus | null | void> {\r\n  let done = false;\r\n  let status: SignatureStatus | null | void = {\r\n    slot: 0,\r\n    confirmations: 0,\r\n    err: null,\r\n  };\r\n  let subId = 0;\r\n  // eslint-disable-next-line no-async-promise-executor\r\n  status = await new Promise(async (resolve, reject) => {\r\n    setTimeout(() => {\r\n      if (done) {\r\n        return;\r\n      }\r\n      done = true;\r\n      log.warn('Rejecting for timeout...');\r\n      reject({ timeout: true });\r\n    }, timeout);\r\n    try {\r\n      subId = connection.onSignature(\r\n        txid,\r\n        (result, context) => {\r\n          done = true;\r\n          status = {\r\n            err: result.err,\r\n            slot: context.slot,\r\n            confirmations: 0,\r\n          };\r\n          if (result.err) {\r\n            log.warn('Rejected via websocket', result.err);\r\n            reject(status);\r\n          } else {\r\n            log.debug('Resolved via websocket', result);\r\n            resolve(status);\r\n          }\r\n        },\r\n        commitment,\r\n      );\r\n    } catch (e) {\r\n      done = true;\r\n      log.error('WS error in setup', txid, e);\r\n    }\r\n    while (!done && queryStatus) {\r\n      // eslint-disable-next-line no-loop-func\r\n      (async () => {\r\n        try {\r\n          const signatureStatuses = await connection.getSignatureStatuses([\r\n            txid,\r\n          ]);\r\n          status = signatureStatuses && signatureStatuses.value[0];\r\n          console.log(explorerLinkFor(txid, connection));\r\n          if (!done) {\r\n            if (!status) {\r\n              log.debug('REST null result for', txid, status);\r\n            } else if (status.err) {\r\n              log.error('REST error for', txid, status);\r\n              done = true;\r\n              reject(status.err);\r\n            } else if (!status.confirmations) {\r\n              log.error('REST no confirmations for', txid, status);\r\n            } else {\r\n              log.debug('REST confirmation for', txid, status);\r\n              done = true;\r\n              resolve(status);\r\n            }\r\n          }\r\n        } catch (e) {\r\n          if (!done) {\r\n            log.error('REST connection error: txid', txid, e);\r\n          }\r\n        }\r\n      })();\r\n      await sleep(2000);\r\n    }\r\n  });\r\n\r\n  //@ts-ignore\r\n  if (connection._signatureSubscriptions[subId])\r\n    connection.removeSignatureListener(subId);\r\n  done = true;\r\n  log.debug('Returning status', status);\r\n  return status;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}