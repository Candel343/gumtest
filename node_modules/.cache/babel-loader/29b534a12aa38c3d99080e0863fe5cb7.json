{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Diego\\\\metaplex\\\\js\\\\packages\\\\gumdrop\\\\src\\\\components\\\\Claim.tsx\",\n    _s = $RefreshSig$();\n\nimport React from \"react\";\nimport queryString from 'query-string';\nimport { Box, Button, CircularProgress, FormControl, Link as HyperLink, InputLabel, MenuItem, Select, Stack, Step, StepLabel, Stepper, TextField } from \"@mui/material\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { Keypair, PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY, SYSVAR_CLOCK_PUBKEY, Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport { AccountLayout, MintLayout, Token, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { notify } from \"@oyster/common\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\nimport { useConnection } from \"../contexts\";\nimport { CANDY_MACHINE_ID, GUMDROP_DISTRIBUTOR_ID, GUMDROP_TEMPORAL_SIGNER, SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_METADATA_PROGRAM_ID } from \"../utils/ids\";\nimport { getCandyMachine, getCandyMachineAddress, getEdition, getEditionMarkerPda, getMetadata } from \"../utils/accounts\";\nimport { MerkleTree } from \"../utils/merkleTree\";\nimport { explorerLinkFor, sendSignedTransaction } from \"../utils/transactions\";\nimport { chunk } from \"../utils/claimant\";\nimport { coder } from \"../utils/merkleDistributor\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst walletKeyOrPda = async (walletKey, handle, pin, seed) => {\n  if (pin === null) {\n    try {\n      const key = new PublicKey(handle);\n\n      if (!key.equals(walletKey)) {\n        throw new Error(\"Claimant wallet handle does not match connected wallet\");\n      }\n\n      return [key, []];\n    } catch (err) {\n      throw new Error(`Invalid claimant wallet handle ${err}`);\n    }\n  } else {\n    const seeds = [seed.toBuffer(), Buffer.from(handle), Buffer.from(pin.toArray(\"le\", 4))];\n    const [claimantPda] = await PublicKey.findProgramAddress([seeds[0], ...chunk(seeds[1], 32), seeds[2]], GUMDROP_DISTRIBUTOR_ID);\n    return [claimantPda, seeds];\n  }\n};\n\nconst buildMintClaim = async (connection, walletKey, distributorKey, distributorInfo, tokenAcc, proof, handle, amount, index, pin) => {\n  let tokenAccKey;\n\n  try {\n    tokenAccKey = new PublicKey(tokenAcc);\n  } catch (err) {\n    throw new Error(`Invalid tokenAcc key ${err}`);\n  }\n\n  const distTokenAccount = await connection.getAccountInfo(tokenAccKey);\n\n  if (distTokenAccount === null) {\n    throw new Error(`Could not fetch distributor token account`);\n  }\n\n  const tokenAccountInfo = AccountLayout.decode(distTokenAccount.data);\n  const mint = new PublicKey(tokenAccountInfo.mint);\n  console.log(mint.toBase58());\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, mint); // TODO: since it's in the PDA do we need it to be in the leaf?\n\n  const leaf = Buffer.from([...new BN(index).toArray(\"le\", 8), ...secret.toBuffer(), ...mint.toBuffer(), ...new BN(amount).toArray(\"le\", 8)]);\n  const matches = MerkleTree.verifyClaim(leaf, proof, Buffer.from(distributorInfo.root));\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimStatus, cbump] = await PublicKey.findProgramAddress([Buffer.from(\"ClaimStatus\"), Buffer.from(new BN(index).toArray(\"le\", 8)), distributorKey.toBuffer()], GUMDROP_DISTRIBUTOR_ID);\n  const [walletTokenKey] = await PublicKey.findProgramAddress([walletKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n  const setup = [];\n\n  if ((await connection.getAccountInfo(walletTokenKey)) === null) {\n    setup.push(Token.createAssociatedTokenAccountInstruction(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, walletTokenKey, walletKey, walletKey));\n  }\n\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey) ? walletKey : distributorInfo.temporal;\n  const claimAirdrop = new TransactionInstruction({\n    programId: GUMDROP_DISTRIBUTOR_ID,\n    keys: [{\n      pubkey: distributorKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: claimStatus,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: tokenAccKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: walletTokenKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: temporalSigner,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: walletKey,\n      isSigner: true,\n      isWritable: false\n    }, // payer\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }],\n    data: Buffer.from([...Buffer.from(sha256.digest(\"global:claim\")).slice(0, 8), ...new BN(cbump).toArray(\"le\", 1), ...new BN(index).toArray(\"le\", 8), ...new BN(amount).toArray(\"le\", 8), ...secret.toBuffer(), ...new BN(proof.length).toArray(\"le\", 4), ...Buffer.concat(proof)])\n  });\n  return [[...setup, claimAirdrop], pdaSeeds, []];\n};\n\nconst buildCandyClaim = async (connection, walletKey, distributorKey, distributorInfo, candyConfig, candyUUID, proof, handle, amount, index, pin) => {\n  let configKey;\n\n  try {\n    configKey = new PublicKey(candyConfig);\n  } catch (err) {\n    throw new Error(`Invalid candy config key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, configKey); // TODO: since it's in the PDA do we need it to be in the leaf?\n\n  const leaf = Buffer.from([...new BN(index).toArray(\"le\", 8), ...secret.toBuffer(), ...configKey.toBuffer(), ...new BN(amount).toArray(\"le\", 8)]);\n  const matches = MerkleTree.verifyClaim(leaf, proof, Buffer.from(distributorInfo.root));\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress([Buffer.from(\"ClaimCount\"), Buffer.from(new BN(index).toArray(\"le\", 8)), distributorKey.toBuffer()], GUMDROP_DISTRIBUTOR_ID);\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress([Buffer.from(\"Wallet\"), distributorKey.toBuffer()], GUMDROP_DISTRIBUTOR_ID); // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey) ? walletKey : distributorInfo.temporal;\n  const setup = [];\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  let nftsAlreadyMinted = 0;\n\n  if (claimCountAccount === null) {// nothing claimed yet\n  } else {\n    // TODO: subtract already minted?...\n    const claimAccountInfo = coder.accounts.decode(\"ClaimCount\", claimCountAccount.data);\n    nftsAlreadyMinted = claimAccountInfo.count;\n\n    if (claimAccountInfo.claimant.equals(walletKey)) {\n      // we already proved this claim and verified the OTP once, contract knows\n      // that this wallet is OK\n      temporalSigner = walletKey;\n    } else {\n      // need to claim with the first wallet...\n      const claimantStr = claimAccountInfo.claimant.toBase58();\n      throw new Error(`This wallet does not match existing claimant ${claimantStr}`);\n    }\n  }\n\n  const nftsAvailable = amount;\n\n  if (nftsAlreadyMinted >= nftsAvailable) {\n    throw new Error(`Cannot mint another NFT. ${nftsAvailable} NFT(s) were originally allocated` + (nftsAlreadyMinted > 0 ? ` and ${nftsAlreadyMinted} NFT(s) were already minted` : \"\"));\n  }\n\n  const [candyMachineKey] = await getCandyMachineAddress(configKey, candyUUID);\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n  console.log(\"Candy Machine\", candyMachine);\n  const candyMachineMints = [];\n  const [instrs, mint] = await buildSingleCandyMint(connection, walletKey, distributorKey, distributorWalletKey, claimCount, temporalSigner, configKey, candyMachineKey, candyMachine.wallet, Buffer.from([...new BN(wbump).toArray(\"le\", 1), ...new BN(cbump).toArray(\"le\", 1), ...new BN(index).toArray(\"le\", 8), ...new BN(amount).toArray(\"le\", 8), ...secret.toBuffer(), ...new BN(proof.length).toArray(\"le\", 4), ...Buffer.concat(proof)]));\n  candyMachineMints.push(mint);\n  setup.push(...instrs);\n  return [setup, pdaSeeds, candyMachineMints];\n};\n\nconst buildSingleCandyMint = async (connection, walletKey, distributorKey, distributorWalletKey, claimCount, temporalSigner, configKey, candyMachineKey, candyMachineWallet, data) => {\n  const candyMachineMint = Keypair.generate();\n  const candyMachineMetadata = await getMetadata(candyMachineMint.publicKey);\n  const candyMachineMaster = await getEdition(candyMachineMint.publicKey);\n  const setup = [];\n  await createMintAndAccount(connection, walletKey, candyMachineMint.publicKey, setup);\n  setup.push(new TransactionInstruction({\n    programId: GUMDROP_DISTRIBUTOR_ID,\n    keys: [{\n      pubkey: distributorKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: distributorWalletKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: claimCount,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: temporalSigner,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: walletKey,\n      isSigner: true,\n      isWritable: false\n    }, // payer\n    {\n      pubkey: configKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: candyMachineKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: candyMachineWallet,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: candyMachineMint.publicKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: candyMachineMetadata,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: candyMachineMaster,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_METADATA_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: CANDY_MACHINE_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }],\n    data: Buffer.from([...Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0, 8), ...data])\n  }));\n  return [setup, candyMachineMint];\n};\n\nconst createMintAndAccount = async (connection, walletKey, mint, setup) => {\n  const [walletTokenKey] = await PublicKey.findProgramAddress([walletKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n  setup.push(SystemProgram.createAccount({\n    fromPubkey: walletKey,\n    newAccountPubkey: mint,\n    space: MintLayout.span,\n    lamports: await connection.getMinimumBalanceForRentExemption(MintLayout.span),\n    programId: TOKEN_PROGRAM_ID\n  }));\n  setup.push(Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mint, 0, walletKey, walletKey));\n  setup.push(Token.createAssociatedTokenAccountInstruction(SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, walletTokenKey, walletKey, walletKey));\n  setup.push(Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint, walletTokenKey, walletKey, [], 1));\n};\n\nconst buildEditionClaim = async (connection, walletKey, distributorKey, distributorInfo, masterMint, edition, proof, handle, amount, index, pin) => {\n  let masterMintKey;\n\n  try {\n    masterMintKey = new PublicKey(masterMint);\n  } catch (err) {\n    throw new Error(`Invalid master mint key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, masterMintKey); // should we assert that the amount is 1?\n\n  const leaf = Buffer.from([...new BN(index).toArray(\"le\", 8), ...secret.toBuffer(), ...masterMintKey.toBuffer(), ...new BN(amount).toArray(\"le\", 8), ...new BN(edition).toArray(\"le\", 8)]);\n  const matches = MerkleTree.verifyClaim(leaf, proof, Buffer.from(distributorInfo.root));\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress([Buffer.from(\"ClaimCount\"), Buffer.from(new BN(index).toArray(\"le\", 8)), distributorKey.toBuffer()], GUMDROP_DISTRIBUTOR_ID); // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey) ? walletKey : distributorInfo.temporal;\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n\n  if (claimCountAccount !== null) {\n    throw new Error(`This edition was already claimed`);\n  }\n\n  const setup = [];\n  const newMint = Keypair.generate();\n  const newMetadataKey = await getMetadata(newMint.publicKey);\n  const masterMetadataKey = await getMetadata(masterMintKey);\n  const newEdition = await getEdition(newMint.publicKey);\n  const masterEdition = await getEdition(masterMintKey);\n  await createMintAndAccount(connection, walletKey, newMint.publicKey, setup);\n  const [distributorTokenKey] = await PublicKey.findProgramAddress([distributorKey.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), masterMintKey.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n  const editionMarkKey = await getEditionMarkerPda(masterMintKey, new BN(edition));\n  setup.push(new TransactionInstruction({\n    programId: GUMDROP_DISTRIBUTOR_ID,\n    keys: [{\n      pubkey: distributorKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: claimCount,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: temporalSigner,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: walletKey,\n      isSigner: true,\n      isWritable: false\n    }, // payer\n    {\n      pubkey: newMetadataKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: newEdition,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: masterEdition,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: newMint.publicKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: editionMarkKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: walletKey,\n      isSigner: true,\n      isWritable: false\n    }, // `newMint` auth\n    {\n      pubkey: distributorTokenKey,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: walletKey,\n      isSigner: false,\n      isWritable: false\n    }, // new update auth\n    {\n      pubkey: masterMetadataKey,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: masterMintKey,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_METADATA_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }],\n    data: Buffer.from([...Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0, 8), ...new BN(cbump).toArray(\"le\", 1), ...new BN(index).toArray(\"le\", 8), ...new BN(amount).toArray(\"le\", 8), ...new BN(edition).toArray(\"le\", 8), ...secret.toBuffer(), ...new BN(proof.length).toArray(\"le\", 4), ...Buffer.concat(proof)])\n  }));\n  return [setup, pdaSeeds, [newMint]];\n};\n\nconst fetchDistributor = async (connection, distributorStr) => {\n  let key;\n\n  try {\n    key = new PublicKey(distributorStr);\n  } catch (err) {\n    throw new Error(`Invalid distributor key ${err}`);\n  }\n\n  const account = await connection.getAccountInfo(key);\n\n  if (account === null) {\n    throw new Error(`Could not fetch distributor ${distributorStr}`);\n  }\n\n  if (!account.owner.equals(GUMDROP_DISTRIBUTOR_ID)) {\n    const ownerStr = account.owner.toBase58();\n    throw new Error(`Invalid distributor owner ${ownerStr}`);\n  }\n\n  const info = coder.accounts.decode(\"MerkleDistributor\", account.data);\n  return [key, info];\n};\n\nconst fetchNeedsTemporalSigner = async (connection, distributorStr, indexStr, claimMethod) => {\n  const [key, info] = await fetchDistributor(connection, distributorStr);\n\n  if (!info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)) {\n    // default pubkey or program itself (distribution through wallets)\n    return false;\n  } else if (claimMethod === \"candy\") {\n    const [claimCount] = await PublicKey.findProgramAddress([Buffer.from(\"ClaimCount\"), Buffer.from(new BN(Number(indexStr)).toArray(\"le\", 8)), key.toBuffer()], GUMDROP_DISTRIBUTOR_ID); // if someone (maybe us) has already claimed this, the contract will\n    // not check the existing temporal signer anymore since presumably\n    // they have already verified the OTP. So we need to fetch the temporal\n    // signer if it is null\n\n    const claimCountAccount = await connection.getAccountInfo(claimCount);\n    return claimCountAccount === null;\n  } else {\n    // default to need one\n    return true;\n  }\n};\n\nexport const Claim = props => {\n  _s();\n\n  const connection = useConnection();\n  const wallet = useWallet();\n  let query = props.location.search;\n\n  if (query && query.length > 0) {\n    localStorage.setItem(\"claimQuery\", query);\n  } else {\n    const stored = localStorage.getItem(\"claimQuery\");\n    if (stored) query = stored;\n  }\n\n  const params = queryString.parse(query);\n  const [distributor, setDistributor] = React.useState(params.distributor || \"\");\n  const [claimMethod, setClaimMethod] = React.useState(params.tokenAcc ? \"transfer\" : params.config ? \"candy\" : params.master ? \"edition\" : \"\");\n  const [tokenAcc, setTokenAcc] = React.useState(params.tokenAcc || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(params.config || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(params.uuid || \"\");\n  const [masterMint, setMasterMint] = React.useState(params.master || \"\");\n  const [editionStr, setEditionStr] = React.useState(params.edition || \"\");\n  const [handle, setHandle] = React.useState(params.handle || \"\");\n  const [amountStr, setAmount] = React.useState(params.amount || \"\");\n  const [indexStr, setIndex] = React.useState(params.index || \"\");\n  const [pinStr, setPin] = React.useState(params.pin || \"\");\n  const [proofStr, setProof] = React.useState(params.proof || \"\");\n  const discordGuild = params.guild;\n  const allFieldsPopulated = distributor.length > 0 && (claimMethod === \"transfer\" ? tokenAcc.length > 0 : claimMethod === \"candy\" ? candyConfig.length > 0 && candyUUID.length > 0 : claimMethod === \"edition\" ? masterMint.length > 0 && editionStr.length > 0 : false) && handle.length > 0 && amountStr.length > 0 && indexStr.length > 0; // NB: pin can be empty if handle is a public-key and we are claiming through wallets\n  // NB: proof can be empty!\n\n  const [editable, setEditable] = React.useState(!allFieldsPopulated); // temporal verification\n\n  const [transaction, setTransaction] = React.useState(null);\n  const [OTPStr, setOTPStr] = React.useState(\"\"); // async computed\n\n  const [asyncNeedsTemporalSigner, setNeedsTemporalSigner] = React.useState(true);\n  React.useEffect(() => {\n    const wrap = async () => {\n      try {\n        setNeedsTemporalSigner(await fetchNeedsTemporalSigner(connection, distributor, indexStr, claimMethod));\n      } catch {// TODO: log?\n      }\n    };\n\n    wrap();\n  }, [connection, distributor, indexStr, claimMethod]);\n  const lambdaAPIEndpoint = \"https://{PLACEHOLDER-API-ID}.execute-api.us-east-2.amazonaws.com/send-OTP\";\n  const skipAWSWorkflow = false;\n\n  const sendOTP = async e => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const index = Number(indexStr);\n    const amount = Number(amountStr);\n    let pin = null;\n\n    if (isNaN(amount)) {\n      throw new Error(`Could not parse amount ${amountStr}`);\n    }\n\n    if (isNaN(index)) {\n      throw new Error(`Could not parse index ${indexStr}`);\n    }\n\n    if (params.pin !== \"NA\") {\n      try {\n        pin = new BN(pinStr);\n      } catch (err) {\n        throw new Error(`Could not parse pin ${pinStr}: ${err}`);\n      }\n    } // TODO: use cached?\n\n\n    const [distributorKey, distributorInfo] = await fetchDistributor(connection, distributor);\n    console.log(\"Distributor\", distributorInfo);\n    const proof = proofStr === \"\" ? [] : proofStr.split(\",\").map(b => {\n      const ret = Buffer.from(bs58.decode(b));\n      if (ret.length !== 32) throw new Error(`Invalid proof hash length`);\n      return ret;\n    });\n    let instructions, pdaSeeds, extraSigners;\n\n    if (claimMethod === \"candy\") {\n      console.log(\"Building candy claim\");\n      [instructions, pdaSeeds, extraSigners] = await buildCandyClaim(connection, wallet.publicKey, distributorKey, distributorInfo, candyConfig, candyUUID, proof, handle, amount, index, pin);\n    } else if (claimMethod === \"transfer\") {\n      [instructions, pdaSeeds, extraSigners] = await buildMintClaim(connection, wallet.publicKey, distributorKey, distributorInfo, tokenAcc, proof, handle, amount, index, pin);\n    } else if (claimMethod === \"edition\") {\n      const edition = Number(editionStr);\n\n      if (isNaN(edition)) {\n        throw new Error(`Could not parse edition ${editionStr}`);\n      }\n\n      [instructions, pdaSeeds, extraSigners] = await buildEditionClaim(connection, wallet.publicKey, distributorKey, distributorInfo, masterMint, edition, proof, handle, amount, index, pin);\n    } else {\n      throw new Error(`Unknown claim method ${claimMethod}`);\n    } // NB: if we're claiming through wallets then pdaSeeds should be empty\n    // since the secret is the wallet key (which is also a signer)\n\n\n    if (pin === null && pdaSeeds.length > 0) {\n      throw new Error(`Internal error: PDA generated when distributing to wallet directly`);\n    }\n\n    const transaction = new Transaction({\n      feePayer: wallet.publicKey,\n      recentBlockhash: (await connection.getRecentBlockhash(\"singleGossip\")).blockhash\n    });\n    const signers = new Set();\n\n    for (const instr of instructions) {\n      transaction.add(instr);\n\n      for (const key of instr.keys) if (key.isSigner) signers.add(key.pubkey);\n    }\n\n    console.log(`Expecting the following signers: ${[...signers].map(s => s.toBase58())}`);\n    transaction.setSigners(...signers);\n\n    if (extraSigners.length > 0) {\n      transaction.partialSign(...extraSigners);\n    }\n\n    const txnNeedsTemporalSigner = transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      const otpQuery = {\n        method: \"send\",\n        transaction: bs58.encode(transaction.serializeMessage()),\n        seeds: pdaSeeds\n      };\n\n      if (discordGuild) {\n        otpQuery.discordGuild = discordGuild;\n      }\n\n      const params = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(otpQuery)\n      };\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      let data;\n\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP response`);\n      }\n\n      console.log(\"AWS OTP response data:\", data);\n      let succeeded, toCheck;\n\n      if (discordGuild) {\n        succeeded = !!data.id;\n        toCheck = \"discord\";\n      } else {\n        succeeded = !!data.MessageId;\n        toCheck = \"email\";\n      }\n\n      if (!succeeded) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      notify({\n        message: \"OTP sent\",\n        description: `Please check your ${toCheck} (${handle}) for an OTP`\n      });\n    }\n\n    return transaction;\n  };\n\n  const verifyOTP = async (e, transaction) => {\n    e.preventDefault();\n\n    if (!transaction) {\n      throw new Error(`Transaction not available for OTP verification`);\n    }\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const txnNeedsTemporalSigner = transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      // TODO: distinguish between OTP failure and transaction-error. We can try\n      // again on the former but not the latter\n      const OTP = Number(OTPStr);\n\n      if (isNaN(OTP) || OTPStr.length === 0) {\n        throw new Error(`Could not parse OTP ${OTPStr}`);\n      }\n\n      const params = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        FunctionName: \"send-OTP\",\n        body: JSON.stringify({\n          method: \"verify\",\n          otp: OTP,\n          handle: handle // TODO?\n\n        })\n      };\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        const blob = JSON.stringify(response);\n        throw new Error(`Failed to verify AWS OTP. ${blob}`);\n      }\n\n      let data;\n\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP verification response`);\n      }\n\n      console.log(\"AWS verify response data:\", data);\n      let sig;\n\n      try {\n        sig = bs58.decode(data);\n      } catch {\n        throw new Error(`Could not decode transaction signature ${data.body}`);\n      }\n\n      transaction.addSignature(GUMDROP_TEMPORAL_SIGNER, sig);\n    }\n\n    let fullySigned;\n\n    try {\n      fullySigned = await wallet.signTransaction(transaction);\n    } catch {\n      throw new Error(\"Failed to sign transaction\");\n    }\n\n    const claimResult = await sendSignedTransaction({\n      connection,\n      signedTransaction: fullySigned\n    });\n    console.log(claimResult);\n    notify({\n      message: \"Claim succeeded\",\n      description: /*#__PURE__*/_jsxDEV(HyperLink, {\n        href: explorerLinkFor(claimResult.txid, connection),\n        children: \"View transaction on explorer\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 918,\n        columnNumber: 9\n      }, this)\n    });\n    setTransaction(null);\n\n    try {\n      setNeedsTemporalSigner(await fetchNeedsTemporalSigner(connection, distributor, indexStr, claimMethod));\n    } catch {// TODO: log?\n    }\n  };\n\n  const [loading, setLoading] = React.useState(false);\n\n  const loadingProgress = () => /*#__PURE__*/_jsxDEV(CircularProgress, {\n    size: 24,\n    sx: {\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      marginTop: '-12px',\n      marginLeft: '-12px'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 934,\n    columnNumber: 5\n  }, this);\n\n  const verifyOTPC = onClick => /*#__PURE__*/_jsxDEV(React.Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(TextField, {\n      id: \"otp-text-field\",\n      label: \"OTP\",\n      value: OTPStr,\n      onChange: e => setOTPStr(e.target.value)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 948,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Box, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 954,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Box, {\n      sx: {\n        position: \"relative\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(Button, {\n        disabled: !wallet.connected || !OTPStr || loading,\n        variant: \"contained\",\n        color: \"success\",\n        style: {\n          width: \"100%\"\n        },\n        onClick: e => {\n          setLoading(true);\n\n          const wrap = async () => {\n            try {\n              await verifyOTP(e, transaction);\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`\n              });\n              setLoading(false);\n            }\n          };\n\n          wrap();\n        },\n        children: \"Claim Gumdrop\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 957,\n        columnNumber: 7\n      }, this), loading && loadingProgress()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 956,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 947,\n    columnNumber: 5\n  }, this);\n\n  const claimData = claimMethod => {\n    if (claimMethod === \"candy\") {\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(TextField, {\n          id: \"config-text-field\",\n          label: \"Candy Config\",\n          value: candyConfig,\n          onChange: e => setCandyConfig(e.target.value),\n          disabled: !editable\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 991,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(TextField, {\n          id: \"config-uuid-text-field\",\n          label: \"Candy UUID\",\n          value: candyUUID,\n          onChange: e => setCandyUUID(e.target.value),\n          disabled: !editable\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 998,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 990,\n        columnNumber: 9\n      }, this);\n    } else if (claimMethod === \"transfer\") {\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: /*#__PURE__*/_jsxDEV(TextField, {\n          id: \"token-acc-text-field\",\n          label: \"Source Token Account\",\n          value: tokenAcc,\n          onChange: e => setTokenAcc(e.target.value),\n          disabled: !editable\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1010,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1009,\n        columnNumber: 9\n      }, this);\n    } else if (claimMethod === \"edition\") {\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(TextField, {\n          id: \"master-mint-text-field\",\n          label: \"Master Mint\",\n          value: masterMint,\n          onChange: e => setMasterMint(e.target.value),\n          disabled: !editable\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1022,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(TextField, {\n          id: \"edition-text-field\",\n          label: \"Edition\",\n          value: editionStr,\n          onChange: e => setEditionStr(e.target.value),\n          disabled: !editable\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1029,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1021,\n        columnNumber: 9\n      }, this);\n    }\n  };\n\n  const populateClaimC = onClick => /*#__PURE__*/_jsxDEV(React.Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(TextField, {\n      id: \"distributor-text-field\",\n      label: \"Distributor\",\n      value: distributor,\n      onChange: e => setDistributor(e.target.value),\n      disabled: !editable\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1043,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(FormControl, {\n      fullWidth: true,\n      children: [/*#__PURE__*/_jsxDEV(InputLabel, {\n        id: \"claim-method-label\",\n        disabled: !editable,\n        children: \"Claim Method\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1051,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(Select, {\n        labelId: \"claim-method-label\",\n        id: \"claim-method-select\",\n        value: claimMethod,\n        label: \"Claim Method\",\n        onChange: e => {\n          setClaimMethod(e.target.value);\n        },\n        style: {\n          textAlign: \"left\"\n        },\n        disabled: !editable,\n        children: [/*#__PURE__*/_jsxDEV(MenuItem, {\n          value: \"transfer\",\n          children: \"Token Transfer\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1066,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(MenuItem, {\n          value: \"candy\",\n          children: \"Candy Machine\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1067,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(MenuItem, {\n          value: \"edition\",\n          children: \"Limited Edition\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1068,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1057,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1050,\n      columnNumber: 7\n    }, this), claimMethod !== \"\" && claimData(claimMethod), claimMethod !== \"edition\" && /*#__PURE__*/_jsxDEV(TextField, {\n      id: \"amount-text-field\",\n      label: \"Amount\",\n      value: amountStr,\n      onChange: e => setAmount(e.target.value),\n      disabled: !editable\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1072,\n      columnNumber: 37\n    }, this), /*#__PURE__*/_jsxDEV(TextField, {\n      id: \"handle-text-field\",\n      label: \"Handle\",\n      value: handle,\n      onChange: e => setHandle(e.target.value),\n      disabled: !editable\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1079,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(TextField, {\n      id: \"index-text-field\",\n      label: \"Index\",\n      value: indexStr,\n      onChange: e => setIndex(e.target.value),\n      disabled: !editable\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1086,\n      columnNumber: 7\n    }, this), params.pin !== \"NA\" && /*#__PURE__*/_jsxDEV(TextField, {\n      id: \"pin-text-field\",\n      label: \"Pin\",\n      value: pinStr,\n      onChange: e => setPin(e.target.value),\n      disabled: !editable\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1093,\n      columnNumber: 31\n    }, this), /*#__PURE__*/_jsxDEV(TextField, {\n      id: \"proof-text-field\",\n      label: \"Proof\",\n      multiline: true,\n      value: proofStr,\n      onChange: e => setProof(e.target.value),\n      disabled: !editable\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1100,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Button, {\n      color: \"info\",\n      onClick: () => setEditable(!editable),\n      children: !editable ? \"Edit Claim\" : \"Stop Editing\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1108,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Box, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1114,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Box, {\n      sx: {\n        position: \"relative\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(Button, {\n        disabled: !wallet.connected || !allFieldsPopulated || loading,\n        variant: \"contained\",\n        style: {\n          width: \"100%\"\n        },\n        color: asyncNeedsTemporalSigner ? \"primary\" : \"success\",\n        onClick: e => {\n          setLoading(true);\n\n          const wrap = async () => {\n            try {\n              const needsTemporalSigner = await fetchNeedsTemporalSigner(connection, distributor, indexStr, claimMethod);\n              const transaction = await sendOTP(e);\n\n              if (!needsTemporalSigner) {\n                await verifyOTP(e, transaction);\n              } else {\n                setTransaction(transaction);\n              }\n\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`\n              });\n              setLoading(false);\n            }\n          };\n\n          wrap();\n        },\n        children: asyncNeedsTemporalSigner ? \"Next\" : \"Claim Gumdrop\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1117,\n        columnNumber: 7\n      }, this), loading && loadingProgress()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1116,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1042,\n    columnNumber: 5\n  }, this);\n\n  const steps = [{\n    name: \"Populate Claim\",\n    inner: populateClaimC\n  }];\n\n  if (asyncNeedsTemporalSigner) {\n    steps.push({\n      name: \"Verify OTP\",\n      inner: verifyOTPC\n    });\n  } // TODO: better interaction between setting `asyncNeedsTemporalSigner` and\n  // the stepper... this is pretty jank\n\n\n  const [activeStep, setActiveStep] = React.useState(0);\n  const stepToUse = Math.min(activeStep, steps.length - 1);\n\n  const handleNext = () => {\n    // return to start if going past the end (claim succeeded)\n    setActiveStep(prev => {\n      if (prev === steps.length - 1) {\n        return 0;\n      } else {\n        return prev + 1;\n      }\n    });\n  };\n\n  const handleBack = () => {\n    setActiveStep(prev => prev - 1);\n  };\n\n  const stepper = /*#__PURE__*/_jsxDEV(React.Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(Stepper, {\n      activeStep: stepToUse,\n      children: steps.map(s => {\n        return /*#__PURE__*/_jsxDEV(Step, {\n          children: /*#__PURE__*/_jsxDEV(StepLabel, {\n            children: s.name\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1188,\n            columnNumber: 15\n          }, this)\n        }, s.name, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1187,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1184,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Box, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1193,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1183,\n    columnNumber: 5\n  }, this);\n\n  return /*#__PURE__*/_jsxDEV(Stack, {\n    spacing: 2,\n    children: [asyncNeedsTemporalSigner && stepper, steps[stepToUse].inner(handleNext), stepToUse > 0 && /*#__PURE__*/_jsxDEV(Button, {\n      color: \"info\",\n      onClick: handleBack,\n      children: \"Back\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1202,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1198,\n    columnNumber: 5\n  }, this);\n};\n\n_s(Claim, \"OKg30iGaTkNAFts9fvWaZq9nZdY=\", false, function () {\n  return [useConnection, useWallet];\n});\n\n_c = Claim;\n\nvar _c;\n\n$RefreshReg$(_c, \"Claim\");","map":{"version":3,"sources":["C:/Users/Diego/metaplex/js/packages/gumdrop/src/components/Claim.tsx"],"names":["React","queryString","Box","Button","CircularProgress","FormControl","Link","HyperLink","InputLabel","MenuItem","Select","Stack","Step","StepLabel","Stepper","TextField","useWallet","Keypair","PublicKey","SystemProgram","SYSVAR_RENT_PUBKEY","SYSVAR_CLOCK_PUBKEY","Transaction","TransactionInstruction","AccountLayout","MintLayout","Token","TOKEN_PROGRAM_ID","notify","sha256","BN","bs58","useConnection","CANDY_MACHINE_ID","GUMDROP_DISTRIBUTOR_ID","GUMDROP_TEMPORAL_SIGNER","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_METADATA_PROGRAM_ID","getCandyMachine","getCandyMachineAddress","getEdition","getEditionMarkerPda","getMetadata","MerkleTree","explorerLinkFor","sendSignedTransaction","chunk","coder","walletKeyOrPda","walletKey","handle","pin","seed","key","equals","Error","err","seeds","toBuffer","Buffer","from","toArray","claimantPda","findProgramAddress","buildMintClaim","connection","distributorKey","distributorInfo","tokenAcc","proof","amount","index","tokenAccKey","distTokenAccount","getAccountInfo","tokenAccountInfo","decode","data","mint","console","log","toBase58","secret","pdaSeeds","leaf","matches","verifyClaim","root","claimStatus","cbump","walletTokenKey","setup","push","createAssociatedTokenAccountInstruction","temporalSigner","temporal","default","claimAirdrop","programId","keys","pubkey","isSigner","isWritable","digest","slice","length","concat","buildCandyClaim","candyConfig","candyUUID","configKey","claimCount","distributorWalletKey","wbump","claimCountAccount","nftsAlreadyMinted","claimAccountInfo","accounts","count","claimant","claimantStr","nftsAvailable","candyMachineKey","candyMachine","candyMachineMints","instrs","buildSingleCandyMint","wallet","candyMachineWallet","candyMachineMint","generate","candyMachineMetadata","publicKey","candyMachineMaster","createMintAndAccount","createAccount","fromPubkey","newAccountPubkey","space","span","lamports","getMinimumBalanceForRentExemption","createInitMintInstruction","createMintToInstruction","buildEditionClaim","masterMint","edition","masterMintKey","newMint","newMetadataKey","masterMetadataKey","newEdition","masterEdition","distributorTokenKey","editionMarkKey","fetchDistributor","distributorStr","account","owner","ownerStr","info","fetchNeedsTemporalSigner","indexStr","claimMethod","Number","Claim","props","query","location","search","localStorage","setItem","stored","getItem","params","parse","distributor","setDistributor","useState","setClaimMethod","config","master","setTokenAcc","setCandyConfig","setCandyUUID","uuid","setMasterMint","editionStr","setEditionStr","setHandle","amountStr","setAmount","setIndex","pinStr","setPin","proofStr","setProof","discordGuild","guild","allFieldsPopulated","editable","setEditable","transaction","setTransaction","OTPStr","setOTPStr","asyncNeedsTemporalSigner","setNeedsTemporalSigner","useEffect","wrap","lambdaAPIEndpoint","skipAWSWorkflow","sendOTP","e","preventDefault","connected","isNaN","split","map","b","ret","instructions","extraSigners","feePayer","recentBlockhash","getRecentBlockhash","blockhash","signers","Set","instr","add","s","setSigners","partialSign","txnNeedsTemporalSigner","signatures","some","otpQuery","method","encode","serializeMessage","headers","body","JSON","stringify","response","fetch","status","json","succeeded","toCheck","id","MessageId","message","description","verifyOTP","OTP","FunctionName","otp","blob","sig","addSignature","fullySigned","signTransaction","claimResult","signedTransaction","txid","loading","setLoading","loadingProgress","position","top","left","marginTop","marginLeft","verifyOTPC","onClick","target","value","width","claimData","populateClaimC","textAlign","needsTemporalSigner","steps","name","inner","activeStep","setActiveStep","stepToUse","Math","min","handleNext","prev","handleBack","stepper"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport { RouteComponentProps, } from \"react-router-dom\";\r\nimport queryString from 'query-string';\r\n\r\nimport {\r\n  Box,\r\n  Button,\r\n  CircularProgress,\r\n  FormControl,\r\n  Link as HyperLink,\r\n  InputLabel,\r\n  MenuItem,\r\n  Select,\r\n  Stack,\r\n  Step,\r\n  StepLabel,\r\n  Stepper,\r\n  TextField,\r\n} from \"@mui/material\";\r\n\r\nimport {\r\n  useWallet,\r\n} from \"@solana/wallet-adapter-react\";\r\nimport {\r\n  Connection as RPCConnection,\r\n  Keypair,\r\n  PublicKey,\r\n  SystemProgram,\r\n  SYSVAR_RENT_PUBKEY,\r\n  SYSVAR_CLOCK_PUBKEY,\r\n  Transaction,\r\n  TransactionInstruction,\r\n} from \"@solana/web3.js\";\r\nimport {\r\n  AccountLayout,\r\n  MintLayout,\r\n  Token,\r\n  TOKEN_PROGRAM_ID,\r\n} from \"@solana/spl-token\";\r\nimport {\r\n  notify,\r\n} from \"@oyster/common\";\r\nimport { sha256 } from \"js-sha256\";\r\nimport BN from 'bn.js';\r\nimport * as bs58 from \"bs58\";\r\n\r\nimport {\r\n  useConnection,\r\n} from \"../contexts\";\r\nimport {\r\n  CANDY_MACHINE_ID,\r\n  GUMDROP_DISTRIBUTOR_ID,\r\n  GUMDROP_TEMPORAL_SIGNER,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n} from \"../utils/ids\";\r\nimport {\r\n  getCandyMachine,\r\n  getCandyMachineAddress,\r\n  getEdition,\r\n  getEditionMarkerPda,\r\n  getMetadata,\r\n} from \"../utils/accounts\";\r\nimport { MerkleTree } from \"../utils/merkleTree\";\r\nimport {\r\n  explorerLinkFor,\r\n  sendSignedTransaction,\r\n} from \"../utils/transactions\";\r\nimport {\r\n  chunk,\r\n} from \"../utils/claimant\";\r\nimport { coder } from \"../utils/merkleDistributor\";\r\n\r\nconst walletKeyOrPda = async (\r\n  walletKey : PublicKey,\r\n  handle : string,\r\n  pin : BN | null,\r\n  seed : PublicKey,\r\n) : Promise<[PublicKey, Array<Buffer>]> => {\r\n  if (pin === null) {\r\n    try {\r\n      const key = new PublicKey(handle);\r\n      if (!key.equals(walletKey)) {\r\n        throw new Error(\"Claimant wallet handle does not match connected wallet\");\r\n      }\r\n      return [key, []];\r\n    } catch (err) {\r\n      throw new Error(`Invalid claimant wallet handle ${err}`);\r\n    }\r\n  } else {\r\n    const seeds = [\r\n      seed.toBuffer(),\r\n      Buffer.from(handle),\r\n      Buffer.from(pin.toArray(\"le\", 4)),\r\n    ];\r\n\r\n    const [claimantPda, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        seeds[0],\r\n        ...chunk(seeds[1], 32),\r\n        seeds[2],\r\n      ],\r\n      GUMDROP_DISTRIBUTOR_ID\r\n    );\r\n    return [claimantPda, seeds];\r\n  }\r\n}\r\n\r\n\r\nconst buildMintClaim = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorInfo : any,\r\n  tokenAcc : string,\r\n  proof : Array<Buffer>,\r\n  handle : string,\r\n  amount : number,\r\n  index : number,\r\n  pin : BN | null,\r\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\r\n  let tokenAccKey: PublicKey;\r\n  try {\r\n    tokenAccKey = new PublicKey(tokenAcc);\r\n  } catch (err) {\r\n    throw new Error(`Invalid tokenAcc key ${err}`);\r\n  }\r\n  const distTokenAccount = await connection.getAccountInfo(tokenAccKey);\r\n  if (distTokenAccount === null) {\r\n    throw new Error(`Could not fetch distributor token account`);\r\n  }\r\n\r\n  const tokenAccountInfo = AccountLayout.decode(distTokenAccount.data);\r\n  const mint = new PublicKey(tokenAccountInfo.mint);\r\n\r\n  console.log(mint.toBase58());\r\n\r\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, mint);\r\n\r\n  // TODO: since it's in the PDA do we need it to be in the leaf?\r\n  const leaf = Buffer.from(\r\n    [...new BN(index).toArray(\"le\", 8),\r\n     ...secret.toBuffer(),\r\n     ...mint.toBuffer(),\r\n     ...new BN(amount).toArray(\"le\", 8),\r\n    ]\r\n  );\r\n\r\n  const matches = MerkleTree.verifyClaim(\r\n    leaf, proof, Buffer.from(distributorInfo.root)\r\n  );\r\n\r\n  if (!matches) {\r\n    throw new Error(\"Gumdrop merkle proof does not match\");\r\n  }\r\n\r\n  const [claimStatus, cbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"ClaimStatus\"),\r\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\r\n    [\r\n      walletKey.toBuffer(),\r\n      TOKEN_PROGRAM_ID.toBuffer(),\r\n      mint.toBuffer(),\r\n    ],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n  );\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n\r\n  if (await connection.getAccountInfo(walletTokenKey) === null) {\r\n    setup.push(Token.createAssociatedTokenAccountInstruction(\r\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n        TOKEN_PROGRAM_ID,\r\n        mint,\r\n        walletTokenKey,\r\n        walletKey,\r\n        walletKey\r\n      ));\r\n  }\r\n\r\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\r\n      ? walletKey : distributorInfo.temporal;\r\n\r\n  const claimAirdrop = new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\r\n          { pubkey: claimStatus             , isSigner: false , isWritable: true  } ,\r\n          { pubkey: tokenAccKey             , isSigner: false , isWritable: true  } ,\r\n          { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\r\n          { pubkey: temporalSigner          , isSigner: true  , isWritable: false } ,\r\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,  // payer\r\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:claim\")).slice(0, 8),\r\n        ...new BN(cbump).toArray(\"le\", 1),\r\n        ...new BN(index).toArray(\"le\", 8),\r\n        ...new BN(amount).toArray(\"le\", 8),\r\n        ...secret.toBuffer(),\r\n        ...new BN(proof.length).toArray(\"le\", 4),\r\n        ...Buffer.concat(proof),\r\n      ])\r\n  })\r\n\r\n  return [[...setup, claimAirdrop], pdaSeeds, []];\r\n}\r\n\r\nconst buildCandyClaim = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorInfo : any,\r\n  candyConfig : string,\r\n  candyUUID : string,\r\n  proof : Array<Buffer>,\r\n  handle : string,\r\n  amount : number,\r\n  index : number,\r\n  pin : BN | null,\r\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\r\n\r\n  let configKey : PublicKey;\r\n  try {\r\n    configKey = new PublicKey(candyConfig);\r\n  } catch (err) {\r\n    throw new Error(`Invalid candy config key ${err}`);\r\n  }\r\n\r\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, configKey);\r\n\r\n  // TODO: since it's in the PDA do we need it to be in the leaf?\r\n  const leaf = Buffer.from(\r\n    [...new BN(index).toArray(\"le\", 8),\r\n     ...secret.toBuffer(),\r\n     ...configKey.toBuffer(),\r\n     ...new BN(amount).toArray(\"le\", 8),\r\n    ]\r\n  );\r\n\r\n  const matches = MerkleTree.verifyClaim(\r\n    leaf, proof, Buffer.from(distributorInfo.root)\r\n  );\r\n\r\n  if (!matches) {\r\n    throw new Error(\"Gumdrop merkle proof does not match\");\r\n  }\r\n\r\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"ClaimCount\"),\r\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"Wallet\"),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  // atm the contract has a special case for when the temporal key is defaulted\r\n  // (aka always passes temporal check)\r\n  // TODO: more flexible\r\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\r\n      ? walletKey : distributorInfo.temporal;\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n\r\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\r\n  let nftsAlreadyMinted = 0;\r\n  if (claimCountAccount === null) {\r\n    // nothing claimed yet\r\n  } else {\r\n    // TODO: subtract already minted?...\r\n    const claimAccountInfo = coder.accounts.decode(\r\n      \"ClaimCount\", claimCountAccount.data);\r\n    nftsAlreadyMinted = claimAccountInfo.count;\r\n    if (claimAccountInfo.claimant.equals(walletKey)) {\r\n      // we already proved this claim and verified the OTP once, contract knows\r\n      // that this wallet is OK\r\n      temporalSigner = walletKey;\r\n    } else {\r\n      // need to claim with the first wallet...\r\n      const claimantStr = claimAccountInfo.claimant.toBase58();\r\n      throw new Error(`This wallet does not match existing claimant ${claimantStr}`);\r\n    }\r\n  }\r\n\r\n  const nftsAvailable = amount;\r\n  if (nftsAlreadyMinted >= nftsAvailable) {\r\n    throw new Error(`Cannot mint another NFT. ${nftsAvailable} NFT(s) were originally allocated`\r\n      + (nftsAlreadyMinted > 0 ? ` and ${nftsAlreadyMinted} NFT(s) were already minted` : \"\"));\r\n  }\r\n\r\n\r\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUUID);\r\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\r\n  console.log(\"Candy Machine\", candyMachine);\r\n\r\n  const candyMachineMints : Array<Keypair> = [];\r\n\r\n  const [instrs, mint] = await buildSingleCandyMint(\r\n    connection,\r\n    walletKey,\r\n    distributorKey,\r\n    distributorWalletKey,\r\n    claimCount,\r\n    temporalSigner,\r\n    configKey,\r\n    candyMachineKey,\r\n    candyMachine.wallet,\r\n    Buffer.from([\r\n      ...new BN(wbump).toArray(\"le\", 1),\r\n      ...new BN(cbump).toArray(\"le\", 1),\r\n      ...new BN(index).toArray(\"le\", 8),\r\n      ...new BN(amount).toArray(\"le\", 8),\r\n      ...secret.toBuffer(),\r\n      ...new BN(proof.length).toArray(\"le\", 4),\r\n      ...Buffer.concat(proof),\r\n    ]),\r\n  );\r\n  candyMachineMints.push(mint);\r\n  setup.push(...instrs);\r\n\r\n  return [setup, pdaSeeds, candyMachineMints];\r\n}\r\n\r\nconst buildSingleCandyMint = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorWalletKey : PublicKey,\r\n  claimCount : PublicKey,\r\n  temporalSigner : PublicKey,\r\n  configKey : PublicKey,\r\n  candyMachineKey : PublicKey,\r\n  candyMachineWallet : PublicKey,\r\n  data : Buffer,\r\n) : Promise<[Array<TransactionInstruction>, Keypair]> => {\r\n  const candyMachineMint = Keypair.generate();\r\n  const candyMachineMetadata = await getMetadata(candyMachineMint.publicKey);\r\n  const candyMachineMaster = await getEdition(candyMachineMint.publicKey);\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n  await createMintAndAccount(connection, walletKey, candyMachineMint.publicKey, setup);\r\n  setup.push(new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: distributorWalletKey      , isSigner: false , isWritable: true  } ,\r\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\r\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\r\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\r\n\r\n          { pubkey: configKey                 , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineKey           , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineWallet        , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineMint.publicKey, isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineMetadata      , isSigner: false , isWritable: true  } ,\r\n          { pubkey: candyMachineMaster        , isSigner: false , isWritable: true  } ,\r\n\r\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\r\n          { pubkey: CANDY_MACHINE_ID          , isSigner: false , isWritable: false } ,\r\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\r\n          { pubkey: SYSVAR_CLOCK_PUBKEY       , isSigner: false , isWritable: false } ,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0, 8),\r\n        ...data,\r\n      ])\r\n  }));\r\n\r\n  return [setup, candyMachineMint];\r\n}\r\n\r\nconst createMintAndAccount = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  mint : PublicKey,\r\n  setup : Array<TransactionInstruction>,\r\n) => {\r\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\r\n    [\r\n      walletKey.toBuffer(),\r\n      TOKEN_PROGRAM_ID.toBuffer(),\r\n      mint.toBuffer(),\r\n    ],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n  );\r\n\r\n  setup.push(SystemProgram.createAccount({\r\n    fromPubkey: walletKey,\r\n    newAccountPubkey: mint,\r\n    space: MintLayout.span,\r\n    lamports:\r\n      await connection.getMinimumBalanceForRentExemption(\r\n        MintLayout.span,\r\n      ),\r\n    programId: TOKEN_PROGRAM_ID,\r\n  }));\r\n\r\n  setup.push(Token.createInitMintInstruction(\r\n    TOKEN_PROGRAM_ID,\r\n    mint,\r\n    0,\r\n    walletKey,\r\n    walletKey,\r\n  ));\r\n\r\n  setup.push(Token.createAssociatedTokenAccountInstruction(\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n    TOKEN_PROGRAM_ID,\r\n    mint,\r\n    walletTokenKey,\r\n    walletKey,\r\n    walletKey\r\n  ));\r\n\r\n  setup.push(Token.createMintToInstruction(\r\n    TOKEN_PROGRAM_ID,\r\n    mint,\r\n    walletTokenKey,\r\n    walletKey,\r\n    [],\r\n    1,\r\n  ));\r\n\r\n}\r\n\r\nconst buildEditionClaim = async (\r\n  connection : RPCConnection,\r\n  walletKey : PublicKey,\r\n  distributorKey : PublicKey,\r\n  distributorInfo : any,\r\n  masterMint : string,\r\n  edition : number,\r\n  proof : Array<Buffer>,\r\n  handle : string,\r\n  amount : number,\r\n  index : number,\r\n  pin : BN | null,\r\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\r\n\r\n  let masterMintKey : PublicKey;\r\n  try {\r\n    masterMintKey = new PublicKey(masterMint);\r\n  } catch (err) {\r\n    throw new Error(`Invalid master mint key ${err}`);\r\n  }\r\n\r\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, masterMintKey);\r\n\r\n  // should we assert that the amount is 1?\r\n  const leaf = Buffer.from(\r\n    [...new BN(index).toArray(\"le\", 8),\r\n     ...secret.toBuffer(),\r\n     ...masterMintKey.toBuffer(),\r\n     ...new BN(amount).toArray(\"le\", 8),\r\n     ...new BN(edition).toArray(\"le\", 8),\r\n    ]\r\n  );\r\n\r\n  const matches = MerkleTree.verifyClaim(\r\n    leaf, proof, Buffer.from(distributorInfo.root)\r\n  );\r\n\r\n  if (!matches) {\r\n    throw new Error(\"Gumdrop merkle proof does not match\");\r\n  }\r\n\r\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(\"ClaimCount\"),\r\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\r\n      distributorKey.toBuffer(),\r\n    ],\r\n    GUMDROP_DISTRIBUTOR_ID\r\n  );\r\n\r\n  // atm the contract has a special case for when the temporal key is defaulted\r\n  // (aka always passes temporal check)\r\n  // TODO: more flexible\r\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\r\n      ? walletKey : distributorInfo.temporal;\r\n\r\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\r\n  if (claimCountAccount !== null) {\r\n    throw new Error(`This edition was already claimed`);\r\n  }\r\n\r\n  const setup : Array<TransactionInstruction> = [];\r\n\r\n  const newMint = Keypair.generate();\r\n  const newMetadataKey = await getMetadata(newMint.publicKey);\r\n  const masterMetadataKey = await getMetadata(masterMintKey);\r\n  const newEdition = await getEdition(newMint.publicKey);\r\n  const masterEdition = await getEdition(masterMintKey);\r\n\r\n  await createMintAndAccount(connection, walletKey, newMint.publicKey, setup);\r\n\r\n  const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\r\n    [\r\n      distributorKey.toBuffer(),\r\n      TOKEN_PROGRAM_ID.toBuffer(),\r\n      masterMintKey.toBuffer(),\r\n    ],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n  );\r\n\r\n  const editionMarkKey = await getEditionMarkerPda(masterMintKey, new BN(edition));\r\n\r\n  setup.push(new TransactionInstruction({\r\n      programId: GUMDROP_DISTRIBUTOR_ID,\r\n      keys: [\r\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\r\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\r\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\r\n\r\n          { pubkey: newMetadataKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: newEdition                , isSigner: false , isWritable: true  } ,\r\n          { pubkey: masterEdition             , isSigner: false , isWritable: true  } ,\r\n          { pubkey: newMint.publicKey         , isSigner: false , isWritable: true  } ,\r\n          { pubkey: editionMarkKey            , isSigner: false , isWritable: true  } ,\r\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // `newMint` auth\r\n          { pubkey: distributorTokenKey       , isSigner: false , isWritable: false } ,\r\n          { pubkey: walletKey                 , isSigner: false , isWritable: false } , // new update auth\r\n          { pubkey: masterMetadataKey         , isSigner: false , isWritable: false } ,\r\n          { pubkey: masterMintKey             , isSigner: false , isWritable: false } ,\r\n\r\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\r\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\r\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\r\n      ],\r\n      data: Buffer.from([\r\n        ...Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0, 8),\r\n        ...new BN(cbump).toArray(\"le\", 1),\r\n        ...new BN(index).toArray(\"le\", 8),\r\n        ...new BN(amount).toArray(\"le\", 8),\r\n        ...new BN(edition).toArray(\"le\", 8),\r\n        ...secret.toBuffer(),\r\n        ...new BN(proof.length).toArray(\"le\", 4),\r\n        ...Buffer.concat(proof),\r\n      ])\r\n  }));\r\n\r\n  return [setup, pdaSeeds, [newMint]];\r\n}\r\n\r\nconst fetchDistributor = async (\r\n  connection : RPCConnection,\r\n  distributorStr : string,\r\n) => {\r\n  let key;\r\n  try {\r\n    key = new PublicKey(distributorStr);\r\n  } catch (err) {\r\n    throw new Error(`Invalid distributor key ${err}`);\r\n  }\r\n  const account = await connection.getAccountInfo(key);\r\n  if (account === null) {\r\n    throw new Error(`Could not fetch distributor ${distributorStr}`);\r\n  }\r\n  if (!account.owner.equals(GUMDROP_DISTRIBUTOR_ID)) {\r\n    const ownerStr = account.owner.toBase58();\r\n    throw new Error(`Invalid distributor owner ${ownerStr}`);\r\n  }\r\n  const info = coder.accounts.decode(\"MerkleDistributor\", account.data);\r\n  return [key, info];\r\n};\r\n\r\nconst fetchNeedsTemporalSigner = async (\r\n  connection : RPCConnection,\r\n  distributorStr : string,\r\n  indexStr : string,\r\n  claimMethod : string,\r\n) => {\r\n  const [key, info] = await fetchDistributor(connection, distributorStr);\r\n  if (!info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)) {\r\n    // default pubkey or program itself (distribution through wallets)\r\n    return false;\r\n  } else if (claimMethod === \"candy\") {\r\n    const [claimCount, ] = await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from(\"ClaimCount\"),\r\n        Buffer.from(new BN(Number(indexStr)).toArray(\"le\", 8)),\r\n        key.toBuffer(),\r\n      ],\r\n      GUMDROP_DISTRIBUTOR_ID\r\n    );\r\n    // if someone (maybe us) has already claimed this, the contract will\r\n    // not check the existing temporal signer anymore since presumably\r\n    // they have already verified the OTP. So we need to fetch the temporal\r\n    // signer if it is null\r\n    const claimCountAccount = await connection.getAccountInfo(claimCount);\r\n    return claimCountAccount === null;\r\n  } else {\r\n    // default to need one\r\n    return true;\r\n  }\r\n};\r\n\r\nexport type ClaimProps = {};\r\n\r\nexport const Claim = (\r\n  props : RouteComponentProps<ClaimProps>,\r\n) => {\r\n  const connection = useConnection();\r\n  const wallet = useWallet();\r\n\r\n  let query = props.location.search;\r\n  if (query && query.length > 0) {\r\n    localStorage.setItem(\"claimQuery\", query);\r\n  } else {\r\n    const stored = localStorage.getItem(\"claimQuery\");\r\n    if (stored)\r\n      query = stored;\r\n  }\r\n\r\n  const params = queryString.parse(query);\r\n  const [distributor, setDistributor] = React.useState(params.distributor as string || \"\");\r\n  const [claimMethod, setClaimMethod] = React.useState(\r\n        params.tokenAcc ? \"transfer\"\r\n      : params.config   ? \"candy\"\r\n      : params.master   ? \"edition\"\r\n      :                   \"\");\r\n  const [tokenAcc, setTokenAcc] = React.useState(params.tokenAcc as string || \"\");\r\n  const [candyConfig, setCandyConfig] = React.useState(params.config as string || \"\");\r\n  const [candyUUID, setCandyUUID] = React.useState(params.uuid as string || \"\");\r\n  const [masterMint, setMasterMint] = React.useState(params.master as string || \"\");\r\n  const [editionStr, setEditionStr] = React.useState(params.edition as string || \"\");\r\n  const [handle, setHandle] = React.useState(params.handle as string || \"\");\r\n  const [amountStr, setAmount] = React.useState(params.amount as string || \"\");\r\n  const [indexStr, setIndex] = React.useState(params.index as string || \"\");\r\n  const [pinStr, setPin] = React.useState(params.pin as string || \"\");\r\n  const [proofStr, setProof] = React.useState(params.proof as string || \"\");\r\n\r\n  const discordGuild = params.guild;\r\n\r\n  const allFieldsPopulated =\r\n    distributor.length > 0\r\n    && ( claimMethod === \"transfer\" ? tokenAcc.length > 0\r\n       : claimMethod === \"candy\"    ? candyConfig.length > 0 && candyUUID.length > 0\r\n       : claimMethod === \"edition\"  ? masterMint.length > 0 && editionStr.length > 0\r\n       :                              false\r\n       )\r\n    && handle.length > 0\r\n    && amountStr.length > 0\r\n    && indexStr.length > 0;\r\n    // NB: pin can be empty if handle is a public-key and we are claiming through wallets\r\n    // NB: proof can be empty!\r\n\r\n  const [editable, setEditable] = React.useState(!allFieldsPopulated);\r\n\r\n  // temporal verification\r\n  const [transaction, setTransaction] = React.useState<Transaction | null>(null);\r\n  const [OTPStr, setOTPStr] = React.useState(\"\");\r\n\r\n  // async computed\r\n  const [asyncNeedsTemporalSigner, setNeedsTemporalSigner] = React.useState<boolean>(true);\r\n\r\n  React.useEffect(() => {\r\n    const wrap = async () => {\r\n      try {\r\n        setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\r\n          connection, distributor, indexStr, claimMethod));\r\n      } catch {\r\n        // TODO: log?\r\n      }\r\n    };\r\n    wrap();\r\n  }, [connection, distributor, indexStr, claimMethod]);\r\n\r\n  const lambdaAPIEndpoint = \"https://{PLACEHOLDER-API-ID}.execute-api.us-east-2.amazonaws.com/send-OTP\";\r\n\r\n  const skipAWSWorkflow = false;\r\n\r\n  const sendOTP = async (e : React.SyntheticEvent) => {\r\n    e.preventDefault();\r\n\r\n    if (!wallet.connected || wallet.publicKey === null) {\r\n      throw new Error(`Wallet not connected`);\r\n    }\r\n\r\n    const index = Number(indexStr);\r\n    const amount = Number(amountStr);\r\n    let pin : BN | null = null;\r\n\r\n    if (isNaN(amount)) {\r\n      throw new Error(`Could not parse amount ${amountStr}`);\r\n    }\r\n    if (isNaN(index)) {\r\n      throw new Error(`Could not parse index ${indexStr}`);\r\n    }\r\n    if (params.pin !== \"NA\") {\r\n      try {\r\n        pin = new BN(pinStr);\r\n      } catch (err) {\r\n        throw new Error(`Could not parse pin ${pinStr}: ${err}`);\r\n      }\r\n    }\r\n\r\n    // TODO: use cached?\r\n    const [distributorKey, distributorInfo] =\r\n        await fetchDistributor(connection, distributor);\r\n\r\n    console.log(\"Distributor\", distributorInfo);\r\n\r\n    const proof = proofStr === \"\" ? [] : proofStr.split(\",\").map(b => {\r\n      const ret = Buffer.from(bs58.decode(b))\r\n      if (ret.length !== 32)\r\n        throw new Error(`Invalid proof hash length`);\r\n      return ret;\r\n    });\r\n\r\n    let instructions, pdaSeeds, extraSigners;\r\n    if (claimMethod === \"candy\") {\r\n      console.log(\"Building candy claim\");\r\n      [instructions, pdaSeeds, extraSigners] = await buildCandyClaim(\r\n        connection, wallet.publicKey, distributorKey, distributorInfo,\r\n        candyConfig, candyUUID,\r\n        proof, handle, amount, index, pin\r\n      );\r\n    } else if (claimMethod === \"transfer\") {\r\n      [instructions, pdaSeeds, extraSigners] = await buildMintClaim(\r\n        connection, wallet.publicKey, distributorKey, distributorInfo,\r\n        tokenAcc,\r\n        proof, handle, amount, index, pin\r\n      );\r\n    } else if (claimMethod === \"edition\") {\r\n      const edition = Number(editionStr);\r\n      if (isNaN(edition)) {\r\n        throw new Error(`Could not parse edition ${editionStr}`);\r\n      }\r\n      [instructions, pdaSeeds, extraSigners] = await buildEditionClaim(\r\n        connection, wallet.publicKey, distributorKey, distributorInfo,\r\n        masterMint, edition,\r\n        proof, handle, amount, index, pin\r\n      );\r\n    } else {\r\n      throw new Error(`Unknown claim method ${claimMethod}`);\r\n    }\r\n\r\n    // NB: if we're claiming through wallets then pdaSeeds should be empty\r\n    // since the secret is the wallet key (which is also a signer)\r\n    if (pin === null && pdaSeeds.length > 0) {\r\n      throw new Error(`Internal error: PDA generated when distributing to wallet directly`);\r\n    }\r\n\r\n    const transaction = new Transaction({\r\n      feePayer: wallet.publicKey,\r\n      recentBlockhash: (await connection.getRecentBlockhash(\"singleGossip\")).blockhash,\r\n    });\r\n\r\n    const signers = new Set<PublicKey>();\r\n    for (const instr of instructions) {\r\n      transaction.add(instr);\r\n      for (const key of instr.keys)\r\n        if (key.isSigner)\r\n          signers.add(key.pubkey);\r\n    }\r\n    console.log(`Expecting the following signers: ${[...signers].map(s => s.toBase58())}`);\r\n    transaction.setSigners(...signers);\r\n\r\n    if (extraSigners.length > 0) {\r\n      transaction.partialSign(...extraSigners);\r\n    }\r\n\r\n    const txnNeedsTemporalSigner =\r\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\r\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\r\n      const otpQuery : { [key: string] : any } = {\r\n        method: \"send\",\r\n        transaction: bs58.encode(transaction.serializeMessage()),\r\n        seeds: pdaSeeds,\r\n      };\r\n      if (discordGuild) {\r\n        otpQuery.discordGuild = discordGuild;\r\n      }\r\n      const params = {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify(otpQuery),\r\n      };\r\n\r\n      const response = await fetch(lambdaAPIEndpoint, params);\r\n      console.log(response);\r\n\r\n      if (response.status !== 200) {\r\n        throw new Error(`Failed to send AWS OTP`);\r\n      }\r\n\r\n      let data;\r\n      try {\r\n        data = await response.json();\r\n      } catch {\r\n        throw new Error(`Could not parse AWS OTP response`);\r\n      }\r\n\r\n      console.log(\"AWS OTP response data:\", data);\r\n\r\n      let succeeded, toCheck;\r\n      if (discordGuild) {\r\n        succeeded = !!data.id;\r\n        toCheck = \"discord\";\r\n      } else {\r\n        succeeded = !!data.MessageId;\r\n        toCheck = \"email\";\r\n      }\r\n\r\n      if (!succeeded) {\r\n        throw new Error(`Failed to send AWS OTP`);\r\n      }\r\n\r\n      notify({\r\n        message: \"OTP sent\",\r\n        description: `Please check your ${toCheck} (${handle}) for an OTP`,\r\n      });\r\n    }\r\n\r\n    return transaction;\r\n  };\r\n\r\n  const verifyOTP = async (\r\n    e : React.SyntheticEvent,\r\n    transaction : Transaction | null,\r\n  ) => {\r\n    e.preventDefault();\r\n\r\n    if (!transaction) {\r\n      throw new Error(`Transaction not available for OTP verification`);\r\n    }\r\n\r\n    if (!wallet.connected || wallet.publicKey === null) {\r\n      throw new Error(`Wallet not connected`);\r\n    }\r\n\r\n    const txnNeedsTemporalSigner =\r\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\r\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\r\n      // TODO: distinguish between OTP failure and transaction-error. We can try\r\n      // again on the former but not the latter\r\n      const OTP = Number(OTPStr);\r\n      if (isNaN(OTP) || OTPStr.length === 0) {\r\n        throw new Error(`Could not parse OTP ${OTPStr}`);\r\n      }\r\n\r\n      const params = {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        FunctionName: \"send-OTP\",\r\n        body: JSON.stringify({\r\n          method: \"verify\",\r\n          otp: OTP,\r\n          handle: handle,  // TODO?\r\n        }),\r\n      };\r\n\r\n      const response = await fetch(lambdaAPIEndpoint, params);\r\n      console.log(response);\r\n\r\n      if (response.status !== 200) {\r\n        const blob = JSON.stringify(response);\r\n        throw new Error(`Failed to verify AWS OTP. ${blob}`);\r\n      }\r\n\r\n      let data;\r\n      try {\r\n        data = await response.json();\r\n      } catch {\r\n        throw new Error(`Could not parse AWS OTP verification response`);\r\n      }\r\n\r\n      console.log(\"AWS verify response data:\", data);\r\n\r\n      let sig;\r\n      try {\r\n        sig = bs58.decode(data);\r\n      } catch {\r\n        throw new Error(`Could not decode transaction signature ${data.body}`);\r\n      }\r\n\r\n      transaction.addSignature(GUMDROP_TEMPORAL_SIGNER, sig);\r\n    }\r\n\r\n    let fullySigned;\r\n    try {\r\n      fullySigned = await wallet.signTransaction(transaction);\r\n    } catch {\r\n      throw new Error(\"Failed to sign transaction\");\r\n    }\r\n\r\n    const claimResult = await sendSignedTransaction({\r\n      connection,\r\n      signedTransaction: fullySigned,\r\n    });\r\n\r\n    console.log(claimResult);\r\n    notify({\r\n      message: \"Claim succeeded\",\r\n      description: (\r\n        <HyperLink href={explorerLinkFor(claimResult.txid, connection)}>\r\n          View transaction on explorer\r\n        </HyperLink>\r\n      ),\r\n    });\r\n    setTransaction(null);\r\n    try {\r\n      setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\r\n        connection, distributor, indexStr, claimMethod));\r\n    } catch {\r\n      // TODO: log?\r\n    }\r\n  };\r\n\r\n  const [loading, setLoading] = React.useState(false);\r\n  const loadingProgress = () => (\r\n    <CircularProgress\r\n      size={24}\r\n      sx={{\r\n        position: 'absolute',\r\n        top: '50%',\r\n        left: '50%',\r\n        marginTop: '-12px',\r\n        marginLeft: '-12px',\r\n      }}\r\n    />\r\n  );\r\n\r\n  const verifyOTPC = (onClick) => (\r\n    <React.Fragment>\r\n      <TextField\r\n        id=\"otp-text-field\"\r\n        label=\"OTP\"\r\n        value={OTPStr}\r\n        onChange={(e) => setOTPStr(e.target.value)}\r\n      />\r\n      <Box />\r\n\r\n      <Box sx={{ position: \"relative\" }}>\r\n      <Button\r\n        disabled={!wallet.connected || !OTPStr || loading}\r\n        variant=\"contained\"\r\n        color=\"success\"\r\n        style={{ width: \"100%\" }}\r\n        onClick={(e) => {\r\n          setLoading(true);\r\n          const wrap = async () => {\r\n            try {\r\n              await verifyOTP(e, transaction);\r\n              setLoading(false);\r\n              onClick();\r\n            } catch (err) {\r\n              notify({\r\n                message: \"Claim failed\",\r\n                description: `${err}`,\r\n              });\r\n              setLoading(false);\r\n            }\r\n          };\r\n          wrap();\r\n        }}\r\n      >\r\n        Claim Gumdrop\r\n      </Button>\r\n      {loading && loadingProgress()}\r\n      </Box>\r\n    </React.Fragment>\r\n  );\r\n\r\n  const claimData = (claimMethod) => {\r\n    if (claimMethod === \"candy\") {\r\n      return (\r\n        <React.Fragment>\r\n          <TextField\r\n            id=\"config-text-field\"\r\n            label=\"Candy Config\"\r\n            value={candyConfig}\r\n            onChange={e => setCandyConfig(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n          <TextField\r\n            id=\"config-uuid-text-field\"\r\n            label=\"Candy UUID\"\r\n            value={candyUUID}\r\n            onChange={e => setCandyUUID(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n        </React.Fragment>\r\n      );\r\n    } else if (claimMethod === \"transfer\") {\r\n      return (\r\n        <React.Fragment>\r\n          <TextField\r\n            id=\"token-acc-text-field\"\r\n            label=\"Source Token Account\"\r\n            value={tokenAcc}\r\n            onChange={(e) => setTokenAcc(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n        </React.Fragment>\r\n      );\r\n    } else if (claimMethod === \"edition\") {\r\n      return (\r\n        <React.Fragment>\r\n          <TextField\r\n            id=\"master-mint-text-field\"\r\n            label=\"Master Mint\"\r\n            value={masterMint}\r\n            onChange={(e) => setMasterMint(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n          <TextField\r\n            id=\"edition-text-field\"\r\n            label=\"Edition\"\r\n            value={editionStr}\r\n            onChange={(e) => setEditionStr(e.target.value)}\r\n            disabled={!editable}\r\n          />\r\n        </React.Fragment>\r\n      );\r\n    }\r\n  };\r\n\r\n  const populateClaimC = (onClick) => (\r\n    <React.Fragment>\r\n      <TextField\r\n        id=\"distributor-text-field\"\r\n        label=\"Distributor\"\r\n        value={distributor}\r\n        onChange={(e) => setDistributor(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      <FormControl fullWidth>\r\n        <InputLabel\r\n          id=\"claim-method-label\"\r\n          disabled={!editable}\r\n        >\r\n          Claim Method\r\n        </InputLabel>\r\n        <Select\r\n          labelId=\"claim-method-label\"\r\n          id=\"claim-method-select\"\r\n          value={claimMethod}\r\n          label=\"Claim Method\"\r\n          onChange={(e) => { setClaimMethod(e.target.value); }}\r\n          style={{textAlign: \"left\"}}\r\n          disabled={!editable}\r\n        >\r\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\r\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\r\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\r\n        </Select>\r\n      </FormControl>\r\n      {claimMethod !== \"\" && claimData(claimMethod)}\r\n      {claimMethod !== \"edition\" && <TextField\r\n        id=\"amount-text-field\"\r\n        label=\"Amount\"\r\n        value={amountStr}\r\n        onChange={(e) => setAmount(e.target.value)}\r\n        disabled={!editable}\r\n      />}\r\n      <TextField\r\n        id=\"handle-text-field\"\r\n        label=\"Handle\"\r\n        value={handle}\r\n        onChange={(e) => setHandle(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      <TextField\r\n        id=\"index-text-field\"\r\n        label=\"Index\"\r\n        value={indexStr}\r\n        onChange={(e) => setIndex(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      {params.pin !== \"NA\" && <TextField\r\n        id=\"pin-text-field\"\r\n        label=\"Pin\"\r\n        value={pinStr}\r\n        onChange={(e) => setPin(e.target.value)}\r\n        disabled={!editable}\r\n      />}\r\n      <TextField\r\n        id=\"proof-text-field\"\r\n        label=\"Proof\"\r\n        multiline\r\n        value={proofStr}\r\n        onChange={(e) => setProof(e.target.value)}\r\n        disabled={!editable}\r\n      />\r\n      <Button\r\n        color=\"info\"\r\n        onClick={() => setEditable(!editable)}\r\n      >\r\n        {!editable ? \"Edit Claim\" : \"Stop Editing\"}\r\n      </Button>\r\n      <Box />\r\n\r\n      <Box sx={{ position: \"relative\" }}>\r\n      <Button\r\n        disabled={!wallet.connected || !allFieldsPopulated || loading}\r\n        variant=\"contained\"\r\n        style={{ width: \"100%\" }}\r\n        color={asyncNeedsTemporalSigner ? \"primary\" : \"success\"}\r\n        onClick={(e) => {\r\n          setLoading(true);\r\n          const wrap = async () => {\r\n            try {\r\n              const needsTemporalSigner = await fetchNeedsTemporalSigner(\r\n                  connection, distributor, indexStr, claimMethod);\r\n              const transaction = await sendOTP(e);\r\n              if (!needsTemporalSigner) {\r\n                await verifyOTP(e, transaction);\r\n              } else {\r\n                setTransaction(transaction);\r\n              }\r\n              setLoading(false);\r\n              onClick();\r\n            } catch (err) {\r\n              notify({\r\n                message: \"Claim failed\",\r\n                description: `${err}`,\r\n              });\r\n              setLoading(false);\r\n            }\r\n          };\r\n          wrap();\r\n        }}\r\n      >\r\n        {asyncNeedsTemporalSigner ? \"Next\" : \"Claim Gumdrop\"}\r\n      </Button>\r\n      {loading && loadingProgress()}\r\n      </Box>\r\n    </React.Fragment>\r\n  );\r\n\r\n  const steps = [\r\n    { name: \"Populate Claim\", inner: populateClaimC },\r\n  ];\r\n  if (asyncNeedsTemporalSigner) {\r\n    steps.push(\r\n    { name: \"Verify OTP\"    , inner: verifyOTPC     }\r\n    );\r\n  }\r\n\r\n  // TODO: better interaction between setting `asyncNeedsTemporalSigner` and\r\n  // the stepper... this is pretty jank\r\n  const [activeStep, setActiveStep] = React.useState(0);\r\n  const stepToUse = Math.min(activeStep, steps.length - 1);\r\n\r\n  const handleNext = () => {\r\n    // return to start if going past the end (claim succeeded)\r\n    setActiveStep(prev => {\r\n      if (prev === steps.length - 1) {\r\n        return 0;\r\n      } else {\r\n        return prev + 1;\r\n      }\r\n    });\r\n  };\r\n  const handleBack = () => {\r\n    setActiveStep(prev => prev - 1);\r\n  };\r\n\r\n  const stepper = (\r\n    <React.Fragment>\r\n      <Stepper activeStep={stepToUse}>\r\n        {steps.map(s => {\r\n          return (\r\n            <Step key={s.name}>\r\n              <StepLabel>{s.name}</StepLabel>\r\n            </Step>\r\n          );\r\n        })}\r\n      </Stepper>\r\n      <Box />\r\n    </React.Fragment>\r\n  );\r\n\r\n  return (\r\n    <Stack spacing={2}>\r\n      {asyncNeedsTemporalSigner && stepper}\r\n      {steps[stepToUse].inner(handleNext)}\r\n      {stepToUse > 0 && (\r\n        <Button\r\n          color=\"info\"\r\n          onClick={handleBack}\r\n        >\r\n          Back\r\n        </Button>\r\n      )}\r\n    </Stack>\r\n  );\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}