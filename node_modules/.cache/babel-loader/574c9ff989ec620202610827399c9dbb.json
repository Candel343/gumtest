{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useAccount = exports.useMint = exports.useNativeAccount = exports.AccountsProvider = exports.useAccountsContext = void 0;\n\nconst react_1 = __importStar(require(\"react\"));\n\nconst wallet_adapter_react_1 = require(\"@solana/wallet-adapter-react\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst spl_token_1 = require(\"@solana/spl-token\");\n\nconst connection_1 = require(\"../../contexts/connection\");\n\nconst ids_1 = require(\"../../utils/ids\");\n\nconst programIds_1 = require(\"../../utils/programIds\");\n\nconst cache_1 = require(\"./cache\");\n\nconst deserialize_1 = require(\"./deserialize\");\n\nconst parsesrs_1 = require(\"./parsesrs\");\n\nconst AccountsContext = react_1.default.createContext(null);\n\nconst useAccountsContext = () => {\n  const context = react_1.useContext(AccountsContext);\n  return context;\n};\n\nexports.useAccountsContext = useAccountsContext;\n\nfunction wrapNativeAccount(pubkey, account) {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new web3_js_1.PublicKey(pubkey);\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: ids_1.WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new spl_token_1.u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new spl_token_1.u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null\n    }\n  };\n}\n\nconst UseNativeAccount = () => {\n  const connection = connection_1.useConnection();\n  const {\n    publicKey\n  } = wallet_adapter_react_1.useWallet();\n  const [nativeAccount, setNativeAccount] = react_1.useState();\n  const updateCache = react_1.useCallback(account => {\n    if (publicKey) {\n      const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n\n      if (wrapped !== undefined) {\n        const id = publicKey.toBase58();\n        cache_1.cache.registerParser(id, parsesrs_1.TokenAccountParser);\n        cache_1.genericCache.set(id, wrapped);\n        cache_1.cache.emitter.raiseCacheUpdated(id, false, parsesrs_1.TokenAccountParser, true);\n      }\n    }\n  }, [publicKey]);\n  react_1.useEffect(() => {\n    let subId = 0;\n\n    const updateAccount = account => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      const account = await connection.getAccountInfo(publicKey);\n      updateAccount(account);\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n  return {\n    nativeAccount\n  };\n};\n\nconst PRECACHED_OWNERS = new Set();\n\nconst precacheUserTokenAccounts = async (connection, owner) => {\n  if (!owner) {\n    return;\n  } // used for filtering account updates over websocket\n\n\n  PRECACHED_OWNERS.add(owner.toBase58()); // user accounts are updated via ws subscription\n\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds_1.programIds().token\n  });\n  accounts.value.forEach(info => {\n    cache_1.cache.add(info.pubkey.toBase58(), info.account, parsesrs_1.TokenAccountParser);\n  });\n};\n\nfunction AccountsProvider({\n  children = null\n}) {\n  const connection = connection_1.useConnection();\n  const {\n    publicKey\n  } = wallet_adapter_react_1.useWallet();\n  const [tokenAccounts, setTokenAccounts] = react_1.useState([]);\n  const [userAccounts, setUserAccounts] = react_1.useState([]);\n  const {\n    nativeAccount\n  } = UseNativeAccount();\n  const walletKey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58();\n  const selectUserAccounts = react_1.useCallback(() => {\n    return cache_1.cache.byParser(parsesrs_1.TokenAccountParser).map(id => cache_1.cache.get(id)).filter(a => a && a.info.owner.toBase58() === walletKey).map(a => a);\n  }, [walletKey]);\n  react_1.useEffect(() => {\n    const accounts = selectUserAccounts().filter(a => a !== undefined);\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n  react_1.useEffect(() => {\n    const subs = [];\n    cache_1.cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new web3_js_1.PublicKey(id), info => {\n          cache_1.cache.add(id, info, deserialize);\n        });\n      }\n    });\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n  react_1.useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      }); // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n\n      const tokenSubID = connection.onProgramAccountChange(programIds_1.programIds().token, info => {\n        // TODO: fix type in web3.js\n        const id = info.accountId; // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n\n        if (info.accountInfo.data.length === spl_token_1.AccountLayout.span) {\n          const data = deserialize_1.deserializeAccount(info.accountInfo.data);\n\n          if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n            cache_1.cache.add(id, info.accountInfo, parsesrs_1.TokenAccountParser);\n            setTokenAccounts(selectUserAccounts());\n          }\n        }\n      }, 'singleGossip');\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n  return react_1.default.createElement(AccountsContext.Provider, {\n    value: {\n      userAccounts,\n      nativeAccount\n    }\n  }, children);\n}\n\nexports.AccountsProvider = AccountsProvider;\n\nfunction useNativeAccount() {\n  const context = react_1.useContext(AccountsContext);\n  return {\n    account: context.nativeAccount\n  };\n}\n\nexports.useNativeAccount = useNativeAccount;\n\nfunction useMint(key) {\n  const connection = connection_1.useConnection();\n  const [mint, setMint] = react_1.useState();\n  const id = typeof key === 'string' ? key : key === null || key === void 0 ? void 0 : key.toBase58();\n  react_1.useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache_1.cache.query(connection, id, parsesrs_1.MintParser).then(acc => setMint(acc.info)).catch(err => console.log(err));\n    const dispose = cache_1.cache.emitter.onCache(e => {\n      const event = e;\n\n      if (event.id === id) {\n        cache_1.cache.query(connection, id, parsesrs_1.MintParser).then(mint => setMint(mint.info));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n  return mint;\n}\n\nexports.useMint = useMint;\n\nfunction useAccount(pubKey) {\n  const connection = connection_1.useConnection();\n  const [account, setAccount] = react_1.useState();\n  const key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();\n  react_1.useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache_1.cache.query(connection, key, parsesrs_1.TokenAccountParser).catch(err => console.log(err));\n\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n    const dispose = cache_1.cache.emitter.onCache(e => {\n      const event = e;\n\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n  return account;\n}\n\nexports.useAccount = useAccount;","map":{"version":3,"sources":["../../../../src/contexts/accounts/accounts.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.useAccount = exports.useMint = exports.useNativeAccount = exports.AccountsProvider = exports.useAccountsContext = void 0;\r\nconst react_1 = __importStar(require(\"react\"));\r\nconst wallet_adapter_react_1 = require(\"@solana/wallet-adapter-react\");\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\nconst spl_token_1 = require(\"@solana/spl-token\");\r\nconst connection_1 = require(\"../../contexts/connection\");\r\nconst ids_1 = require(\"../../utils/ids\");\r\nconst programIds_1 = require(\"../../utils/programIds\");\r\nconst cache_1 = require(\"./cache\");\r\nconst deserialize_1 = require(\"./deserialize\");\r\nconst parsesrs_1 = require(\"./parsesrs\");\r\nconst AccountsContext = react_1.default.createContext(null);\r\nconst useAccountsContext = () => {\r\n    const context = react_1.useContext(AccountsContext);\r\n    return context;\r\n};\r\nexports.useAccountsContext = useAccountsContext;\r\nfunction wrapNativeAccount(pubkey, account) {\r\n    if (!account) {\r\n        return undefined;\r\n    }\r\n    const key = new web3_js_1.PublicKey(pubkey);\r\n    return {\r\n        pubkey: pubkey,\r\n        account,\r\n        info: {\r\n            address: key,\r\n            mint: ids_1.WRAPPED_SOL_MINT,\r\n            owner: key,\r\n            amount: new spl_token_1.u64(account.lamports),\r\n            delegate: null,\r\n            delegatedAmount: new spl_token_1.u64(0),\r\n            isInitialized: true,\r\n            isFrozen: false,\r\n            isNative: true,\r\n            rentExemptReserve: null,\r\n            closeAuthority: null,\r\n        },\r\n    };\r\n}\r\nconst UseNativeAccount = () => {\r\n    const connection = connection_1.useConnection();\r\n    const { publicKey } = wallet_adapter_react_1.useWallet();\r\n    const [nativeAccount, setNativeAccount] = react_1.useState();\r\n    const updateCache = react_1.useCallback(account => {\r\n        if (publicKey) {\r\n            const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\r\n            if (wrapped !== undefined) {\r\n                const id = publicKey.toBase58();\r\n                cache_1.cache.registerParser(id, parsesrs_1.TokenAccountParser);\r\n                cache_1.genericCache.set(id, wrapped);\r\n                cache_1.cache.emitter.raiseCacheUpdated(id, false, parsesrs_1.TokenAccountParser, true);\r\n            }\r\n        }\r\n    }, [publicKey]);\r\n    react_1.useEffect(() => {\r\n        let subId = 0;\r\n        const updateAccount = (account) => {\r\n            if (account) {\r\n                updateCache(account);\r\n                setNativeAccount(account);\r\n            }\r\n        };\r\n        (async () => {\r\n            if (!connection || !publicKey) {\r\n                return;\r\n            }\r\n            const account = await connection.getAccountInfo(publicKey);\r\n            updateAccount(account);\r\n            subId = connection.onAccountChange(publicKey, updateAccount);\r\n        })();\r\n        return () => {\r\n            if (subId) {\r\n                connection.removeAccountChangeListener(subId);\r\n            }\r\n        };\r\n    }, [setNativeAccount, publicKey, connection, updateCache]);\r\n    return { nativeAccount };\r\n};\r\nconst PRECACHED_OWNERS = new Set();\r\nconst precacheUserTokenAccounts = async (connection, owner) => {\r\n    if (!owner) {\r\n        return;\r\n    }\r\n    // used for filtering account updates over websocket\r\n    PRECACHED_OWNERS.add(owner.toBase58());\r\n    // user accounts are updated via ws subscription\r\n    const accounts = await connection.getTokenAccountsByOwner(owner, {\r\n        programId: programIds_1.programIds().token,\r\n    });\r\n    accounts.value.forEach(info => {\r\n        cache_1.cache.add(info.pubkey.toBase58(), info.account, parsesrs_1.TokenAccountParser);\r\n    });\r\n};\r\nfunction AccountsProvider({ children = null }) {\r\n    const connection = connection_1.useConnection();\r\n    const { publicKey } = wallet_adapter_react_1.useWallet();\r\n    const [tokenAccounts, setTokenAccounts] = react_1.useState([]);\r\n    const [userAccounts, setUserAccounts] = react_1.useState([]);\r\n    const { nativeAccount } = UseNativeAccount();\r\n    const walletKey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58();\r\n    const selectUserAccounts = react_1.useCallback(() => {\r\n        return cache_1.cache\r\n            .byParser(parsesrs_1.TokenAccountParser)\r\n            .map(id => cache_1.cache.get(id))\r\n            .filter(a => a && a.info.owner.toBase58() === walletKey)\r\n            .map(a => a);\r\n    }, [walletKey]);\r\n    react_1.useEffect(() => {\r\n        const accounts = selectUserAccounts().filter(a => a !== undefined);\r\n        setUserAccounts(accounts);\r\n    }, [nativeAccount, tokenAccounts, selectUserAccounts]);\r\n    react_1.useEffect(() => {\r\n        const subs = [];\r\n        cache_1.cache.emitter.onCache(args => {\r\n            if (args.isNew && args.isActive) {\r\n                let id = args.id;\r\n                let deserialize = args.parser;\r\n                connection.onAccountChange(new web3_js_1.PublicKey(id), info => {\r\n                    cache_1.cache.add(id, info, deserialize);\r\n                });\r\n            }\r\n        });\r\n        return () => {\r\n            subs.forEach(id => connection.removeAccountChangeListener(id));\r\n        };\r\n    }, [connection]);\r\n    react_1.useEffect(() => {\r\n        if (!connection || !publicKey) {\r\n            setTokenAccounts([]);\r\n        }\r\n        else {\r\n            precacheUserTokenAccounts(connection, publicKey).then(() => {\r\n                setTokenAccounts(selectUserAccounts());\r\n            });\r\n            // This can return different types of accounts: token-account, mint, multisig\r\n            // TODO: web3.js expose ability to filter.\r\n            // this should use only filter syntax to only get accounts that are owned by user\r\n            const tokenSubID = connection.onProgramAccountChange(programIds_1.programIds().token, info => {\r\n                // TODO: fix type in web3.js\r\n                const id = info.accountId;\r\n                // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\r\n                if (info.accountInfo.data.length === spl_token_1.AccountLayout.span) {\r\n                    const data = deserialize_1.deserializeAccount(info.accountInfo.data);\r\n                    if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\r\n                        cache_1.cache.add(id, info.accountInfo, parsesrs_1.TokenAccountParser);\r\n                        setTokenAccounts(selectUserAccounts());\r\n                    }\r\n                }\r\n            }, 'singleGossip');\r\n            return () => {\r\n                connection.removeProgramAccountChangeListener(tokenSubID);\r\n            };\r\n        }\r\n    }, [connection, publicKey, selectUserAccounts]);\r\n    return (react_1.default.createElement(AccountsContext.Provider, { value: {\r\n            userAccounts,\r\n            nativeAccount,\r\n        } }, children));\r\n}\r\nexports.AccountsProvider = AccountsProvider;\r\nfunction useNativeAccount() {\r\n    const context = react_1.useContext(AccountsContext);\r\n    return {\r\n        account: context.nativeAccount,\r\n    };\r\n}\r\nexports.useNativeAccount = useNativeAccount;\r\nfunction useMint(key) {\r\n    const connection = connection_1.useConnection();\r\n    const [mint, setMint] = react_1.useState();\r\n    const id = typeof key === 'string' ? key : key === null || key === void 0 ? void 0 : key.toBase58();\r\n    react_1.useEffect(() => {\r\n        if (!id) {\r\n            return;\r\n        }\r\n        cache_1.cache\r\n            .query(connection, id, parsesrs_1.MintParser)\r\n            .then(acc => setMint(acc.info))\r\n            .catch(err => console.log(err));\r\n        const dispose = cache_1.cache.emitter.onCache(e => {\r\n            const event = e;\r\n            if (event.id === id) {\r\n                cache_1.cache\r\n                    .query(connection, id, parsesrs_1.MintParser)\r\n                    .then(mint => setMint(mint.info));\r\n            }\r\n        });\r\n        return () => {\r\n            dispose();\r\n        };\r\n    }, [connection, id]);\r\n    return mint;\r\n}\r\nexports.useMint = useMint;\r\nfunction useAccount(pubKey) {\r\n    const connection = connection_1.useConnection();\r\n    const [account, setAccount] = react_1.useState();\r\n    const key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();\r\n    react_1.useEffect(() => {\r\n        const query = async () => {\r\n            try {\r\n                if (!key) {\r\n                    return;\r\n                }\r\n                const acc = await cache_1.cache\r\n                    .query(connection, key, parsesrs_1.TokenAccountParser)\r\n                    .catch(err => console.log(err));\r\n                if (acc) {\r\n                    setAccount(acc);\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n        };\r\n        query();\r\n        const dispose = cache_1.cache.emitter.onCache(e => {\r\n            const event = e;\r\n            if (event.id === key) {\r\n                query();\r\n            }\r\n        });\r\n        return () => {\r\n            dispose();\r\n        };\r\n    }, [connection, key]);\r\n    return account;\r\n}\r\nexports.useAccount = useAccount;\r\n//# sourceMappingURL=accounts.js.map"]},"metadata":{},"sourceType":"script"}