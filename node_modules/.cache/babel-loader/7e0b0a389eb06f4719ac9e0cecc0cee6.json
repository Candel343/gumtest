{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processMetaplexAccounts = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst models_1 = require(\"../../models\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst accounts_1 = require(\"../accounts\");\n\nconst userNames_json_1 = __importDefault(require(\"../../config/userNames.json\"));\n\nconst processMetaplexAccounts = async ({\n  account,\n  pubkey\n}, setter) => {\n  if (!isMetaplexAccount(account)) return;\n\n  try {\n    const STORE_ID = utils_1.programIds().store;\n\n    if (isAuctionManagerV1Account(account) || isAuctionManagerV2Account(account)) {\n      const storeKey = new web3_js_1.PublicKey(account.data.slice(1, 33));\n\n      if (STORE_ID && storeKey.equals(STORE_ID)) {\n        const auctionManager = models_1.decodeAuctionManager(account.data);\n        const parsedAccount = {\n          pubkey,\n          account,\n          info: auctionManager\n        };\n        setter('auctionManagersByAuction', auctionManager.auction, parsedAccount);\n      }\n    }\n\n    if (isBidRedemptionTicketV1Account(account) || isBidRedemptionTicketV2Account(account)) {\n      const ticket = models_1.decodeBidRedemptionTicket(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: ticket\n      };\n      setter('bidRedemptions', pubkey, parsedAccount);\n\n      if (ticket.key == models_1.MetaplexKey.BidRedemptionTicketV2) {\n        const asV2 = ticket;\n\n        if (asV2.winnerIndex) {\n          setter('bidRedemptionV2sByAuctionManagerAndWinningIndex', asV2.auctionManager + '-' + asV2.winnerIndex.toNumber(), parsedAccount);\n        }\n      }\n    }\n\n    if (isPayoutTicketV1Account(account)) {\n      const ticket = models_1.decodePayoutTicket(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: ticket\n      };\n      setter('payoutTickets', pubkey, parsedAccount);\n    }\n\n    if (isAuctionCacheV1Account(account)) {\n      const cache = models_1.decodeAuctionCache(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: cache\n      };\n      setter('auctionCaches', pubkey, parsedAccount);\n    }\n\n    if (isStoreIndexerV1Account(account)) {\n      const indexer = models_1.decodeStoreIndexer(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: indexer\n      };\n\n      if (parsedAccount.info.store == (STORE_ID === null || STORE_ID === void 0 ? void 0 : STORE_ID.toBase58())) {\n        setter('storeIndexer', pubkey, parsedAccount);\n      }\n    }\n\n    if (isPrizeTrackingTicketV1Account(account)) {\n      const ticket = models_1.decodePrizeTrackingTicket(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: ticket\n      };\n      setter('prizeTrackingTickets', pubkey, parsedAccount);\n    }\n\n    if (isStoreV1Account(account)) {\n      const store = models_1.decodeStore(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: store\n      };\n\n      if (STORE_ID && pubkey === STORE_ID.toBase58()) {\n        setter('store', pubkey, parsedAccount);\n      }\n    }\n\n    if (isSafetyDepositConfigV1Account(account)) {\n      const config = models_1.decodeSafetyDepositConfig(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: config\n      };\n      setter('safetyDepositConfigsByAuctionManagerAndIndex', config.auctionManager + '-' + config.order.toNumber(), parsedAccount);\n    }\n\n    if (isWhitelistedCreatorV1Account(account)) {\n      const parsedAccount = accounts_1.cache.add(pubkey, account, models_1.WhitelistedCreatorParser, false); // TODO: figure out a way to avoid generating creator addresses during parsing\n      // should we store store id inside creator?\n\n      if (STORE_ID) {\n        const isWhitelistedCreator = await models_1.isCreatorPartOfTheStore(parsedAccount.info.address, pubkey);\n        const nameInfo = userNames_json_1.default[parsedAccount.info.address];\n\n        if (nameInfo) {\n          parsedAccount.info = { ...parsedAccount.info,\n            ...nameInfo\n          };\n        }\n\n        if (isWhitelistedCreator) {\n          setter('whitelistedCreatorsByCreator', parsedAccount.info.address, parsedAccount);\n        }\n      }\n    }\n  } catch {// ignore errors\n    // add type as first byte for easier deserialization\n  }\n};\n\nexports.processMetaplexAccounts = processMetaplexAccounts;\n\nconst isMetaplexAccount = account => account && utils_1.pubkeyToString(account.owner) === utils_1.METAPLEX_ID;\n\nconst isAuctionManagerV1Account = account => account.data[0] === models_1.MetaplexKey.AuctionManagerV1;\n\nconst isAuctionManagerV2Account = account => account.data[0] === models_1.MetaplexKey.AuctionManagerV2;\n\nconst isBidRedemptionTicketV1Account = account => account.data[0] === models_1.MetaplexKey.BidRedemptionTicketV1;\n\nconst isBidRedemptionTicketV2Account = account => account.data[0] === models_1.MetaplexKey.BidRedemptionTicketV2;\n\nconst isPayoutTicketV1Account = account => account.data[0] === models_1.MetaplexKey.PayoutTicketV1;\n\nconst isPrizeTrackingTicketV1Account = account => account.data[0] === models_1.MetaplexKey.PrizeTrackingTicketV1;\n\nconst isStoreV1Account = account => account.data[0] === models_1.MetaplexKey.StoreV1;\n\nconst isSafetyDepositConfigV1Account = account => account.data[0] === models_1.MetaplexKey.SafetyDepositConfigV1;\n\nconst isWhitelistedCreatorV1Account = account => account.data[0] === models_1.MetaplexKey.WhitelistedCreatorV1;\n\nconst isAuctionCacheV1Account = account => account.data[0] === models_1.MetaplexKey.AuctionCacheV1;\n\nconst isStoreIndexerV1Account = account => account.data[0] === models_1.MetaplexKey.StoreIndexerV1;","map":{"version":3,"sources":["../../../../src/contexts/meta/processMetaplexAccounts.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.processMetaplexAccounts = void 0;\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\nconst models_1 = require(\"../../models\");\r\nconst utils_1 = require(\"../../utils\");\r\nconst accounts_1 = require(\"../accounts\");\r\nconst userNames_json_1 = __importDefault(require(\"../../config/userNames.json\"));\r\nconst processMetaplexAccounts = async ({ account, pubkey }, setter) => {\r\n    if (!isMetaplexAccount(account))\r\n        return;\r\n    try {\r\n        const STORE_ID = utils_1.programIds().store;\r\n        if (isAuctionManagerV1Account(account) ||\r\n            isAuctionManagerV2Account(account)) {\r\n            const storeKey = new web3_js_1.PublicKey(account.data.slice(1, 33));\r\n            if (STORE_ID && storeKey.equals(STORE_ID)) {\r\n                const auctionManager = models_1.decodeAuctionManager(account.data);\r\n                const parsedAccount = {\r\n                    pubkey,\r\n                    account,\r\n                    info: auctionManager,\r\n                };\r\n                setter('auctionManagersByAuction', auctionManager.auction, parsedAccount);\r\n            }\r\n        }\r\n        if (isBidRedemptionTicketV1Account(account) ||\r\n            isBidRedemptionTicketV2Account(account)) {\r\n            const ticket = models_1.decodeBidRedemptionTicket(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: ticket,\r\n            };\r\n            setter('bidRedemptions', pubkey, parsedAccount);\r\n            if (ticket.key == models_1.MetaplexKey.BidRedemptionTicketV2) {\r\n                const asV2 = ticket;\r\n                if (asV2.winnerIndex) {\r\n                    setter('bidRedemptionV2sByAuctionManagerAndWinningIndex', asV2.auctionManager + '-' + asV2.winnerIndex.toNumber(), parsedAccount);\r\n                }\r\n            }\r\n        }\r\n        if (isPayoutTicketV1Account(account)) {\r\n            const ticket = models_1.decodePayoutTicket(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: ticket,\r\n            };\r\n            setter('payoutTickets', pubkey, parsedAccount);\r\n        }\r\n        if (isAuctionCacheV1Account(account)) {\r\n            const cache = models_1.decodeAuctionCache(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: cache,\r\n            };\r\n            setter('auctionCaches', pubkey, parsedAccount);\r\n        }\r\n        if (isStoreIndexerV1Account(account)) {\r\n            const indexer = models_1.decodeStoreIndexer(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: indexer,\r\n            };\r\n            if (parsedAccount.info.store == (STORE_ID === null || STORE_ID === void 0 ? void 0 : STORE_ID.toBase58())) {\r\n                setter('storeIndexer', pubkey, parsedAccount);\r\n            }\r\n        }\r\n        if (isPrizeTrackingTicketV1Account(account)) {\r\n            const ticket = models_1.decodePrizeTrackingTicket(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: ticket,\r\n            };\r\n            setter('prizeTrackingTickets', pubkey, parsedAccount);\r\n        }\r\n        if (isStoreV1Account(account)) {\r\n            const store = models_1.decodeStore(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: store,\r\n            };\r\n            if (STORE_ID && pubkey === STORE_ID.toBase58()) {\r\n                setter('store', pubkey, parsedAccount);\r\n            }\r\n        }\r\n        if (isSafetyDepositConfigV1Account(account)) {\r\n            const config = models_1.decodeSafetyDepositConfig(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: config,\r\n            };\r\n            setter('safetyDepositConfigsByAuctionManagerAndIndex', config.auctionManager + '-' + config.order.toNumber(), parsedAccount);\r\n        }\r\n        if (isWhitelistedCreatorV1Account(account)) {\r\n            const parsedAccount = accounts_1.cache.add(pubkey, account, models_1.WhitelistedCreatorParser, false);\r\n            // TODO: figure out a way to avoid generating creator addresses during parsing\r\n            // should we store store id inside creator?\r\n            if (STORE_ID) {\r\n                const isWhitelistedCreator = await models_1.isCreatorPartOfTheStore(parsedAccount.info.address, pubkey);\r\n                const nameInfo = userNames_json_1.default[parsedAccount.info.address];\r\n                if (nameInfo) {\r\n                    parsedAccount.info = { ...parsedAccount.info, ...nameInfo };\r\n                }\r\n                if (isWhitelistedCreator) {\r\n                    setter('whitelistedCreatorsByCreator', parsedAccount.info.address, parsedAccount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        // ignore errors\r\n        // add type as first byte for easier deserialization\r\n    }\r\n};\r\nexports.processMetaplexAccounts = processMetaplexAccounts;\r\nconst isMetaplexAccount = (account) => account && utils_1.pubkeyToString(account.owner) === utils_1.METAPLEX_ID;\r\nconst isAuctionManagerV1Account = (account) => account.data[0] === models_1.MetaplexKey.AuctionManagerV1;\r\nconst isAuctionManagerV2Account = (account) => account.data[0] === models_1.MetaplexKey.AuctionManagerV2;\r\nconst isBidRedemptionTicketV1Account = (account) => account.data[0] === models_1.MetaplexKey.BidRedemptionTicketV1;\r\nconst isBidRedemptionTicketV2Account = (account) => account.data[0] === models_1.MetaplexKey.BidRedemptionTicketV2;\r\nconst isPayoutTicketV1Account = (account) => account.data[0] === models_1.MetaplexKey.PayoutTicketV1;\r\nconst isPrizeTrackingTicketV1Account = (account) => account.data[0] === models_1.MetaplexKey.PrizeTrackingTicketV1;\r\nconst isStoreV1Account = (account) => account.data[0] === models_1.MetaplexKey.StoreV1;\r\nconst isSafetyDepositConfigV1Account = (account) => account.data[0] === models_1.MetaplexKey.SafetyDepositConfigV1;\r\nconst isWhitelistedCreatorV1Account = (account) => account.data[0] === models_1.MetaplexKey.WhitelistedCreatorV1;\r\nconst isAuctionCacheV1Account = (account) => account.data[0] === models_1.MetaplexKey.AuctionCacheV1;\r\nconst isStoreIndexerV1Account = (account) => account.data[0] === models_1.MetaplexKey.StoreIndexerV1;\r\n//# sourceMappingURL=processMetaplexAccounts.js.map"]},"metadata":{},"sourceType":"script"}