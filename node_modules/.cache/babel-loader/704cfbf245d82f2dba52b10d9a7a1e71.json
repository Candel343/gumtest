{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processMetaData = void 0;\n\nconst isValidHttpUrl_1 = require(\"../../utils/isValidHttpUrl\");\n\nconst actions_1 = require(\"../../actions\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst processMetaData = async ({\n  account,\n  pubkey\n}, setter) => {\n  if (!isMetadataAccount(account)) return;\n\n  try {\n    if (isMetadataV1Account(account)) {\n      const metadata = actions_1.decodeMetadata(account.data);\n\n      if (isValidHttpUrl_1.isValidHttpUrl(metadata.data.uri) && metadata.data.uri.indexOf('arweave') >= 0) {\n        const parsedAccount = {\n          pubkey,\n          account,\n          info: metadata\n        };\n        await setter('metadataByMint', metadata.mint, parsedAccount);\n        await setter('metadataByMetadata', pubkey, parsedAccount);\n      }\n    }\n\n    if (isEditionV1Account(account)) {\n      const edition = actions_1.decodeEdition(account.data);\n      const parsedAccount = {\n        pubkey,\n        account,\n        info: edition\n      };\n      setter('editions', pubkey, parsedAccount);\n    }\n\n    if (isMasterEditionAccount(account)) {\n      const masterEdition = actions_1.decodeMasterEdition(account.data);\n\n      if (isMasterEditionV1(masterEdition)) {\n        const parsedAccount = {\n          pubkey,\n          account,\n          info: masterEdition\n        };\n        setter('masterEditions', pubkey, parsedAccount);\n        setter('masterEditionsByPrintingMint', masterEdition.printingMint, parsedAccount);\n        setter('masterEditionsByOneTimeAuthMint', masterEdition.oneTimePrintingAuthorizationMint, parsedAccount);\n      } else {\n        const parsedAccount = {\n          pubkey,\n          account,\n          info: masterEdition\n        };\n        setter('masterEditions', pubkey, parsedAccount);\n      }\n    }\n  } catch {// ignore errors\n    // add type as first byte for easier deserialization\n  }\n};\n\nexports.processMetaData = processMetaData;\n\nconst isMetadataAccount = account => account && utils_1.pubkeyToString(account.owner) === utils_1.METADATA_PROGRAM_ID;\n\nconst isMetadataV1Account = account => account.data[0] === actions_1.MetadataKey.MetadataV1;\n\nconst isEditionV1Account = account => account.data[0] === actions_1.MetadataKey.EditionV1;\n\nconst isMasterEditionAccount = account => account.data[0] === actions_1.MetadataKey.MasterEditionV1 || account.data[0] === actions_1.MetadataKey.MasterEditionV2;\n\nconst isMasterEditionV1 = me => {\n  return me.key === actions_1.MetadataKey.MasterEditionV1;\n};","map":{"version":3,"sources":["../../../../src/contexts/meta/processMetaData.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.processMetaData = void 0;\r\nconst isValidHttpUrl_1 = require(\"../../utils/isValidHttpUrl\");\r\nconst actions_1 = require(\"../../actions\");\r\nconst utils_1 = require(\"../../utils\");\r\nconst processMetaData = async ({ account, pubkey }, setter) => {\r\n    if (!isMetadataAccount(account))\r\n        return;\r\n    try {\r\n        if (isMetadataV1Account(account)) {\r\n            const metadata = actions_1.decodeMetadata(account.data);\r\n            if (isValidHttpUrl_1.isValidHttpUrl(metadata.data.uri) &&\r\n                metadata.data.uri.indexOf('arweave') >= 0) {\r\n                const parsedAccount = {\r\n                    pubkey,\r\n                    account,\r\n                    info: metadata,\r\n                };\r\n                await setter('metadataByMint', metadata.mint, parsedAccount);\r\n                await setter('metadataByMetadata', pubkey, parsedAccount);\r\n            }\r\n        }\r\n        if (isEditionV1Account(account)) {\r\n            const edition = actions_1.decodeEdition(account.data);\r\n            const parsedAccount = {\r\n                pubkey,\r\n                account,\r\n                info: edition,\r\n            };\r\n            setter('editions', pubkey, parsedAccount);\r\n        }\r\n        if (isMasterEditionAccount(account)) {\r\n            const masterEdition = actions_1.decodeMasterEdition(account.data);\r\n            if (isMasterEditionV1(masterEdition)) {\r\n                const parsedAccount = {\r\n                    pubkey,\r\n                    account,\r\n                    info: masterEdition,\r\n                };\r\n                setter('masterEditions', pubkey, parsedAccount);\r\n                setter('masterEditionsByPrintingMint', masterEdition.printingMint, parsedAccount);\r\n                setter('masterEditionsByOneTimeAuthMint', masterEdition.oneTimePrintingAuthorizationMint, parsedAccount);\r\n            }\r\n            else {\r\n                const parsedAccount = {\r\n                    pubkey,\r\n                    account,\r\n                    info: masterEdition,\r\n                };\r\n                setter('masterEditions', pubkey, parsedAccount);\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        // ignore errors\r\n        // add type as first byte for easier deserialization\r\n    }\r\n};\r\nexports.processMetaData = processMetaData;\r\nconst isMetadataAccount = (account) => account && utils_1.pubkeyToString(account.owner) === utils_1.METADATA_PROGRAM_ID;\r\nconst isMetadataV1Account = (account) => account.data[0] === actions_1.MetadataKey.MetadataV1;\r\nconst isEditionV1Account = (account) => account.data[0] === actions_1.MetadataKey.EditionV1;\r\nconst isMasterEditionAccount = (account) => account.data[0] === actions_1.MetadataKey.MasterEditionV1 ||\r\n    account.data[0] === actions_1.MetadataKey.MasterEditionV2;\r\nconst isMasterEditionV1 = (me) => {\r\n    return me.key === actions_1.MetadataKey.MasterEditionV1;\r\n};\r\n//# sourceMappingURL=processMetaData.js.map"]},"metadata":{},"sourceType":"script"}