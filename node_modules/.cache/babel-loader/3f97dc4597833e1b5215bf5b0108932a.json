{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeResAccounts = exports.unsafeAccount = exports.getProgramAccounts = void 0;\n\nasync function getProgramAccounts(connection, programId, configOrCommitment) {\n  const extra = {};\n  let commitment; //let encoding;\n\n  if (configOrCommitment) {\n    if (typeof configOrCommitment === 'string') {\n      commitment = configOrCommitment;\n    } else {\n      commitment = configOrCommitment.commitment; //encoding = configOrCommitment.encoding;\n\n      if (configOrCommitment.dataSlice) {\n        extra.dataSlice = configOrCommitment.dataSlice;\n      }\n\n      if (configOrCommitment.filters) {\n        extra.filters = configOrCommitment.filters;\n      }\n    }\n  }\n\n  const args = connection._buildArgs([programId], commitment, 'base64', extra);\n\n  const unsafeRes = await connection._rpcRequest('getProgramAccounts', args);\n  return unsafeResAccounts(unsafeRes.result);\n}\n\nexports.getProgramAccounts = getProgramAccounts;\n\nfunction unsafeAccount(account) {\n  return {\n    // TODO: possible delay parsing could be added here\n    data: Buffer.from(account.data[0], 'base64'),\n    executable: account.executable,\n    lamports: account.lamports,\n    // TODO: maybe we can do it in lazy way? or just use string\n    owner: account.owner\n  };\n}\n\nexports.unsafeAccount = unsafeAccount;\n\nfunction unsafeResAccounts(data) {\n  return data.map(item => ({\n    account: unsafeAccount(item.account),\n    pubkey: item.pubkey\n  }));\n}\n\nexports.unsafeResAccounts = unsafeResAccounts;","map":{"version":3,"sources":["../../../../src/contexts/meta/web3.ts"],"names":[],"mappings":";;;;;;;AAIO,eAAe,kBAAf,CACL,UADK,EAEL,SAFK,EAGL,kBAHK,EAGmB;AAExB,QAAM,KAAK,GAAQ,EAAnB;AACA,MAAI,UAAJ,CAHwB,CAIxB;;AAEA,MAAI,kBAAJ,EAAwB;AACtB,QAAI,OAAO,kBAAP,KAA8B,QAAlC,EAA4C;AAC1C,MAAA,UAAU,GAAG,kBAAb;AACD,KAFD,MAEO;AACL,MAAA,UAAU,GAAG,kBAAkB,CAAC,UAAhC,CADK,CAEL;;AAEA,UAAI,kBAAkB,CAAC,SAAvB,EAAkC;AAChC,QAAA,KAAK,CAAC,SAAN,GAAkB,kBAAkB,CAAC,SAArC;AACD;;AAED,UAAI,kBAAkB,CAAC,OAAvB,EAAgC;AAC9B,QAAA,KAAK,CAAC,OAAN,GAAgB,kBAAkB,CAAC,OAAnC;AACD;AACF;AACF;;AAED,QAAM,IAAI,GAAG,UAAU,CAAC,UAAX,CAAsB,CAAC,SAAD,CAAtB,EAAmC,UAAnC,EAA+C,QAA/C,EAAyD,KAAzD,CAAb;;AACA,QAAM,SAAS,GAAG,MAAO,UAAkB,CAAC,WAAnB,CACvB,oBADuB,EAEvB,IAFuB,CAAzB;AAKA,SAAO,iBAAiB,CAAC,SAAS,CAAC,MAAX,CAAxB;AACD;;AAjCD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAmCA,SAAgB,aAAhB,CAA8B,OAA9B,EAAoE;AAClE,SAAO;AACL;AACA,IAAA,IAAI,EAAE,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,IAAR,CAAa,CAAb,CAAZ,EAA6B,QAA7B,CAFD;AAGL,IAAA,UAAU,EAAE,OAAO,CAAC,UAHf;AAIL,IAAA,QAAQ,EAAE,OAAO,CAAC,QAJb;AAKL;AACA,IAAA,KAAK,EAAE,OAAO,CAAC;AANV,GAAP;AAQD;;AATD,OAAA,CAAA,aAAA,GAAA,aAAA;;AAWA,SAAgB,iBAAhB,CACE,IADF,EAII;AAEF,SAAO,IAAI,CAAC,GAAL,CAAS,IAAI,KAAK;AACvB,IAAA,OAAO,EAAE,aAAa,CAAC,IAAI,CAAC,OAAN,CADC;AAEvB,IAAA,MAAM,EAAE,IAAI,CAAC;AAFU,GAAL,CAAb,CAAP;AAID;;AAVD,OAAA,CAAA,iBAAA,GAAA,iBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.unsafeResAccounts = exports.unsafeAccount = exports.getProgramAccounts = void 0;\r\nasync function getProgramAccounts(connection, programId, configOrCommitment) {\r\n    const extra = {};\r\n    let commitment;\r\n    //let encoding;\r\n    if (configOrCommitment) {\r\n        if (typeof configOrCommitment === 'string') {\r\n            commitment = configOrCommitment;\r\n        }\r\n        else {\r\n            commitment = configOrCommitment.commitment;\r\n            //encoding = configOrCommitment.encoding;\r\n            if (configOrCommitment.dataSlice) {\r\n                extra.dataSlice = configOrCommitment.dataSlice;\r\n            }\r\n            if (configOrCommitment.filters) {\r\n                extra.filters = configOrCommitment.filters;\r\n            }\r\n        }\r\n    }\r\n    const args = connection._buildArgs([programId], commitment, 'base64', extra);\r\n    const unsafeRes = await connection._rpcRequest('getProgramAccounts', args);\r\n    return unsafeResAccounts(unsafeRes.result);\r\n}\r\nexports.getProgramAccounts = getProgramAccounts;\r\nfunction unsafeAccount(account) {\r\n    return {\r\n        // TODO: possible delay parsing could be added here\r\n        data: Buffer.from(account.data[0], 'base64'),\r\n        executable: account.executable,\r\n        lamports: account.lamports,\r\n        // TODO: maybe we can do it in lazy way? or just use string\r\n        owner: account.owner,\r\n    };\r\n}\r\nexports.unsafeAccount = unsafeAccount;\r\nfunction unsafeResAccounts(data) {\r\n    return data.map(item => ({\r\n        account: unsafeAccount(item.account),\r\n        pubkey: item.pubkey,\r\n    }));\r\n}\r\nexports.unsafeResAccounts = unsafeResAccounts;\r\n//# sourceMappingURL=web3.js.map"]},"metadata":{},"sourceType":"script"}