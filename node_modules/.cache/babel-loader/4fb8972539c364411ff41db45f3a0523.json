{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initMetadata = exports.metadataByMintUpdater = exports.processingAccounts = exports.makeSetter = exports.loadAccounts = exports.limitedLoadAccounts = exports.pullPage = exports.pullPages = exports.pullAuctionSubaccounts = exports.pullPayoutTickets = exports.pullYourMetadata = exports.pullStoreMetadata = exports.USE_SPEED_RUN = void 0;\n\nconst ids_1 = require(\"../../utils/ids\");\n\nconst models_1 = require(\"../../models\");\n\nconst actions_1 = require(\"../../actions\");\n\nconst lodash_1 = require(\"lodash\");\n\nconst metaplex_1 = require(\"../../models/metaplex\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst isMetadataPartOfStore_1 = require(\"./isMetadataPartOfStore\");\n\nconst processAuctions_1 = require(\"./processAuctions\");\n\nconst processMetaplexAccounts_1 = require(\"./processMetaplexAccounts\");\n\nconst processMetaData_1 = require(\"./processMetaData\");\n\nconst processVaultData_1 = require(\"./processVaultData\");\n\nconst getEmptyMetaState_1 = require(\"./getEmptyMetaState\");\n\nconst getMultipleAccounts_1 = require(\"../accounts/getMultipleAccounts\");\n\nconst web3_1 = require(\"./web3\");\n\nconst createPipelineExecutor_1 = require(\"../../utils/createPipelineExecutor\");\n\nconst __1 = require(\"../..\");\n\nconst MULTIPLE_ACCOUNT_BATCH_SIZE = 100;\nexports.USE_SPEED_RUN = false;\nconst WHITELISTED_METADATA = ['98vYFjBYS9TguUMWQRPjy2SZuxKuUMcqR4vnQiLjZbte'];\nconst WHITELISTED_AUCTION = ['D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e'];\nconst AUCTION_TO_METADATA = {\n  D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e: ['98vYFjBYS9TguUMWQRPjy2SZuxKuUMcqR4vnQiLjZbte']\n};\nconst AUCTION_TO_VAULT = {\n  D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e: '3wHCBd3fYRPWjd5GqzrXanLJUKRyU3nECKbTPKfVwcFX'\n};\nconst WHITELISTED_AUCTION_MANAGER = ['3HD2C8oCL8dpqbXo8hq3CMw6tRSZDZJGajLxnrZ3ZkYx'];\nconst WHITELISTED_VAULT = ['3wHCBd3fYRPWjd5GqzrXanLJUKRyU3nECKbTPKfVwcFX'];\n\nconst pullStoreMetadata = async (connection, tempCache) => {\n  const updateTemp = exports.makeSetter(tempCache);\n\n  const loadMetadata = () => pullMetadataByCreators(connection, tempCache, updateTemp);\n\n  const loadEditions = () => pullEditions(connection, updateTemp, tempCache, tempCache.metadata);\n\n  console.log('-------->Loading all metadata for store.');\n  await loadMetadata();\n  await loadEditions();\n  await postProcessMetadata(tempCache);\n  console.log('-------->Metadata processing complete.');\n  return tempCache;\n};\n\nexports.pullStoreMetadata = pullStoreMetadata;\n\nconst pullYourMetadata = async (connection, userTokenAccounts, tempCache) => {\n  const updateTemp = exports.makeSetter(tempCache);\n  console.log('--------->Pulling metadata for user.');\n  let currBatch = [];\n  let batches = [];\n  const editions = [];\n\n  for (let i = 0; i < userTokenAccounts.length; i++) {\n    if (userTokenAccounts[i].info.amount.toNumber() == 1) {\n      if (2 + currBatch.length > MULTIPLE_ACCOUNT_BATCH_SIZE) {\n        batches.push(currBatch);\n        currBatch = [];\n      } else {\n        const edition = await actions_1.getEdition(userTokenAccounts[i].info.mint.toBase58());\n        const newAdd = [await actions_1.getMetadata(userTokenAccounts[i].info.mint.toBase58()), edition];\n        editions.push(edition);\n        currBatch = currBatch.concat(newAdd);\n      }\n    }\n  }\n\n  if (currBatch.length > 0 && currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {\n    batches.push(currBatch);\n  }\n\n  console.log('------> From token accounts for user', 'produced', batches.length, 'batches of accounts to pull');\n\n  for (let i = 0; i < batches.length; i++) {\n    const accounts = await getMultipleAccounts_1.getMultipleAccounts(connection, batches[i], 'single');\n\n    if (accounts) {\n      console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');\n\n      for (let j = 0; j < accounts.keys.length; j++) {\n        const pubkey = accounts.keys[j];\n        await processMetaData_1.processMetaData({\n          pubkey,\n          account: accounts.array[j]\n        }, updateTemp);\n      }\n    } else {\n      console.log('------->Failed to pull batch', i, 'skipping');\n    }\n  }\n\n  console.log('------> Pulling master editions for user');\n  currBatch = [];\n  batches = [];\n\n  for (let i = 0; i < editions.length; i++) {\n    if (1 + currBatch.length > MULTIPLE_ACCOUNT_BATCH_SIZE) {\n      batches.push(currBatch);\n      currBatch = [];\n    } else if (tempCache.editions[editions[i]]) {\n      currBatch.push(tempCache.editions[editions[i]].info.parent);\n    }\n  }\n\n  if (currBatch.length > 0 && currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {\n    batches.push(currBatch);\n  }\n\n  console.log('------> From token accounts for user', 'produced', batches.length, 'batches of accounts to pull');\n\n  for (let i = 0; i < batches.length; i++) {\n    const accounts = await getMultipleAccounts_1.getMultipleAccounts(connection, batches[i], 'single');\n\n    if (accounts) {\n      console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');\n\n      for (let j = 0; j < accounts.keys.length; j++) {\n        const pubkey = accounts.keys[j];\n        await processMetaData_1.processMetaData({\n          pubkey,\n          account: accounts.array[j]\n        }, updateTemp);\n      }\n    } else {\n      console.log('------->Failed to pull batch', i, 'skipping');\n    }\n  }\n\n  await postProcessMetadata(tempCache);\n  console.log('-------->User metadata processing complete.');\n  return tempCache;\n};\n\nexports.pullYourMetadata = pullYourMetadata;\n\nconst pullPayoutTickets = async (connection, tempCache) => {\n  const updateTemp = exports.makeSetter(tempCache);\n\n  const forEach = fn => async accounts => {\n    for (const account of accounts) {\n      await fn(account, updateTemp);\n    }\n  };\n\n  web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      dataSize: metaplex_1.MAX_PAYOUT_TICKET_SIZE\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));\n  return tempCache;\n};\n\nexports.pullPayoutTickets = pullPayoutTickets;\n\nconst pullAuctionSubaccounts = async (connection, auction, tempCache) => {\n  var _a;\n\n  const updateTemp = exports.makeSetter(tempCache);\n  let cacheKey;\n\n  try {\n    cacheKey = await metaplex_1.getAuctionCache(auction);\n  } catch (e) {\n    console.log(e);\n    console.log('Failed to get auction cache key');\n    return tempCache;\n  }\n\n  const cache = (_a = tempCache.auctionCaches[cacheKey]) === null || _a === void 0 ? void 0 : _a.info;\n\n  if (!cache) {\n    console.log('-----> No auction cache exists for', auction, 'returning');\n    return tempCache;\n  }\n\n  const forEach = fn => async accounts => {\n    for (const account of accounts) {\n      await fn(account, updateTemp);\n    }\n  };\n\n  const auctionExtKey = await actions_1.getAuctionExtended({\n    auctionProgramId: ids_1.AUCTION_ID,\n    resource: cache.vault\n  });\n  const promises = [// pull editions\n  pullEditions(connection, updateTemp, tempCache, cache.metadata.map(m => tempCache.metadataByMetadata[m])), // pull auction data ext\n  connection.getAccountInfo(ids_1.toPublicKey(auctionExtKey)).then(a => a ? processAuctions_1.processAuctions({\n    pubkey: auctionExtKey,\n    account: a\n  }, updateTemp) : null), // bidder metadata pull\n  web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\n    filters: [{\n      memcmp: {\n        offset: 32,\n        bytes: auction\n      }\n    }]\n  }).then(forEach(processAuctions_1.processAuctions)), // bidder pot pull\n  web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\n    filters: [{\n      memcmp: {\n        offset: 64,\n        bytes: auction\n      }\n    }]\n  }).then(forEach(processAuctions_1.processAuctions)), // safety deposit pull\n  web3_1.getProgramAccounts(connection, ids_1.VAULT_ID, {\n    filters: [{\n      memcmp: {\n        offset: 1,\n        bytes: cache.vault\n      }\n    }]\n  }).then(forEach(processVaultData_1.processVaultData)), // bid redemptions\n  ...WHITELISTED_AUCTION_MANAGER.map(() => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      memcmp: {\n        offset: 9,\n        bytes: cache.auctionManager\n      }\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))), // safety deposit configs\n  web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      memcmp: {\n        offset: 1,\n        bytes: cache.auctionManager\n      }\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)), // prize tracking tickets\n  ...cache.metadata.map(md => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      memcmp: {\n        offset: 1,\n        bytes: md\n      }\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))).flat()];\n  await Promise.all(promises);\n  console.log('---------->Pulled sub accounts for auction', auction);\n  return tempCache;\n};\n\nexports.pullAuctionSubaccounts = pullAuctionSubaccounts;\n\nconst pullPages = async connection => {\n  let i = 0;\n  let pageKey = await metaplex_1.getStoreIndexer(i);\n  let account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));\n  const pages = [];\n\n  while (account) {\n    pages.push({\n      info: metaplex_1.decodeStoreIndexer(account.data),\n      pubkey: pageKey,\n      account\n    });\n    i++;\n    pageKey = await metaplex_1.getStoreIndexer(i);\n    account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));\n  }\n\n  return pages;\n};\n\nexports.pullPages = pullPages;\n\nconst pullPage = async (connection, page, tempCache) => {\n  const updateTemp = exports.makeSetter(tempCache);\n\n  const forEach = fn => async accounts => {\n    for (const account of accounts) {\n      await fn(account, updateTemp);\n    }\n  };\n\n  const pageKey = await metaplex_1.getStoreIndexer(page);\n  const account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));\n\n  if (account) {\n    processMetaplexAccounts_1.processMetaplexAccounts({\n      pubkey: pageKey,\n      account\n    }, updateTemp);\n    const newPage = tempCache.storeIndexer.find(s => s.pubkey == pageKey);\n    const auctionCaches = await getMultipleAccounts_1.getMultipleAccounts(connection, (newPage === null || newPage === void 0 ? void 0 : newPage.info.auctionCaches) || [], 'single');\n\n    if (auctionCaches && auctionCaches.keys.length) {\n      console.log('-------->Page ', page, ' found', auctionCaches.keys.length, ' cached auction data');\n      auctionCaches.keys.map((pubkey, i) => {\n        processMetaplexAccounts_1.processMetaplexAccounts({\n          pubkey,\n          account: auctionCaches.array[i]\n        }, updateTemp);\n      });\n      const batches = [];\n      let currBatch = [];\n\n      for (let i = 0; i < auctionCaches.keys.length; i++) {\n        const cache = tempCache.auctionCaches[auctionCaches.keys[i]];\n        const totalNewAccountsToAdd = cache.info.metadata.length + 3;\n\n        if (totalNewAccountsToAdd + currBatch.length > MULTIPLE_ACCOUNT_BATCH_SIZE) {\n          batches.push(currBatch);\n          currBatch = [];\n        } else {\n          const newAdd = [...cache.info.metadata, cache.info.auction, cache.info.auctionManager, cache.info.vault];\n          currBatch = currBatch.concat(newAdd);\n        }\n      }\n\n      if (currBatch.length > 0 && currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {\n        batches.push(currBatch);\n      }\n\n      console.log('------> From account caches for page', page, 'produced', batches.length, 'batches of accounts to pull');\n\n      for (let i = 0; i < batches.length; i++) {\n        const accounts = await getMultipleAccounts_1.getMultipleAccounts(connection, batches[i], 'single');\n\n        if (accounts) {\n          console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');\n\n          for (let i = 0; i < accounts.keys.length; i++) {\n            const pubkey = accounts.keys[i];\n            await processMetaplexAccounts_1.processMetaplexAccounts({\n              pubkey,\n              account: accounts.array[i]\n            }, updateTemp);\n            await processVaultData_1.processVaultData({\n              pubkey,\n              account: accounts.array[i]\n            }, updateTemp);\n            await processMetaData_1.processMetaData({\n              pubkey,\n              account: accounts.array[i]\n            }, updateTemp);\n            await processAuctions_1.processAuctions({\n              pubkey,\n              account: accounts.array[i]\n            }, updateTemp);\n          }\n        } else {\n          console.log('------->Failed to pull batch', i, 'skipping');\n        }\n      }\n\n      for (let i = 0; i < auctionCaches.keys.length; i++) {\n        const auctionCache = tempCache.auctionCaches[auctionCaches.keys[i]];\n        const metadata = auctionCache.info.metadata.map(s => tempCache.metadataByMetadata[s]);\n        tempCache.metadataByAuction[auctionCache.info.auction] = metadata;\n      }\n    }\n\n    if (page == 0) {\n      console.log('-------->Page 0, pulling creators and store');\n      await web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n        filters: [{\n          dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE\n        }]\n      }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));\n\n      const store = __1.programIds().store;\n\n      if (store) {\n        const storeAcc = await connection.getAccountInfo(store);\n\n        if (storeAcc) {\n          await processMetaplexAccounts_1.processMetaplexAccounts({\n            pubkey: store.toBase58(),\n            account: storeAcc\n          }, updateTemp);\n        }\n      }\n    }\n\n    await postProcessMetadata(tempCache);\n  }\n\n  return tempCache;\n};\n\nexports.pullPage = pullPage;\n\nconst limitedLoadAccounts = async connection => {\n  const tempCache = getEmptyMetaState_1.getEmptyMetaState();\n  const updateTemp = exports.makeSetter(tempCache);\n\n  const forEach = fn => async accounts => {\n    for (const account of accounts) {\n      await fn(account, updateTemp);\n    }\n  };\n\n  const pullMetadata = async metadata => {\n    const mdKey = new web3_js_1.PublicKey(metadata);\n    const md = await connection.getAccountInfo(mdKey);\n    const mdObject = actions_1.decodeMetadata(Buffer.from((md === null || md === void 0 ? void 0 : md.data) || new Uint8Array([])));\n    const editionKey = await actions_1.getEdition(mdObject.mint);\n    const editionData = await connection.getAccountInfo(new web3_js_1.PublicKey(editionKey));\n\n    if (md) {\n      //@ts-ignore\n      md.owner = md.owner.toBase58();\n      processMetaData_1.processMetaData({\n        pubkey: metadata,\n        account: md\n      }, updateTemp);\n\n      if (editionData) {\n        //@ts-ignore\n        editionData.owner = editionData.owner.toBase58();\n        processMetaData_1.processMetaData({\n          pubkey: editionKey,\n          account: editionData\n        }, updateTemp);\n      }\n    }\n  };\n\n  const pullAuction = async auction => {\n    const auctionExtendedKey = await actions_1.getAuctionExtended({\n      auctionProgramId: ids_1.AUCTION_ID,\n      resource: AUCTION_TO_VAULT[auction]\n    });\n    const auctionData = await getMultipleAccounts_1.getMultipleAccounts(connection, [auction, auctionExtendedKey], 'single');\n\n    if (auctionData) {\n      auctionData.keys.map((pubkey, i) => {\n        processAuctions_1.processAuctions({\n          pubkey,\n          account: auctionData.array[i]\n        }, updateTemp);\n      });\n    }\n  };\n\n  const pullAuctionManager = async auctionManager => {\n    const auctionManagerKey = new web3_js_1.PublicKey(auctionManager);\n    const auctionManagerData = await connection.getAccountInfo(auctionManagerKey);\n\n    if (auctionManagerData) {\n      //@ts-ignore\n      auctionManagerData.owner = auctionManagerData.owner.toBase58();\n      processMetaplexAccounts_1.processMetaplexAccounts({\n        pubkey: auctionManager,\n        account: auctionManagerData\n      }, updateTemp);\n    }\n  };\n\n  const pullVault = async vault => {\n    const vaultKey = new web3_js_1.PublicKey(vault);\n    const vaultData = await connection.getAccountInfo(vaultKey);\n\n    if (vaultData) {\n      //@ts-ignore\n      vaultData.owner = vaultData.owner.toBase58();\n      processVaultData_1.processVaultData({\n        pubkey: vault,\n        account: vaultData\n      }, updateTemp);\n    }\n  };\n\n  const promises = [...WHITELISTED_METADATA.map(md => pullMetadata(md)), ...WHITELISTED_AUCTION.map(a => pullAuction(a)), ...WHITELISTED_AUCTION_MANAGER.map(a => pullAuctionManager(a)), ...WHITELISTED_VAULT.map(a => pullVault(a)), // bidder metadata pull\n  ...WHITELISTED_AUCTION.map(a => web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\n    filters: [{\n      memcmp: {\n        offset: 32,\n        bytes: a\n      }\n    }]\n  }).then(forEach(processAuctions_1.processAuctions))), // bidder pot pull\n  ...WHITELISTED_AUCTION.map(a => web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\n    filters: [{\n      memcmp: {\n        offset: 64,\n        bytes: a\n      }\n    }]\n  }).then(forEach(processAuctions_1.processAuctions))), // safety deposit pull\n  ...WHITELISTED_VAULT.map(v => web3_1.getProgramAccounts(connection, ids_1.VAULT_ID, {\n    filters: [{\n      memcmp: {\n        offset: 1,\n        bytes: v\n      }\n    }]\n  }).then(forEach(processVaultData_1.processVaultData))), // bid redemptions\n  ...WHITELISTED_AUCTION_MANAGER.map(a => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      memcmp: {\n        offset: 9,\n        bytes: a\n      }\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))), // safety deposit configs\n  ...WHITELISTED_AUCTION_MANAGER.map(a => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      memcmp: {\n        offset: 1,\n        bytes: a\n      }\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))), // prize tracking tickets\n  ...Object.keys(AUCTION_TO_METADATA).map(key => AUCTION_TO_METADATA[key].map(md => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      memcmp: {\n        offset: 1,\n        bytes: md\n      }\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))).flat()).flat(), // whitelisted creators\n  web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))];\n  await Promise.all(promises);\n  await postProcessMetadata(tempCache);\n  return tempCache;\n};\n\nexports.limitedLoadAccounts = limitedLoadAccounts;\n\nconst loadAccounts = async connection => {\n  const state = getEmptyMetaState_1.getEmptyMetaState();\n  const updateState = exports.makeSetter(state);\n  const forEachAccount = exports.processingAccounts(updateState);\n\n  const forEach = fn => async accounts => {\n    for (const account of accounts) {\n      await fn(account, updateState);\n    }\n  };\n\n  const loadVaults = () => web3_1.getProgramAccounts(connection, ids_1.VAULT_ID).then(forEachAccount(processVaultData_1.processVaultData));\n\n  const loadAuctions = () => web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID).then(forEachAccount(processAuctions_1.processAuctions));\n\n  const loadMetaplex = () => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID).then(forEachAccount(processMetaplexAccounts_1.processMetaplexAccounts));\n\n  const loadCreators = () => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\n    filters: [{\n      dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE\n    }]\n  }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));\n\n  const loadMetadata = () => pullMetadataByCreators(connection, state, updateState);\n\n  const loadEditions = () => pullEditions(connection, updateState, state, state.metadata);\n\n  const loading = [loadCreators().then(loadMetadata).then(loadEditions), loadVaults(), loadAuctions(), loadMetaplex()];\n  await Promise.all(loading);\n  state.metadata = lodash_1.uniqWith(state.metadata, (a, b) => a.pubkey === b.pubkey);\n  return state;\n};\n\nexports.loadAccounts = loadAccounts;\n\nconst pullEditions = async (connection, updater, state, metadataArr) => {\n  console.log('Pulling editions for optimized metadata');\n  let setOf100MetadataEditionKeys = [];\n  const editionPromises = [];\n\n  const loadBatch = () => {\n    editionPromises.push(getMultipleAccounts_1.getMultipleAccounts(connection, setOf100MetadataEditionKeys, 'recent').then(processEditions));\n    setOf100MetadataEditionKeys = [];\n  };\n\n  const processEditions = returnedAccounts => {\n    for (let j = 0; j < returnedAccounts.array.length; j++) {\n      processMetaData_1.processMetaData({\n        pubkey: returnedAccounts.keys[j],\n        account: returnedAccounts.array[j]\n      }, updater);\n    }\n  };\n\n  for (const metadata of metadataArr) {\n    // let editionKey: StringPublicKey;\n    // TODO the nonce builder isnt working here, figure out why\n    //if (metadata.info.editionNonce === null) {\n    const editionKey = await actions_1.getEdition(metadata.info.mint);\n    /*} else {\r\n      editionKey = (\r\n        await PublicKey.createProgramAddress(\r\n          [\r\n            Buffer.from(METADATA_PREFIX),\r\n            toPublicKey(METADATA_PROGRAM_ID).toBuffer(),\r\n            toPublicKey(metadata.info.mint).toBuffer(),\r\n            new Uint8Array([metadata.info.editionNonce || 0]),\r\n          ],\r\n          toPublicKey(METADATA_PROGRAM_ID),\r\n        )\r\n      ).toBase58();\r\n    }*/\n\n    setOf100MetadataEditionKeys.push(editionKey);\n\n    if (setOf100MetadataEditionKeys.length >= 100) {\n      loadBatch();\n    }\n  }\n\n  if (setOf100MetadataEditionKeys.length >= 0) {\n    loadBatch();\n  }\n\n  await Promise.all(editionPromises);\n  console.log('Edition size', Object.keys(state.editions).length, Object.keys(state.masterEditions).length);\n};\n\nconst pullMetadataByCreators = (connection, state, updater) => {\n  console.log('pulling optimized nfts');\n  const whitelistedCreators = Object.values(state.whitelistedCreatorsByCreator);\n\n  const setter = async (prop, key, value) => {\n    if (prop === 'metadataByMint') {\n      await exports.initMetadata(value, state.whitelistedCreatorsByCreator, updater);\n    } else {\n      updater(prop, key, value);\n    }\n  };\n\n  const forEachAccount = exports.processingAccounts(setter);\n  const additionalPromises = [];\n\n  for (const creator of whitelistedCreators) {\n    for (let i = 0; i < actions_1.MAX_CREATOR_LIMIT; i++) {\n      const promise = web3_1.getProgramAccounts(connection, ids_1.METADATA_PROGRAM_ID, {\n        filters: [{\n          memcmp: {\n            offset: 1 + // key\n            32 + // update auth\n            32 + // mint\n            4 + // name string length\n            actions_1.MAX_NAME_LENGTH + // name\n            4 + // uri string length\n            actions_1.MAX_URI_LENGTH + // uri\n            4 + // symbol string length\n            actions_1.MAX_SYMBOL_LENGTH + // symbol\n            2 + // seller fee basis points\n            1 + // whether or not there is a creators vec\n            4 + // creators vec length\n            i * actions_1.MAX_CREATOR_LEN,\n            bytes: creator.info.address\n          }\n        }]\n      }).then(forEachAccount(processMetaData_1.processMetaData));\n      additionalPromises.push(promise);\n    }\n  }\n\n  return Promise.all(additionalPromises);\n};\n\nconst makeSetter = state => (prop, key, value) => {\n  if (prop === 'store') {\n    state[prop] = value;\n  } else if (prop === 'metadata') {\n    state.metadata.push(value);\n  } else if (prop === 'storeIndexer') {\n    state.storeIndexer = state.storeIndexer.filter(p => p.info.page.toNumber() != value.info.page.toNumber());\n    state.storeIndexer.push(value);\n    state.storeIndexer = state.storeIndexer.sort((a, b) => a.info.page.sub(b.info.page).toNumber());\n  } else {\n    state[prop][key] = value;\n  }\n\n  return state;\n};\n\nexports.makeSetter = makeSetter;\n\nconst processingAccounts = updater => fn => async accounts => {\n  await createPipelineExecutor_1.createPipelineExecutor(accounts.values(), account => fn(account, updater), {\n    sequence: 10,\n    delay: 1,\n    jobsCount: 3\n  });\n};\n\nexports.processingAccounts = processingAccounts;\n\nconst postProcessMetadata = async state => {\n  const values = Object.values(state.metadataByMint);\n\n  for (const metadata of values) {\n    await exports.metadataByMintUpdater(metadata, state);\n  }\n};\n\nconst metadataByMintUpdater = async (metadata, state) => {\n  var _a;\n\n  const key = metadata.info.mint;\n\n  if (isMetadataPartOfStore_1.isMetadataPartOfStore(metadata, state.whitelistedCreatorsByCreator)) {\n    await metadata.info.init();\n    const masterEditionKey = (_a = metadata.info) === null || _a === void 0 ? void 0 : _a.masterEdition;\n\n    if (masterEditionKey) {\n      state.metadataByMasterEdition[masterEditionKey] = metadata;\n    }\n\n    state.metadataByMint[key] = metadata;\n    if (!state.metadataByMint[key]) state.metadata.push(metadata);\n  } else {\n    delete state.metadataByMint[key];\n  }\n\n  return state;\n};\n\nexports.metadataByMintUpdater = metadataByMintUpdater;\n\nconst initMetadata = async (metadata, whitelistedCreators, setter) => {\n  var _a;\n\n  if (isMetadataPartOfStore_1.isMetadataPartOfStore(metadata, whitelistedCreators)) {\n    await metadata.info.init();\n    setter('metadataByMint', metadata.info.mint, metadata);\n    setter('metadata', '', metadata);\n    const masterEditionKey = (_a = metadata.info) === null || _a === void 0 ? void 0 : _a.masterEdition;\n\n    if (masterEditionKey) {\n      setter('metadataByMasterEdition', masterEditionKey, metadata);\n    }\n  }\n};\n\nexports.initMetadata = initMetadata;","map":{"version":3,"sources":["../../../../src/contexts/meta/loadAccounts.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.initMetadata = exports.metadataByMintUpdater = exports.processingAccounts = exports.makeSetter = exports.loadAccounts = exports.limitedLoadAccounts = exports.pullPage = exports.pullPages = exports.pullAuctionSubaccounts = exports.pullPayoutTickets = exports.pullYourMetadata = exports.pullStoreMetadata = exports.USE_SPEED_RUN = void 0;\r\nconst ids_1 = require(\"../../utils/ids\");\r\nconst models_1 = require(\"../../models\");\r\nconst actions_1 = require(\"../../actions\");\r\nconst lodash_1 = require(\"lodash\");\r\nconst metaplex_1 = require(\"../../models/metaplex\");\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\nconst isMetadataPartOfStore_1 = require(\"./isMetadataPartOfStore\");\r\nconst processAuctions_1 = require(\"./processAuctions\");\r\nconst processMetaplexAccounts_1 = require(\"./processMetaplexAccounts\");\r\nconst processMetaData_1 = require(\"./processMetaData\");\r\nconst processVaultData_1 = require(\"./processVaultData\");\r\nconst getEmptyMetaState_1 = require(\"./getEmptyMetaState\");\r\nconst getMultipleAccounts_1 = require(\"../accounts/getMultipleAccounts\");\r\nconst web3_1 = require(\"./web3\");\r\nconst createPipelineExecutor_1 = require(\"../../utils/createPipelineExecutor\");\r\nconst __1 = require(\"../..\");\r\nconst MULTIPLE_ACCOUNT_BATCH_SIZE = 100;\r\nexports.USE_SPEED_RUN = false;\r\nconst WHITELISTED_METADATA = ['98vYFjBYS9TguUMWQRPjy2SZuxKuUMcqR4vnQiLjZbte'];\r\nconst WHITELISTED_AUCTION = ['D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e'];\r\nconst AUCTION_TO_METADATA = {\r\n    D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e: [\r\n        '98vYFjBYS9TguUMWQRPjy2SZuxKuUMcqR4vnQiLjZbte',\r\n    ],\r\n};\r\nconst AUCTION_TO_VAULT = {\r\n    D8wMB5iLZnsV7XQjpwqXaDynUtFuDs7cRXvEGNj1NF1e: '3wHCBd3fYRPWjd5GqzrXanLJUKRyU3nECKbTPKfVwcFX',\r\n};\r\nconst WHITELISTED_AUCTION_MANAGER = [\r\n    '3HD2C8oCL8dpqbXo8hq3CMw6tRSZDZJGajLxnrZ3ZkYx',\r\n];\r\nconst WHITELISTED_VAULT = ['3wHCBd3fYRPWjd5GqzrXanLJUKRyU3nECKbTPKfVwcFX'];\r\nconst pullStoreMetadata = async (connection, tempCache) => {\r\n    const updateTemp = exports.makeSetter(tempCache);\r\n    const loadMetadata = () => pullMetadataByCreators(connection, tempCache, updateTemp);\r\n    const loadEditions = () => pullEditions(connection, updateTemp, tempCache, tempCache.metadata);\r\n    console.log('-------->Loading all metadata for store.');\r\n    await loadMetadata();\r\n    await loadEditions();\r\n    await postProcessMetadata(tempCache);\r\n    console.log('-------->Metadata processing complete.');\r\n    return tempCache;\r\n};\r\nexports.pullStoreMetadata = pullStoreMetadata;\r\nconst pullYourMetadata = async (connection, userTokenAccounts, tempCache) => {\r\n    const updateTemp = exports.makeSetter(tempCache);\r\n    console.log('--------->Pulling metadata for user.');\r\n    let currBatch = [];\r\n    let batches = [];\r\n    const editions = [];\r\n    for (let i = 0; i < userTokenAccounts.length; i++) {\r\n        if (userTokenAccounts[i].info.amount.toNumber() == 1) {\r\n            if (2 + currBatch.length > MULTIPLE_ACCOUNT_BATCH_SIZE) {\r\n                batches.push(currBatch);\r\n                currBatch = [];\r\n            }\r\n            else {\r\n                const edition = await actions_1.getEdition(userTokenAccounts[i].info.mint.toBase58());\r\n                const newAdd = [\r\n                    await actions_1.getMetadata(userTokenAccounts[i].info.mint.toBase58()),\r\n                    edition,\r\n                ];\r\n                editions.push(edition);\r\n                currBatch = currBatch.concat(newAdd);\r\n            }\r\n        }\r\n    }\r\n    if (currBatch.length > 0 && currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {\r\n        batches.push(currBatch);\r\n    }\r\n    console.log('------> From token accounts for user', 'produced', batches.length, 'batches of accounts to pull');\r\n    for (let i = 0; i < batches.length; i++) {\r\n        const accounts = await getMultipleAccounts_1.getMultipleAccounts(connection, batches[i], 'single');\r\n        if (accounts) {\r\n            console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');\r\n            for (let j = 0; j < accounts.keys.length; j++) {\r\n                const pubkey = accounts.keys[j];\r\n                await processMetaData_1.processMetaData({\r\n                    pubkey,\r\n                    account: accounts.array[j],\r\n                }, updateTemp);\r\n            }\r\n        }\r\n        else {\r\n            console.log('------->Failed to pull batch', i, 'skipping');\r\n        }\r\n    }\r\n    console.log('------> Pulling master editions for user');\r\n    currBatch = [];\r\n    batches = [];\r\n    for (let i = 0; i < editions.length; i++) {\r\n        if (1 + currBatch.length > MULTIPLE_ACCOUNT_BATCH_SIZE) {\r\n            batches.push(currBatch);\r\n            currBatch = [];\r\n        }\r\n        else if (tempCache.editions[editions[i]]) {\r\n            currBatch.push(tempCache.editions[editions[i]].info.parent);\r\n        }\r\n    }\r\n    if (currBatch.length > 0 && currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {\r\n        batches.push(currBatch);\r\n    }\r\n    console.log('------> From token accounts for user', 'produced', batches.length, 'batches of accounts to pull');\r\n    for (let i = 0; i < batches.length; i++) {\r\n        const accounts = await getMultipleAccounts_1.getMultipleAccounts(connection, batches[i], 'single');\r\n        if (accounts) {\r\n            console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');\r\n            for (let j = 0; j < accounts.keys.length; j++) {\r\n                const pubkey = accounts.keys[j];\r\n                await processMetaData_1.processMetaData({\r\n                    pubkey,\r\n                    account: accounts.array[j],\r\n                }, updateTemp);\r\n            }\r\n        }\r\n        else {\r\n            console.log('------->Failed to pull batch', i, 'skipping');\r\n        }\r\n    }\r\n    await postProcessMetadata(tempCache);\r\n    console.log('-------->User metadata processing complete.');\r\n    return tempCache;\r\n};\r\nexports.pullYourMetadata = pullYourMetadata;\r\nconst pullPayoutTickets = async (connection, tempCache) => {\r\n    const updateTemp = exports.makeSetter(tempCache);\r\n    const forEach = (fn) => async (accounts) => {\r\n        for (const account of accounts) {\r\n            await fn(account, updateTemp);\r\n        }\r\n    };\r\n    web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n        filters: [\r\n            {\r\n                dataSize: metaplex_1.MAX_PAYOUT_TICKET_SIZE,\r\n            },\r\n        ],\r\n    }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));\r\n    return tempCache;\r\n};\r\nexports.pullPayoutTickets = pullPayoutTickets;\r\nconst pullAuctionSubaccounts = async (connection, auction, tempCache) => {\r\n    var _a;\r\n    const updateTemp = exports.makeSetter(tempCache);\r\n    let cacheKey;\r\n    try {\r\n        cacheKey = await metaplex_1.getAuctionCache(auction);\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        console.log('Failed to get auction cache key');\r\n        return tempCache;\r\n    }\r\n    const cache = (_a = tempCache.auctionCaches[cacheKey]) === null || _a === void 0 ? void 0 : _a.info;\r\n    if (!cache) {\r\n        console.log('-----> No auction cache exists for', auction, 'returning');\r\n        return tempCache;\r\n    }\r\n    const forEach = (fn) => async (accounts) => {\r\n        for (const account of accounts) {\r\n            await fn(account, updateTemp);\r\n        }\r\n    };\r\n    const auctionExtKey = await actions_1.getAuctionExtended({\r\n        auctionProgramId: ids_1.AUCTION_ID,\r\n        resource: cache.vault,\r\n    });\r\n    const promises = [\r\n        // pull editions\r\n        pullEditions(connection, updateTemp, tempCache, cache.metadata.map(m => tempCache.metadataByMetadata[m])),\r\n        // pull auction data ext\r\n        connection\r\n            .getAccountInfo(ids_1.toPublicKey(auctionExtKey))\r\n            .then(a => a\r\n            ? processAuctions_1.processAuctions({ pubkey: auctionExtKey, account: a }, updateTemp)\r\n            : null),\r\n        // bidder metadata pull\r\n        web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 32,\r\n                        bytes: auction,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processAuctions_1.processAuctions)),\r\n        // bidder pot pull\r\n        web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 64,\r\n                        bytes: auction,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processAuctions_1.processAuctions)),\r\n        // safety deposit pull\r\n        web3_1.getProgramAccounts(connection, ids_1.VAULT_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 1,\r\n                        bytes: cache.vault,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processVaultData_1.processVaultData)),\r\n        // bid redemptions\r\n        ...WHITELISTED_AUCTION_MANAGER.map(() => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 9,\r\n                        bytes: cache.auctionManager,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))),\r\n        // safety deposit configs\r\n        web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 1,\r\n                        bytes: cache.auctionManager,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)),\r\n        // prize tracking tickets\r\n        ...cache.metadata\r\n            .map(md => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 1,\r\n                        bytes: md,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)))\r\n            .flat(),\r\n    ];\r\n    await Promise.all(promises);\r\n    console.log('---------->Pulled sub accounts for auction', auction);\r\n    return tempCache;\r\n};\r\nexports.pullAuctionSubaccounts = pullAuctionSubaccounts;\r\nconst pullPages = async (connection) => {\r\n    let i = 0;\r\n    let pageKey = await metaplex_1.getStoreIndexer(i);\r\n    let account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));\r\n    const pages = [];\r\n    while (account) {\r\n        pages.push({\r\n            info: metaplex_1.decodeStoreIndexer(account.data),\r\n            pubkey: pageKey,\r\n            account,\r\n        });\r\n        i++;\r\n        pageKey = await metaplex_1.getStoreIndexer(i);\r\n        account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));\r\n    }\r\n    return pages;\r\n};\r\nexports.pullPages = pullPages;\r\nconst pullPage = async (connection, page, tempCache) => {\r\n    const updateTemp = exports.makeSetter(tempCache);\r\n    const forEach = (fn) => async (accounts) => {\r\n        for (const account of accounts) {\r\n            await fn(account, updateTemp);\r\n        }\r\n    };\r\n    const pageKey = await metaplex_1.getStoreIndexer(page);\r\n    const account = await connection.getAccountInfo(new web3_js_1.PublicKey(pageKey));\r\n    if (account) {\r\n        processMetaplexAccounts_1.processMetaplexAccounts({\r\n            pubkey: pageKey,\r\n            account,\r\n        }, updateTemp);\r\n        const newPage = tempCache.storeIndexer.find(s => s.pubkey == pageKey);\r\n        const auctionCaches = await getMultipleAccounts_1.getMultipleAccounts(connection, (newPage === null || newPage === void 0 ? void 0 : newPage.info.auctionCaches) || [], 'single');\r\n        if (auctionCaches && auctionCaches.keys.length) {\r\n            console.log('-------->Page ', page, ' found', auctionCaches.keys.length, ' cached auction data');\r\n            auctionCaches.keys.map((pubkey, i) => {\r\n                processMetaplexAccounts_1.processMetaplexAccounts({\r\n                    pubkey,\r\n                    account: auctionCaches.array[i],\r\n                }, updateTemp);\r\n            });\r\n            const batches = [];\r\n            let currBatch = [];\r\n            for (let i = 0; i < auctionCaches.keys.length; i++) {\r\n                const cache = tempCache.auctionCaches[auctionCaches.keys[i]];\r\n                const totalNewAccountsToAdd = cache.info.metadata.length + 3;\r\n                if (totalNewAccountsToAdd + currBatch.length >\r\n                    MULTIPLE_ACCOUNT_BATCH_SIZE) {\r\n                    batches.push(currBatch);\r\n                    currBatch = [];\r\n                }\r\n                else {\r\n                    const newAdd = [\r\n                        ...cache.info.metadata,\r\n                        cache.info.auction,\r\n                        cache.info.auctionManager,\r\n                        cache.info.vault,\r\n                    ];\r\n                    currBatch = currBatch.concat(newAdd);\r\n                }\r\n            }\r\n            if (currBatch.length > 0 &&\r\n                currBatch.length <= MULTIPLE_ACCOUNT_BATCH_SIZE) {\r\n                batches.push(currBatch);\r\n            }\r\n            console.log('------> From account caches for page', page, 'produced', batches.length, 'batches of accounts to pull');\r\n            for (let i = 0; i < batches.length; i++) {\r\n                const accounts = await getMultipleAccounts_1.getMultipleAccounts(connection, batches[i], 'single');\r\n                if (accounts) {\r\n                    console.log('------->Pulled batch', i, 'with', batches[i].length, 'accounts, processing....');\r\n                    for (let i = 0; i < accounts.keys.length; i++) {\r\n                        const pubkey = accounts.keys[i];\r\n                        await processMetaplexAccounts_1.processMetaplexAccounts({\r\n                            pubkey,\r\n                            account: accounts.array[i],\r\n                        }, updateTemp);\r\n                        await processVaultData_1.processVaultData({\r\n                            pubkey,\r\n                            account: accounts.array[i],\r\n                        }, updateTemp);\r\n                        await processMetaData_1.processMetaData({\r\n                            pubkey,\r\n                            account: accounts.array[i],\r\n                        }, updateTemp);\r\n                        await processAuctions_1.processAuctions({\r\n                            pubkey,\r\n                            account: accounts.array[i],\r\n                        }, updateTemp);\r\n                    }\r\n                }\r\n                else {\r\n                    console.log('------->Failed to pull batch', i, 'skipping');\r\n                }\r\n            }\r\n            for (let i = 0; i < auctionCaches.keys.length; i++) {\r\n                const auctionCache = tempCache.auctionCaches[auctionCaches.keys[i]];\r\n                const metadata = auctionCache.info.metadata.map(s => tempCache.metadataByMetadata[s]);\r\n                tempCache.metadataByAuction[auctionCache.info.auction] = metadata;\r\n            }\r\n        }\r\n        if (page == 0) {\r\n            console.log('-------->Page 0, pulling creators and store');\r\n            await web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n                filters: [\r\n                    {\r\n                        dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE,\r\n                    },\r\n                ],\r\n            }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));\r\n            const store = __1.programIds().store;\r\n            if (store) {\r\n                const storeAcc = await connection.getAccountInfo(store);\r\n                if (storeAcc) {\r\n                    await processMetaplexAccounts_1.processMetaplexAccounts({ pubkey: store.toBase58(), account: storeAcc }, updateTemp);\r\n                }\r\n            }\r\n        }\r\n        await postProcessMetadata(tempCache);\r\n    }\r\n    return tempCache;\r\n};\r\nexports.pullPage = pullPage;\r\nconst limitedLoadAccounts = async (connection) => {\r\n    const tempCache = getEmptyMetaState_1.getEmptyMetaState();\r\n    const updateTemp = exports.makeSetter(tempCache);\r\n    const forEach = (fn) => async (accounts) => {\r\n        for (const account of accounts) {\r\n            await fn(account, updateTemp);\r\n        }\r\n    };\r\n    const pullMetadata = async (metadata) => {\r\n        const mdKey = new web3_js_1.PublicKey(metadata);\r\n        const md = await connection.getAccountInfo(mdKey);\r\n        const mdObject = actions_1.decodeMetadata(Buffer.from((md === null || md === void 0 ? void 0 : md.data) || new Uint8Array([])));\r\n        const editionKey = await actions_1.getEdition(mdObject.mint);\r\n        const editionData = await connection.getAccountInfo(new web3_js_1.PublicKey(editionKey));\r\n        if (md) {\r\n            //@ts-ignore\r\n            md.owner = md.owner.toBase58();\r\n            processMetaData_1.processMetaData({\r\n                pubkey: metadata,\r\n                account: md,\r\n            }, updateTemp);\r\n            if (editionData) {\r\n                //@ts-ignore\r\n                editionData.owner = editionData.owner.toBase58();\r\n                processMetaData_1.processMetaData({\r\n                    pubkey: editionKey,\r\n                    account: editionData,\r\n                }, updateTemp);\r\n            }\r\n        }\r\n    };\r\n    const pullAuction = async (auction) => {\r\n        const auctionExtendedKey = await actions_1.getAuctionExtended({\r\n            auctionProgramId: ids_1.AUCTION_ID,\r\n            resource: AUCTION_TO_VAULT[auction],\r\n        });\r\n        const auctionData = await getMultipleAccounts_1.getMultipleAccounts(connection, [auction, auctionExtendedKey], 'single');\r\n        if (auctionData) {\r\n            auctionData.keys.map((pubkey, i) => {\r\n                processAuctions_1.processAuctions({\r\n                    pubkey,\r\n                    account: auctionData.array[i],\r\n                }, updateTemp);\r\n            });\r\n        }\r\n    };\r\n    const pullAuctionManager = async (auctionManager) => {\r\n        const auctionManagerKey = new web3_js_1.PublicKey(auctionManager);\r\n        const auctionManagerData = await connection.getAccountInfo(auctionManagerKey);\r\n        if (auctionManagerData) {\r\n            //@ts-ignore\r\n            auctionManagerData.owner = auctionManagerData.owner.toBase58();\r\n            processMetaplexAccounts_1.processMetaplexAccounts({\r\n                pubkey: auctionManager,\r\n                account: auctionManagerData,\r\n            }, updateTemp);\r\n        }\r\n    };\r\n    const pullVault = async (vault) => {\r\n        const vaultKey = new web3_js_1.PublicKey(vault);\r\n        const vaultData = await connection.getAccountInfo(vaultKey);\r\n        if (vaultData) {\r\n            //@ts-ignore\r\n            vaultData.owner = vaultData.owner.toBase58();\r\n            processVaultData_1.processVaultData({\r\n                pubkey: vault,\r\n                account: vaultData,\r\n            }, updateTemp);\r\n        }\r\n    };\r\n    const promises = [\r\n        ...WHITELISTED_METADATA.map(md => pullMetadata(md)),\r\n        ...WHITELISTED_AUCTION.map(a => pullAuction(a)),\r\n        ...WHITELISTED_AUCTION_MANAGER.map(a => pullAuctionManager(a)),\r\n        ...WHITELISTED_VAULT.map(a => pullVault(a)),\r\n        // bidder metadata pull\r\n        ...WHITELISTED_AUCTION.map(a => web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 32,\r\n                        bytes: a,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processAuctions_1.processAuctions))),\r\n        // bidder pot pull\r\n        ...WHITELISTED_AUCTION.map(a => web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 64,\r\n                        bytes: a,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processAuctions_1.processAuctions))),\r\n        // safety deposit pull\r\n        ...WHITELISTED_VAULT.map(v => web3_1.getProgramAccounts(connection, ids_1.VAULT_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 1,\r\n                        bytes: v,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processVaultData_1.processVaultData))),\r\n        // bid redemptions\r\n        ...WHITELISTED_AUCTION_MANAGER.map(a => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 9,\r\n                        bytes: a,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))),\r\n        // safety deposit configs\r\n        ...WHITELISTED_AUCTION_MANAGER.map(a => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 1,\r\n                        bytes: a,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts))),\r\n        // prize tracking tickets\r\n        ...Object.keys(AUCTION_TO_METADATA)\r\n            .map(key => AUCTION_TO_METADATA[key]\r\n            .map(md => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n            filters: [\r\n                {\r\n                    memcmp: {\r\n                        offset: 1,\r\n                        bytes: md,\r\n                    },\r\n                },\r\n            ],\r\n        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)))\r\n            .flat())\r\n            .flat(),\r\n        // whitelisted creators\r\n        web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n            filters: [\r\n                {\r\n                    dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE,\r\n                },\r\n            ],\r\n        }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts)),\r\n    ];\r\n    await Promise.all(promises);\r\n    await postProcessMetadata(tempCache);\r\n    return tempCache;\r\n};\r\nexports.limitedLoadAccounts = limitedLoadAccounts;\r\nconst loadAccounts = async (connection) => {\r\n    const state = getEmptyMetaState_1.getEmptyMetaState();\r\n    const updateState = exports.makeSetter(state);\r\n    const forEachAccount = exports.processingAccounts(updateState);\r\n    const forEach = (fn) => async (accounts) => {\r\n        for (const account of accounts) {\r\n            await fn(account, updateState);\r\n        }\r\n    };\r\n    const loadVaults = () => web3_1.getProgramAccounts(connection, ids_1.VAULT_ID).then(forEachAccount(processVaultData_1.processVaultData));\r\n    const loadAuctions = () => web3_1.getProgramAccounts(connection, ids_1.AUCTION_ID).then(forEachAccount(processAuctions_1.processAuctions));\r\n    const loadMetaplex = () => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID).then(forEachAccount(processMetaplexAccounts_1.processMetaplexAccounts));\r\n    const loadCreators = () => web3_1.getProgramAccounts(connection, ids_1.METAPLEX_ID, {\r\n        filters: [\r\n            {\r\n                dataSize: models_1.MAX_WHITELISTED_CREATOR_SIZE,\r\n            },\r\n        ],\r\n    }).then(forEach(processMetaplexAccounts_1.processMetaplexAccounts));\r\n    const loadMetadata = () => pullMetadataByCreators(connection, state, updateState);\r\n    const loadEditions = () => pullEditions(connection, updateState, state, state.metadata);\r\n    const loading = [\r\n        loadCreators().then(loadMetadata).then(loadEditions),\r\n        loadVaults(),\r\n        loadAuctions(),\r\n        loadMetaplex(),\r\n    ];\r\n    await Promise.all(loading);\r\n    state.metadata = lodash_1.uniqWith(state.metadata, (a, b) => a.pubkey === b.pubkey);\r\n    return state;\r\n};\r\nexports.loadAccounts = loadAccounts;\r\nconst pullEditions = async (connection, updater, state, metadataArr) => {\r\n    console.log('Pulling editions for optimized metadata');\r\n    let setOf100MetadataEditionKeys = [];\r\n    const editionPromises = [];\r\n    const loadBatch = () => {\r\n        editionPromises.push(getMultipleAccounts_1.getMultipleAccounts(connection, setOf100MetadataEditionKeys, 'recent').then(processEditions));\r\n        setOf100MetadataEditionKeys = [];\r\n    };\r\n    const processEditions = (returnedAccounts) => {\r\n        for (let j = 0; j < returnedAccounts.array.length; j++) {\r\n            processMetaData_1.processMetaData({\r\n                pubkey: returnedAccounts.keys[j],\r\n                account: returnedAccounts.array[j],\r\n            }, updater);\r\n        }\r\n    };\r\n    for (const metadata of metadataArr) {\r\n        // let editionKey: StringPublicKey;\r\n        // TODO the nonce builder isnt working here, figure out why\r\n        //if (metadata.info.editionNonce === null) {\r\n        const editionKey = await actions_1.getEdition(metadata.info.mint);\r\n        /*} else {\r\n          editionKey = (\r\n            await PublicKey.createProgramAddress(\r\n              [\r\n                Buffer.from(METADATA_PREFIX),\r\n                toPublicKey(METADATA_PROGRAM_ID).toBuffer(),\r\n                toPublicKey(metadata.info.mint).toBuffer(),\r\n                new Uint8Array([metadata.info.editionNonce || 0]),\r\n              ],\r\n              toPublicKey(METADATA_PROGRAM_ID),\r\n            )\r\n          ).toBase58();\r\n        }*/\r\n        setOf100MetadataEditionKeys.push(editionKey);\r\n        if (setOf100MetadataEditionKeys.length >= 100) {\r\n            loadBatch();\r\n        }\r\n    }\r\n    if (setOf100MetadataEditionKeys.length >= 0) {\r\n        loadBatch();\r\n    }\r\n    await Promise.all(editionPromises);\r\n    console.log('Edition size', Object.keys(state.editions).length, Object.keys(state.masterEditions).length);\r\n};\r\nconst pullMetadataByCreators = (connection, state, updater) => {\r\n    console.log('pulling optimized nfts');\r\n    const whitelistedCreators = Object.values(state.whitelistedCreatorsByCreator);\r\n    const setter = async (prop, key, value) => {\r\n        if (prop === 'metadataByMint') {\r\n            await exports.initMetadata(value, state.whitelistedCreatorsByCreator, updater);\r\n        }\r\n        else {\r\n            updater(prop, key, value);\r\n        }\r\n    };\r\n    const forEachAccount = exports.processingAccounts(setter);\r\n    const additionalPromises = [];\r\n    for (const creator of whitelistedCreators) {\r\n        for (let i = 0; i < actions_1.MAX_CREATOR_LIMIT; i++) {\r\n            const promise = web3_1.getProgramAccounts(connection, ids_1.METADATA_PROGRAM_ID, {\r\n                filters: [\r\n                    {\r\n                        memcmp: {\r\n                            offset: 1 + // key\r\n                                32 + // update auth\r\n                                32 + // mint\r\n                                4 + // name string length\r\n                                actions_1.MAX_NAME_LENGTH + // name\r\n                                4 + // uri string length\r\n                                actions_1.MAX_URI_LENGTH + // uri\r\n                                4 + // symbol string length\r\n                                actions_1.MAX_SYMBOL_LENGTH + // symbol\r\n                                2 + // seller fee basis points\r\n                                1 + // whether or not there is a creators vec\r\n                                4 + // creators vec length\r\n                                i * actions_1.MAX_CREATOR_LEN,\r\n                            bytes: creator.info.address,\r\n                        },\r\n                    },\r\n                ],\r\n            }).then(forEachAccount(processMetaData_1.processMetaData));\r\n            additionalPromises.push(promise);\r\n        }\r\n    }\r\n    return Promise.all(additionalPromises);\r\n};\r\nconst makeSetter = (state) => (prop, key, value) => {\r\n    if (prop === 'store') {\r\n        state[prop] = value;\r\n    }\r\n    else if (prop === 'metadata') {\r\n        state.metadata.push(value);\r\n    }\r\n    else if (prop === 'storeIndexer') {\r\n        state.storeIndexer = state.storeIndexer.filter(p => p.info.page.toNumber() != value.info.page.toNumber());\r\n        state.storeIndexer.push(value);\r\n        state.storeIndexer = state.storeIndexer.sort((a, b) => a.info.page.sub(b.info.page).toNumber());\r\n    }\r\n    else {\r\n        state[prop][key] = value;\r\n    }\r\n    return state;\r\n};\r\nexports.makeSetter = makeSetter;\r\nconst processingAccounts = (updater) => (fn) => async (accounts) => {\r\n    await createPipelineExecutor_1.createPipelineExecutor(accounts.values(), account => fn(account, updater), {\r\n        sequence: 10,\r\n        delay: 1,\r\n        jobsCount: 3,\r\n    });\r\n};\r\nexports.processingAccounts = processingAccounts;\r\nconst postProcessMetadata = async (state) => {\r\n    const values = Object.values(state.metadataByMint);\r\n    for (const metadata of values) {\r\n        await exports.metadataByMintUpdater(metadata, state);\r\n    }\r\n};\r\nconst metadataByMintUpdater = async (metadata, state) => {\r\n    var _a;\r\n    const key = metadata.info.mint;\r\n    if (isMetadataPartOfStore_1.isMetadataPartOfStore(metadata, state.whitelistedCreatorsByCreator)) {\r\n        await metadata.info.init();\r\n        const masterEditionKey = (_a = metadata.info) === null || _a === void 0 ? void 0 : _a.masterEdition;\r\n        if (masterEditionKey) {\r\n            state.metadataByMasterEdition[masterEditionKey] = metadata;\r\n        }\r\n        state.metadataByMint[key] = metadata;\r\n        if (!state.metadataByMint[key])\r\n            state.metadata.push(metadata);\r\n    }\r\n    else {\r\n        delete state.metadataByMint[key];\r\n    }\r\n    return state;\r\n};\r\nexports.metadataByMintUpdater = metadataByMintUpdater;\r\nconst initMetadata = async (metadata, whitelistedCreators, setter) => {\r\n    var _a;\r\n    if (isMetadataPartOfStore_1.isMetadataPartOfStore(metadata, whitelistedCreators)) {\r\n        await metadata.info.init();\r\n        setter('metadataByMint', metadata.info.mint, metadata);\r\n        setter('metadata', '', metadata);\r\n        const masterEditionKey = (_a = metadata.info) === null || _a === void 0 ? void 0 : _a.masterEdition;\r\n        if (masterEditionKey) {\r\n            setter('metadataByMasterEdition', masterEditionKey, metadata);\r\n        }\r\n    }\r\n};\r\nexports.initMetadata = initMetadata;\r\n//# sourceMappingURL=loadAccounts.js.map"]},"metadata":{},"sourceType":"script"}