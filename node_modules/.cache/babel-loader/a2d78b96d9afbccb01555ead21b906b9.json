{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useMeta = exports.MetaProvider = void 0;\n\nconst react_1 = __importStar(require(\"react\"));\n\nconst queryExtendedMetadata_1 = require(\"./queryExtendedMetadata\");\n\nconst subscribeAccountsChange_1 = require(\"./subscribeAccountsChange\");\n\nconst getEmptyMetaState_1 = require(\"./getEmptyMetaState\");\n\nconst loadAccounts_1 = require(\"./loadAccounts\");\n\nconst connection_1 = require(\"../connection\");\n\nconst store_1 = require(\"../store\");\n\nconst actions_1 = require(\"../../actions\");\n\nconst _1 = require(\".\");\n\nconst __1 = require(\"../..\");\n\nconst MetaContext = react_1.default.createContext({ ...getEmptyMetaState_1.getEmptyMetaState(),\n  isLoading: false,\n  // @ts-ignore\n  update: () => [actions_1.AuctionData, actions_1.BidderMetadata, actions_1.BidderPot]\n});\n\nfunction MetaProvider({\n  children = null\n}) {\n  const connection = connection_1.useConnection();\n  const {\n    isReady,\n    storeAddress\n  } = store_1.useStore();\n  const [state, setState] = react_1.useState(getEmptyMetaState_1.getEmptyMetaState());\n  const [page, setPage] = react_1.useState(0);\n  const [metadataLoaded, setMetadataLoaded] = react_1.useState(false);\n  const [lastLength, setLastLength] = react_1.useState(0);\n\n  const {\n    userAccounts\n  } = __1.useUserAccounts();\n\n  const [isLoading, setIsLoading] = react_1.useState(true);\n  const updateMints = react_1.useCallback(async metadataByMint => {\n    try {\n      const {\n        metadata,\n        mintToMetadata\n      } = await queryExtendedMetadata_1.queryExtendedMetadata(connection, metadataByMint);\n      setState(current => ({ ...current,\n        metadata,\n        metadataByMint: mintToMetadata\n      }));\n    } catch (er) {\n      console.error(er);\n    }\n  }, [setState]);\n\n  async function pullAllMetadata() {\n    if (isLoading) return false;\n\n    if (!storeAddress) {\n      if (isReady) {\n        setIsLoading(false);\n      }\n\n      return;\n    } else if (!state.store) {\n      setIsLoading(true);\n    }\n\n    setIsLoading(true);\n    const nextState = await _1.pullStoreMetadata(connection, state);\n    setIsLoading(false);\n    setState(nextState);\n    await updateMints(nextState.metadataByMint);\n    return [];\n  }\n\n  async function pullBillingPage(auctionAddress) {\n    if (isLoading) return false;\n\n    if (!storeAddress) {\n      if (isReady) {\n        setIsLoading(false);\n      }\n\n      return;\n    } else if (!state.store) {\n      setIsLoading(true);\n    }\n\n    const nextState = await _1.pullAuctionSubaccounts(connection, auctionAddress, state);\n    console.log('-----> Pulling all payout tickets');\n    await _1.pullPayoutTickets(connection, nextState);\n    setState(nextState);\n    await updateMints(nextState.metadataByMint);\n    return [];\n  }\n\n  async function pullAuctionPage(auctionAddress) {\n    if (isLoading) return state;\n\n    if (!storeAddress) {\n      if (isReady) {\n        setIsLoading(false);\n      }\n\n      return state;\n    } else if (!state.store) {\n      setIsLoading(true);\n    }\n\n    const nextState = await _1.pullAuctionSubaccounts(connection, auctionAddress, state);\n    setState(nextState);\n    await updateMints(nextState.metadataByMint);\n    return nextState;\n  }\n\n  async function pullAllSiteData() {\n    if (isLoading) return state;\n\n    if (!storeAddress) {\n      if (isReady) {\n        setIsLoading(false);\n      }\n\n      return state;\n    } else if (!state.store) {\n      setIsLoading(true);\n    }\n\n    console.log('------->Query started');\n    const nextState = await loadAccounts_1.loadAccounts(connection);\n    console.log('------->Query finished');\n    setState(nextState);\n    await updateMints(nextState.metadataByMint);\n    return;\n  }\n\n  async function update(auctionAddress, bidderAddress, userTokenAccounts) {\n    if (!storeAddress) {\n      if (isReady) {\n        //@ts-ignore\n        window.loadingData = false;\n        setIsLoading(false);\n      }\n\n      return;\n    } else if (!state.store) {\n      //@ts-ignore\n      window.loadingData = true;\n      setIsLoading(true);\n    }\n\n    console.log('-----> Query started');\n    let nextState = await _1.pullPage(connection, page, state);\n\n    if (nextState.storeIndexer.length) {\n      if (loadAccounts_1.USE_SPEED_RUN) {\n        nextState = await loadAccounts_1.limitedLoadAccounts(connection);\n        console.log('------->Query finished');\n        setState(nextState); //@ts-ignore\n\n        window.loadingData = false;\n        setIsLoading(false);\n      } else {\n        console.log('------->Pagination detected, pulling page', page); // Ensures we get the latest so beat race conditions and avoid double pulls.\n\n        let currMetadataLoaded = false;\n        setMetadataLoaded(loaded => {\n          currMetadataLoaded = loaded;\n          return loaded;\n        });\n\n        if (userTokenAccounts && userTokenAccounts.length && !currMetadataLoaded) {\n          console.log('--------->User metadata loading now.');\n          setMetadataLoaded(true);\n          nextState = await loadAccounts_1.pullYourMetadata(connection, userTokenAccounts, nextState);\n        }\n\n        const auction = window.location.href.match(/#\\/auction\\/(\\w+)/);\n        const billing = window.location.href.match(/#\\/auction\\/(\\w+)\\/billing/);\n\n        if (auction && page == 0) {\n          console.log('---------->Loading auction page on initial load, pulling sub accounts');\n          nextState = await _1.pullAuctionSubaccounts(connection, auction[1], nextState);\n\n          if (billing) {\n            console.log('-----> Pulling all payout tickets');\n            await _1.pullPayoutTickets(connection, nextState);\n          }\n        }\n\n        let currLastLength;\n        setLastLength(last => {\n          currLastLength = last;\n          return last;\n        });\n\n        if (nextState.storeIndexer.length != currLastLength) {\n          setPage(page => page + 1);\n        }\n\n        setLastLength(nextState.storeIndexer.length); //@ts-ignore\n\n        window.loadingData = false;\n        setIsLoading(false);\n        setState(nextState);\n      }\n    } else {\n      console.log('------->No pagination detected');\n      nextState = !loadAccounts_1.USE_SPEED_RUN ? await loadAccounts_1.loadAccounts(connection) : await loadAccounts_1.limitedLoadAccounts(connection);\n      console.log('------->Query finished');\n      setState(nextState); //@ts-ignore\n\n      window.loadingData = false;\n      setIsLoading(false);\n    }\n\n    console.log('------->set finished');\n    await updateMints(nextState.metadataByMint);\n\n    if (auctionAddress && bidderAddress) {\n      const auctionBidderKey = auctionAddress + '-' + bidderAddress;\n      return [nextState.auctions[auctionAddress], nextState.bidderPotsByAuctionAndBidder[auctionBidderKey], nextState.bidderMetadataByAuctionAndBidder[auctionBidderKey]];\n    }\n  }\n\n  react_1.useEffect(() => {\n    //@ts-ignore\n    if (window.loadingData) {\n      console.log('currently another update is running, so queue for 3s...');\n      const interval = setInterval(() => {\n        //@ts-ignore\n        if (window.loadingData) {\n          console.log('not running queued update right now, still loading');\n        } else {\n          console.log('running queued update');\n          update(undefined, undefined, userAccounts);\n          clearInterval(interval);\n        }\n      }, 3000);\n    } else {\n      console.log('no update is running, updating.');\n      update(undefined, undefined, userAccounts);\n    }\n  }, [connection, setState, updateMints, storeAddress, isReady, page, userAccounts.length > 0]);\n  react_1.useEffect(() => {\n    if (isLoading) {\n      return;\n    }\n\n    return subscribeAccountsChange_1.subscribeAccountsChange(connection, () => state, setState);\n  }, [connection, setState, isLoading, state]); // TODO: fetch names dynamically\n  // TODO: get names for creators\n  // useEffect(() => {\n  //   (async () => {\n  //     const twitterHandles = await connection.getProgramAccounts(NAME_PROGRAM_ID, {\n  //      filters: [\n  //        {\n  //           dataSize: TWITTER_ACCOUNT_LENGTH,\n  //        },\n  //        {\n  //          memcmp: {\n  //           offset: VERIFICATION_AUTHORITY_OFFSET,\n  //           bytes: TWITTER_VERIFICATION_AUTHORITY.toBase58()\n  //          }\n  //        }\n  //      ]\n  //     });\n  //     const handles = twitterHandles.map(t => {\n  //       const owner = new PublicKey(t.account.data.slice(32, 64));\n  //       const name = t.account.data.slice(96, 114).toString();\n  //     });\n  //     console.log(handles);\n  //   })();\n  // }, [whitelistedCreatorsByCreator]);\n\n  return react_1.default.createElement(MetaContext.Provider, {\n    value: { ...state,\n      // @ts-ignore\n      update,\n      pullAuctionPage,\n      pullAllMetadata,\n      pullBillingPage,\n      pullAllSiteData,\n      isLoading\n    }\n  }, children);\n}\n\nexports.MetaProvider = MetaProvider;\n\nconst useMeta = () => {\n  const context = react_1.useContext(MetaContext);\n  return context;\n};\n\nexports.useMeta = useMeta;","map":{"version":3,"sources":["../../../../src/contexts/meta/meta.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.useMeta = exports.MetaProvider = void 0;\r\nconst react_1 = __importStar(require(\"react\"));\r\nconst queryExtendedMetadata_1 = require(\"./queryExtendedMetadata\");\r\nconst subscribeAccountsChange_1 = require(\"./subscribeAccountsChange\");\r\nconst getEmptyMetaState_1 = require(\"./getEmptyMetaState\");\r\nconst loadAccounts_1 = require(\"./loadAccounts\");\r\nconst connection_1 = require(\"../connection\");\r\nconst store_1 = require(\"../store\");\r\nconst actions_1 = require(\"../../actions\");\r\nconst _1 = require(\".\");\r\nconst __1 = require(\"../..\");\r\nconst MetaContext = react_1.default.createContext({\r\n    ...getEmptyMetaState_1.getEmptyMetaState(),\r\n    isLoading: false,\r\n    // @ts-ignore\r\n    update: () => [actions_1.AuctionData, actions_1.BidderMetadata, actions_1.BidderPot],\r\n});\r\nfunction MetaProvider({ children = null }) {\r\n    const connection = connection_1.useConnection();\r\n    const { isReady, storeAddress } = store_1.useStore();\r\n    const [state, setState] = react_1.useState(getEmptyMetaState_1.getEmptyMetaState());\r\n    const [page, setPage] = react_1.useState(0);\r\n    const [metadataLoaded, setMetadataLoaded] = react_1.useState(false);\r\n    const [lastLength, setLastLength] = react_1.useState(0);\r\n    const { userAccounts } = __1.useUserAccounts();\r\n    const [isLoading, setIsLoading] = react_1.useState(true);\r\n    const updateMints = react_1.useCallback(async (metadataByMint) => {\r\n        try {\r\n            const { metadata, mintToMetadata } = await queryExtendedMetadata_1.queryExtendedMetadata(connection, metadataByMint);\r\n            setState(current => ({\r\n                ...current,\r\n                metadata,\r\n                metadataByMint: mintToMetadata,\r\n            }));\r\n        }\r\n        catch (er) {\r\n            console.error(er);\r\n        }\r\n    }, [setState]);\r\n    async function pullAllMetadata() {\r\n        if (isLoading)\r\n            return false;\r\n        if (!storeAddress) {\r\n            if (isReady) {\r\n                setIsLoading(false);\r\n            }\r\n            return;\r\n        }\r\n        else if (!state.store) {\r\n            setIsLoading(true);\r\n        }\r\n        setIsLoading(true);\r\n        const nextState = await _1.pullStoreMetadata(connection, state);\r\n        setIsLoading(false);\r\n        setState(nextState);\r\n        await updateMints(nextState.metadataByMint);\r\n        return [];\r\n    }\r\n    async function pullBillingPage(auctionAddress) {\r\n        if (isLoading)\r\n            return false;\r\n        if (!storeAddress) {\r\n            if (isReady) {\r\n                setIsLoading(false);\r\n            }\r\n            return;\r\n        }\r\n        else if (!state.store) {\r\n            setIsLoading(true);\r\n        }\r\n        const nextState = await _1.pullAuctionSubaccounts(connection, auctionAddress, state);\r\n        console.log('-----> Pulling all payout tickets');\r\n        await _1.pullPayoutTickets(connection, nextState);\r\n        setState(nextState);\r\n        await updateMints(nextState.metadataByMint);\r\n        return [];\r\n    }\r\n    async function pullAuctionPage(auctionAddress) {\r\n        if (isLoading)\r\n            return state;\r\n        if (!storeAddress) {\r\n            if (isReady) {\r\n                setIsLoading(false);\r\n            }\r\n            return state;\r\n        }\r\n        else if (!state.store) {\r\n            setIsLoading(true);\r\n        }\r\n        const nextState = await _1.pullAuctionSubaccounts(connection, auctionAddress, state);\r\n        setState(nextState);\r\n        await updateMints(nextState.metadataByMint);\r\n        return nextState;\r\n    }\r\n    async function pullAllSiteData() {\r\n        if (isLoading)\r\n            return state;\r\n        if (!storeAddress) {\r\n            if (isReady) {\r\n                setIsLoading(false);\r\n            }\r\n            return state;\r\n        }\r\n        else if (!state.store) {\r\n            setIsLoading(true);\r\n        }\r\n        console.log('------->Query started');\r\n        const nextState = await loadAccounts_1.loadAccounts(connection);\r\n        console.log('------->Query finished');\r\n        setState(nextState);\r\n        await updateMints(nextState.metadataByMint);\r\n        return;\r\n    }\r\n    async function update(auctionAddress, bidderAddress, userTokenAccounts) {\r\n        if (!storeAddress) {\r\n            if (isReady) {\r\n                //@ts-ignore\r\n                window.loadingData = false;\r\n                setIsLoading(false);\r\n            }\r\n            return;\r\n        }\r\n        else if (!state.store) {\r\n            //@ts-ignore\r\n            window.loadingData = true;\r\n            setIsLoading(true);\r\n        }\r\n        console.log('-----> Query started');\r\n        let nextState = await _1.pullPage(connection, page, state);\r\n        if (nextState.storeIndexer.length) {\r\n            if (loadAccounts_1.USE_SPEED_RUN) {\r\n                nextState = await loadAccounts_1.limitedLoadAccounts(connection);\r\n                console.log('------->Query finished');\r\n                setState(nextState);\r\n                //@ts-ignore\r\n                window.loadingData = false;\r\n                setIsLoading(false);\r\n            }\r\n            else {\r\n                console.log('------->Pagination detected, pulling page', page);\r\n                // Ensures we get the latest so beat race conditions and avoid double pulls.\r\n                let currMetadataLoaded = false;\r\n                setMetadataLoaded(loaded => {\r\n                    currMetadataLoaded = loaded;\r\n                    return loaded;\r\n                });\r\n                if (userTokenAccounts &&\r\n                    userTokenAccounts.length &&\r\n                    !currMetadataLoaded) {\r\n                    console.log('--------->User metadata loading now.');\r\n                    setMetadataLoaded(true);\r\n                    nextState = await loadAccounts_1.pullYourMetadata(connection, userTokenAccounts, nextState);\r\n                }\r\n                const auction = window.location.href.match(/#\\/auction\\/(\\w+)/);\r\n                const billing = window.location.href.match(/#\\/auction\\/(\\w+)\\/billing/);\r\n                if (auction && page == 0) {\r\n                    console.log('---------->Loading auction page on initial load, pulling sub accounts');\r\n                    nextState = await _1.pullAuctionSubaccounts(connection, auction[1], nextState);\r\n                    if (billing) {\r\n                        console.log('-----> Pulling all payout tickets');\r\n                        await _1.pullPayoutTickets(connection, nextState);\r\n                    }\r\n                }\r\n                let currLastLength;\r\n                setLastLength(last => {\r\n                    currLastLength = last;\r\n                    return last;\r\n                });\r\n                if (nextState.storeIndexer.length != currLastLength) {\r\n                    setPage(page => page + 1);\r\n                }\r\n                setLastLength(nextState.storeIndexer.length);\r\n                //@ts-ignore\r\n                window.loadingData = false;\r\n                setIsLoading(false);\r\n                setState(nextState);\r\n            }\r\n        }\r\n        else {\r\n            console.log('------->No pagination detected');\r\n            nextState = !loadAccounts_1.USE_SPEED_RUN\r\n                ? await loadAccounts_1.loadAccounts(connection)\r\n                : await loadAccounts_1.limitedLoadAccounts(connection);\r\n            console.log('------->Query finished');\r\n            setState(nextState);\r\n            //@ts-ignore\r\n            window.loadingData = false;\r\n            setIsLoading(false);\r\n        }\r\n        console.log('------->set finished');\r\n        await updateMints(nextState.metadataByMint);\r\n        if (auctionAddress && bidderAddress) {\r\n            const auctionBidderKey = auctionAddress + '-' + bidderAddress;\r\n            return [\r\n                nextState.auctions[auctionAddress],\r\n                nextState.bidderPotsByAuctionAndBidder[auctionBidderKey],\r\n                nextState.bidderMetadataByAuctionAndBidder[auctionBidderKey],\r\n            ];\r\n        }\r\n    }\r\n    react_1.useEffect(() => {\r\n        //@ts-ignore\r\n        if (window.loadingData) {\r\n            console.log('currently another update is running, so queue for 3s...');\r\n            const interval = setInterval(() => {\r\n                //@ts-ignore\r\n                if (window.loadingData) {\r\n                    console.log('not running queued update right now, still loading');\r\n                }\r\n                else {\r\n                    console.log('running queued update');\r\n                    update(undefined, undefined, userAccounts);\r\n                    clearInterval(interval);\r\n                }\r\n            }, 3000);\r\n        }\r\n        else {\r\n            console.log('no update is running, updating.');\r\n            update(undefined, undefined, userAccounts);\r\n        }\r\n    }, [\r\n        connection,\r\n        setState,\r\n        updateMints,\r\n        storeAddress,\r\n        isReady,\r\n        page,\r\n        userAccounts.length > 0,\r\n    ]);\r\n    react_1.useEffect(() => {\r\n        if (isLoading) {\r\n            return;\r\n        }\r\n        return subscribeAccountsChange_1.subscribeAccountsChange(connection, () => state, setState);\r\n    }, [connection, setState, isLoading, state]);\r\n    // TODO: fetch names dynamically\r\n    // TODO: get names for creators\r\n    // useEffect(() => {\r\n    //   (async () => {\r\n    //     const twitterHandles = await connection.getProgramAccounts(NAME_PROGRAM_ID, {\r\n    //      filters: [\r\n    //        {\r\n    //           dataSize: TWITTER_ACCOUNT_LENGTH,\r\n    //        },\r\n    //        {\r\n    //          memcmp: {\r\n    //           offset: VERIFICATION_AUTHORITY_OFFSET,\r\n    //           bytes: TWITTER_VERIFICATION_AUTHORITY.toBase58()\r\n    //          }\r\n    //        }\r\n    //      ]\r\n    //     });\r\n    //     const handles = twitterHandles.map(t => {\r\n    //       const owner = new PublicKey(t.account.data.slice(32, 64));\r\n    //       const name = t.account.data.slice(96, 114).toString();\r\n    //     });\r\n    //     console.log(handles);\r\n    //   })();\r\n    // }, [whitelistedCreatorsByCreator]);\r\n    return (react_1.default.createElement(MetaContext.Provider, { value: {\r\n            ...state,\r\n            // @ts-ignore\r\n            update,\r\n            pullAuctionPage,\r\n            pullAllMetadata,\r\n            pullBillingPage,\r\n            pullAllSiteData,\r\n            isLoading,\r\n        } }, children));\r\n}\r\nexports.MetaProvider = MetaProvider;\r\nconst useMeta = () => {\r\n    const context = react_1.useContext(MetaContext);\r\n    return context;\r\n};\r\nexports.useMeta = useMeta;\r\n//# sourceMappingURL=meta.js.map"]},"metadata":{},"sourceType":"script"}